# 0. 不要拘泥于小节

只规定需要规定的事情:不要强制施加个人喜好或者过时的做法。

---

有些问题只是个人喜好,并不影响程序的正确性或者可读性,所以这些问题不应该出现在编程规范中。任何专业程序员都可以很容易地阅读和编写与其习惯的格式略有不同的代码。应该在每个源文件乃至每个项目中都使用一致的格式,因为同一段代码中要在几种编程风格(style)之间换来换去是很不舒服的。但是无需在多个项目或者整个公司范围内强制实施一致的格式。

* 不要规定缩进多少,应该规定要用缩进来体现代码的结构:缩进空格的数量可以遵照个人习惯,但是至少在每个文件中应该保持一致。
* 不要强制行的具体长度,应该保证代码行的长度有利于阅读:可以遵照个人习惯来决定行长,但是不要过长。研究表明,文字长度不超过10个单词最利于阅读。
* 不要在命名方面规定过多,应该规定的是使用一致的命名规范:只有两点是必需的: (1)永远不要使用“晦涩的名称”,即以下划线开始或者包含双下划线的名称; (2)总是使用形如ONLY_UPPERCASE_NAMES的全大写字母表示宏,不要考虑使用常见的词或者缩略语作为宏的名称(包括常见的模板参数,比如T和U:像“#define T anything"这样的代码是极容易混淆的)。此外,应该使用一致的、有意义的名称,遵循文件的或者模块的规范。(如果你无法决定自己的命名规范,可以尝试如下命名规则:类、函数和枚举的名称形如LikeThis,即单词首字母大写;变量名形如likeThis,即第一个单词首字母小写,第二个单词首字母大写;私有成员变量名形如ikeThis-:宏名称形如LIKETHIS.)
* 不要规定注释体例(除非需要使用工具从特定的体例中提取出文档) ,应该编写有用的注释:尽可能编写代码而不是写注释(比如,见第16条),不要在注释中重复写代码语义,这样很容易产生不一致。应该编写的是解释方法和原理的说明性注释。

# 1. 在高警告级别干净利落地进行编译

高度重视警告:使用编译器的最高警告级别。应该要求构建是干净利落的(没有警告)。理,解所有的警告。通过修改代码而不是降低警告级别来排除警告。

---

编译器是你的朋友。如果它对某个构造发出警告,这经常是说明你的代码中存有潜在的问题成功的构建应该是无声无息的(没有警告的)。如果不是这样,你很快就会养成不仔细查看输出的习惯,从而漏过真正的问题(见第2条)。

排除警告的正确做法是: (1)把它弄清楚;然后, (2)改写代码以排除警告,并使代码阅读者和编译器都能更加清楚,代码是按编写者的意图执行的。

即使程序一开始似乎能够正确运行,也还是要这样做。即使你能够肯定警告是良性的,仍然要这样做。因为良性警告的后面可能隐藏着未来指向真正危险的警告。

## 例外情况

有时候,编译器可能会发出烦人的甚至虚假的警告(即纯属噪声的警告),但是又没有提供消除的方法,这时忙于修改代码解决这个警告可能是劳而尤功或者事倍功半的。如果遇到了这种罕见的情形,作为团队决定,应该避免对纯粹无益的警告再做无用功:单独禁用这个警告,但是要尽可能在刷部禁用,并且编写一个清晰的注释,说明为什么必须禁用。

# 2. 使用自动构建系统

一次按键就解决问题:使用完全自动化(“单操作”)的构建系统,无需用户干预即可构建整一个项目。

---

单操作的构建过程非常重要。它应该能将源文件可靠和可重复地转换为可以交付的软件包。现在已经有了大量自动构建工具,没有理由不用。所以,选择一种,用起来吧。

我们曾经见到不少开发单位忽略了构建系统“单操作”这一需求。有些开发单位认为,用鼠标四处点击几下,运行一些实用工具来注册COM/CORBA服务器,手工复制一些文件,就是很不错的构建过程了。可是,我们都不应该将时间和精力浪费在机器可以干得更快更好的事情上。自动的、可靠的、单操作的构建是非常必要的。

成功的构建应该无声无息,不产生任何警告(见第1条),理想的构建过程不会出现噪声,只会出现一条日志信息: “构建成功"。

==构建有两种模式:增量构建和完全构建。==增量构建只重新构建上次构建(可以是增量的或者完全的)以来发生改变的部分。注意:两次连续增量构建中的第二次构建不应该编写任何输出文件;否则,可能会出现依赖循环(见第22条),构建系统也可能会执行不必要的操作(比如,编写假的肯定要丢弃的临时文件)。

一个项目的完全构建可能有不同形式。可以考虑通过改变许多基本特性来参数化控制构建过程的参数;候选的特性包括目标架构,调试模式还是发布模式,以及范围(基本文件、所有文件、还是完整的安装文件)。一种构建设置能够生成产品的基本可执行文件和库,另一种设置可能还会生成附属文件,而完全构建则可能生成包括所有文件、第三方可重发行文件和安装代码在内的安装文件。

随着项目日渐发展,不使用自动构建所带来的成本也会逐渐增加。如果没有从一开始就使用自动构建,时间和资源的浪费就将无可避免。更糟糕的情况是,到了不得不使用自动构建的时候,你所面临的压力将比项目开始时大得多。大型项目可能应该设置一个“构建管理员”,他的工作就是负责构建系统。

# 3. 使用版本控制系统

请使用==版本控制系统(version control system, VCS)==。永远不要让文件长时间地登出。在新的单元测试通过之后,应该频繁登入。确保登入的代码不会影响构建成功。

---

几乎所有大一点的项目都需要一个以上的开发人员和(或)一周以上的开发时间。在这样的项目中,将需要比较同一文件的各个历史版本,以确定修改是何时(以及/或者由谁)进行的。需要控制和管理源代码的变更。

如果有多个开发人员,他们将会并行地进行修改,可能会在同一时间修改同一文件的不同部分。此时,就需要能对文件进行自动登出/版本管理的工具了,有些情况下还需要并发编辑的合并功能。版本控制系统能够自动化和控制登出、版本管理及合并操作。版本控制系统能够比人工实施更快更正确。而且我们也不需要在管理琐事上浪费时间—编写软件才是我们的工作。

即使是单独工作的开发人员,也有脑子短路的瞬间,需要搞清楚何时为什么引入了某个错误,或者进行了某个修改。我们都难免如此。==版本控制系统能够自动地跟踪每个文件的历史==,使我们能够“让时光倒流”。问题并不在于你是否想从历史中寻找答案,而在于你到底何时需要。

不要破坏构建。版本控制系统中的代码必须总能构建成功。

由于目前能够找到大量的版本控制系统,我们没有任何借口拒之门外。最廉价也最流行的版本控制系统是cvs,这个工具非常灵活,提供了TCP/P访问功能,可以选择增强安全性(提供使用ssh协议作为后端),可以通过脚本编程实现极佳的管理功能,甚至还有图形界面。许多其他的版本控制系统产品要么将cvs作为模仿的标准,要么是以其为基础再构建新的功能。

## 例外情况

只有一个程序员且从头至尾只需一周的项目,可能不需要版本控制系统。

# 4. 在代码审查上投入

审查代码:更多的关注有助于提高质量。==亮出自己的代码,阅读别人的代码。==互相学习,彼此都会受益。

---

好的代码审查过程对开发团队有许多方面的益处,它能够

- 通过来自同伴的良性压力提高代码质量。
- 找出错误、不可移植的代码(如果适用)和潜在的扩展问题。
- 通过思想交流获得更好的设计和实现。
- 快速培养新同事和初入门者。
- 在团队中形成共同的价值观和集体主义。
- 增强整体实力,提升自信心、动力和职业荣誉感。

许多开发单位现在既不奖励高质量的代码和高质量的团队,也不投入时间和资金予以鼓励。我们估计几年之内这种情况仍然会存在,但是趋势已经在缓慢变化,这部分是因为软件安全性需求的不断增加。代码审查恰恰有助于提高软件的安全性,而且还是内部培训的一种极佳方法(而且没有成本)!

如果老板现在还不支持代码审查过程,那就先从提高管理层的认识做起(提示:一开始先给他们看看这本书),同时尽最大努力想各种办法腾出时间进行审查。这种时间是值得花的。代码审查应该成为软件开发周期中的常规环节。如果能够与同事就奖惩制度(根据积极因素,·可能还有消极因素)达成一致,那就更好了。

代码审查无需太形式主义,最好通过书面形式进行—一封简单的电子邮件就足够了。这样能够更容易地跟踪你自己的过程,避免重复。在审查别人的代码时,可能需要保存一份核对表以备参考。我们举贤不避亲地推荐,本书的目录就是一个很好的核对表。愿你使用愉快!小结:我们知道这里有些老调重弹了,但还是不得不说。我们的天性都讨厌代码审查,但是内心又有一个小小的天才程序员乐此不疲,因为它富于成效,而且能够获得更好的代码和更可靠的应用程序。

# 5.  一个实体应该只有一个紧凑的职责

一次只解决一个问题:只给一个实体(变量、类、函数、名称空间、模块和库)赋予一个定义良好的职责。随着实体变大,其职责范围自然也会扩大,但是职责不应该发散。

---

如果一个实体有几个不同的目的,则给使用带来的难度往往会激增,因为这种实体除了会增加理解难度、复杂性和各部分中的错误外,还会导致其他问题。这种实体不仅更大(常常毫无合理理由),而且更难以使用和维护。此外,这种实体经常会为自身的一些特定用途提供有问题的接口,因为各个功能领域之间的部分重叠,会影响干净利落地实现每个功能所需的洞察力。

具有多个不同职责的实体通常都是难于设计和实现的。“多个职责”经常意味着“多重性格”一可能的行为和状态的各种组合方式。==应该选择目的单一的函数(见第39条),小而且目的单一的类,和边界清晰的紧凑模块。==

应该用较小的低层抽象构建更高层次的抽象。要避免将几个低层抽象集合成一个较大的低层次抽象聚合体。用几个简单的行为来实现一个复杂的行为,比反其道而行之更加容易。

# 6. 正确、简单和清晰第一

软件简单为美( Keep It Simple Software, KISS):正确优于速度。==简单优于复杂。清晰优于机巧。安全优于不安全==(见第83条和第99条)。

---

简单设计和清晰代码的价值怎么强调都不过分。代码的维护者将因为你编写的代码容易理解而感谢你-而且这个维护者往往就是未来的你,要努力回忆起6个月前的所思所想。由是有了下面这些经典的格言警句:

程序必须为阅读它的人而编写,只是顺便用于机器执行.-Harold Abelson和Gerald JaySussman

编写程序应该以人为本,计算机第二.-Steve McConnell

计算机系统中最便宜、最快速、最可靠的组件都还不存在.-Gordon Bell

所缺的恰是最精确(永不出错),最安全(坚不可摧),以及设计、文档编写、测试和维护起来最容易的部分,简单设计的重要性怎么强调也不过分.-Jon Bentley

本书中的许多条款都能够自然地产生易于修改的设计和代码,而清晰性是易于维护、易于重构的程序最必需的特征。自己不能充分理解的设计和代码,就更无法充满自信地进行修改了。这里最常见的紧张关系恐怕就在代码清晰和代码优化(见第7条、第8条和第9条)之间。

使一个正确的程序变快,比使一个快速的程序正确要容易得多。要避免使用程序设计语言中的冷僻特性。应该使用最简单的有效技术。

# 7. 编程中应知道何时和如何考虑可伸缩性

小心数据的爆炸性增长:不要进行不成熟的优化,但是要密切关注渐近复杂性。处理用户数据的算法对所处理的数据量耗费的时间应该是可预测的,最好不差于线性关系。如果能够证明优化必要而且非常重要,尤其在数据量逐渐增长的情况下,那么应该集中精力改善算法的O(N)复杂性,而不是进行小型的优化,比如节省一个多余的加法运算。

---

防范可能的未来,也就是说我们要避免设计中含有面对更大的文件、更大的数据库、更多像·素、更多窗口、更多进程和更多线路上传输的数据时会出现的性能陷阱的现象。C++标准库能够成功防范未来的重大因素之一,就是它已经保证了STL容器操作和算法的性能复杂性。

过这种情况,而且我们知道你们也都会碰到,也许已经碰到了。当然,我们可以进行修补,然后给客户发布补厂,但最好还是能避免这样的尴尬和返上。既然所有事物都是平等的(包括清晰性与可读性),那么应该预先做这些事情:

* 使用灵活的、动态分配的数据,不要使用固定大小的数组:那种“比我所需要的最大数组还要大”的数组,在正确性和安全性方面都存在严重问题(见第77条),只有在编译时大小固定不变的数组才是可接受的。
* 了解算法的实际复杂性:要留心那些不易发觉的陷阱,比如看似线性的算法实际上要调用其他线性操作,结果算法实际上是二次的。(见第81条中的例子。)
* 优先使用线性算法或者尽可能快的算法:常数时间复杂性的算法,比如push-back和散列表查询,是最完美的(见第76条和第80条),O(logN)对数复杂性的算法,比如set/map操作和带有随机迭代器的lower_bound和upper_bound,也不错(见第76条、第85条和第86条), O(N)线性复杂性的算法,比如vector:insert和for_each,也可以接受(见第76条、第81条和第84条)。
* 尽可能避免劣于线性复杂性的算法:例如,如果面对的是一个O(NlogN)或者O(N^2^)算法,就必须花费精力寻找替代方案,这样代码才不全于在数据量显著增长的情况下陷入深度激增的性能深潭。
* 永远不要使用指数复杂性的算法,除非你已经山穷水尽,确实别无选择:在决定接受指数算法之前,必须尽力寻找替代方案,因为对于指数算法来说,即使是数据量的有限增加,也会使算法的性能急剧下降。

# 8. 不要进行不成熟的优化

拉丁谚语云,快马无需鞭策:不成熟优化的诱惑非常大,而它的无效性也同样严重。优化的第一原则就是:不要优化。优化的第二原则(仅适用于专家)是:还是不要优化。再三测试,而后优化。

---

我们将不成熟的优化定义为这样的行为:以性能为名,使设计或代码更加复杂,从而导致可读性更差,但是并没有经过验证的性能需求(比如实际的度量数据和与目标的比较结果)作为正当理由,因此本质上对程序没有真正的好处。毫无必要而且无法度量的优化行为其实根本不能使程序运行得更快,这种情况简直是太常见了。

因此,默认时,不要把注意力集中在如何使代码更快上;首先关注的应该是使代码尽可能地清晰和易读(见第6条)。==清晰的代码更容易正确编写,更容易理解,更容易重构-当然也更容易优化。==使事情复杂的行为,包括优化,总是以后再进行的--而且只在必要的时候进行。

不成熟的优化经常并不能使程序更快,这主要有两方面原因。一方面,我们程序员在估计哪些代码应该更快或者更小,以及代码中哪里会成为瓶颈上名声很臭。包括本书的作者,也包括读者你。考虑一下这些事实吧:现代计算机都具有极为复杂的计算模型,经常是几个流水线处理单元并行工作,深高速缓存层次结构,猜测执行(speculative execution) ,分支预测…这还只是CPU芯片。在硬件之上,编译器也在尽其所能地猜测,将源代码转换为最能发掘硬件潜力的机器码。而在这些复杂的架构之上,还有…还有你-程序员的猜测。所以,如果只是猜测的话,你的那些目标不明确的微观优化就很难有机会显著地改善代码。因此,优化之前必须进行度量;而度量之前必须确定优化的目标。在需求得到验证之前,注意力应该放在头号优先的事情上一为人编写代码。(当有什么人要求你进行优化的时候,请进行需求验证。)

另一方面,在现代程序,许多操作越来越不受CPU的限制。它们可能更受内存的限制、网络的限制、硬盘的限制,需要等待Web Service,或等待数据库。即使在最好的情况下,优化这些操作的应用程序代码,也只不过能使等待操作更快。==这也意味若程序员浪费了宝贵的时间去改善没有必要改善的地方,却没有进行需要的有价值的改善。==

##  例外情况

在编写程序库的时候,预测哪些操作最后会用于性能敏感的代码中更加困难。但即使是程序库的编写者,在实施容易令人糊涂的优化之前,也会对很大范围内的客户代码进行性能测试。

# 9. 不要进行不成熟的劣化

放松自己,轻松编程:在所有其他事情特别是代码复杂性和可读性都相同的情况下,一些高效的设计模式和编程惯用法会从你的指尖自然流出,而且不会比悲观的替代方案更难写。这并不是不成熟的优化,而是避免不必要的劣化(pessimization)。

---

避免不成熟的优化并不意味着必然损害性能。所谓不成熟的劣化一词,我们指的就是编写如下这些没有必要的、可能比较低效的程序:

- 在可以用通过引用传递的时候,却定义了通过值传递的参数(见第25条)。
- 在使用前缀++操作符很合适的场合,却使用后缀版本(见第28条)
- 在构造函数中使用赋值操作而不是初始化列表(见第48条)。

如果减少对象的伪临时副本(尤其是在内循环中)并不影响代码的复杂性,那么这个优化就算不上是成熟的优化。在第18条中,我们提倡尽可能将变量声明为局部的,但是又提到了一个例外情况,即有时候将变量从循环中提出来是有好处的。大多数时候,这一点也不会混淆代码的意图,相反,实际上这有助于澄清循环内部执行了哪些功能,哪些计算是不随循环变化的。当然,应该优先使用算法,而不是显式的循环(见第84条)。

构造既清晰又有效的程序有两种重要的方式:使用抽象(见第11条和第36条)和库(见第84条),例如,使==用标准库的vector, list, map, find, sort和其他设施,这些都是由世界级的专家标准化并实现的,不仅能使你的代码更加清晰,更容易理解,而且启动也经常更快。==避免不成熟的劣化在编写库的时候尤其重要。要了解库所使用的所有上下文,通常是不可能的,因此可能需要达到一种平衡,在更加倾向效率和可复用性的同时,又不能因为一小部分潜在的调用者的利益过分提高效率。其中的界限需要你来划定,但是正如第7条所说明的,更需要关注的是可伸缩性,而不是挤掉一个小小的循环。

# 10. 尽量减少全局和共享数据

共享会导致冲突:==避免共享数据,尤其是全局数据。共享数据会增加耦合度,从而降低可维护性,通常还会降低性能。==

---

避免使用名字空间作用域中具有外部连接的数据或者作为静态类成员的数据。这些数据会使程序逻辑变得更加复杂,使程序不同的(而且可能更糟,距离较远的)部分耦合得更加紧密。共享数据对单元测试会产生不良影响,因为使用共享数据的代码片断的正确性不仅取决于数据变化的过程,更取决于以后会使用该数据的未知代码区域的机能。

全局名字空间中的对象名称还会污染全局名字空间

如果必须使用全局的、名字空间作用域的或者静态的类对象,一定要仔细地对其进行初始化。这种对象在不同编译单位中这种对象的初始化顺序是未定义的,正确处理它们需要特殊的技术(参阅本条的参考文献)。初始化顺序规则是非常难于掌握的,应该尽量避免使用;如果不得不用的话,则应该充分了解,小心使用。

名字空间作用域中的对象、静态成员对象或者跨线程或跨进程共享的对象会减少多线程和多处理器环境中的并行性,往往是产生性能和可伸缩性瓶颈的源头(见第7条)。为“无共享”而奋斗吧,用通信方式(比如消息队列)代替数据共享。

应该尽量降低类之间的耦合,尽量减少交互。

# 11. 隐藏信息

不要泄密:==不要公开提供抽象的实体的内部信息。==

---

为了尽量减少操作抽象的调用代码和抽象的实现之间的依赖性,必须隐藏实现内部的数据。否则,调用代码就能够访问—或者更糟,操作—该信息,而原本应属于内部的信息就泄漏给了调用代码所依赖的抽象。应该公开抽象(如果有的话,还是公开领域抽象更好,但至少应该是get/set 抽象),而不是数据。

信息隐藏主要从下列两个方面降低了项目的成本,提高了项目的进度,减少了项目的风险。

- 它限制了变化的影响范围:信息隐藏缩小了变化所引起的“连锁反应”的范围,也降低了由此带来的成本。
- 它强化了不变式:它限制了负责维护(如果有错误的话,也可能是破坏)程序不变式的代码(见第41条)。

不要从任何提供抽象的实体中公开数据(另见第10条)。数据只是抽象、概念性状态的一种可能的具体化而已。如果将注意力集中在概念而不是其表示形式上,就能够提供富于提示性的接口,并按需要对实现进行调整--比如缓存还是实时地计算,又比如使用不同的表示方式,针对某种使用模式(如极坐标与笛卡儿坐标)进行优化。

==绝对不要将类的数据成员设为public== (见第41条),或者公开指向它们的指针或句柄(见第42条)而使其公开,这是一个很常见的信息隐藏的例子,但是它同样适用于更大的实体比如程序库-程序库同样不能暴露内部信息。模块和程序库同样应该提供定义抽象和其中信息流的接口,从而使与调用代码的通信比采用数据共享方式更安全,耦合度更低。

## 例外情况

测试代码经常需要对被测试类或者模块进行白箱访问。值的聚合("C语言式的struct")只是简单地将数据绑在了一起,并没有提供任何抽象,所以它不需要隐藏数据,数据本身就是接口(见第41条)。

# 12. 懂得何时和如何进行并发性编程

如果应用程序使用了多个线程或者进程,应该知道如何尽量减少共享对象(见第10条),以及如何安全地共享必须共享的对象。

---

