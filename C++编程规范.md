# 0. 不要拘泥于小节

只规定需要规定的事情:不要强制施加个人喜好或者过时的做法。

---

有些问题只是个人喜好,并不影响程序的正确性或者可读性,所以这些问题不应该出现在编程规范中。任何专业程序员都可以很容易地阅读和编写与其习惯的格式略有不同的代码。应该在每个源文件乃至每个项目中都使用一致的格式,因为同一段代码中要在几种编程风格(style)之间换来换去是很不舒服的。但是无需在多个项目或者整个公司范围内强制实施一致的格式。

* 不要规定缩进多少,应该规定要用缩进来体现代码的结构:缩进空格的数量可以遵照个人习惯,但是至少在每个文件中应该保持一致。
* 不要强制行的具体长度,应该保证代码行的长度有利于阅读:可以遵照个人习惯来决定行长,但是不要过长。研究表明,文字长度不超过10个单词最利于阅读。
* 不要在命名方面规定过多,应该规定的是使用一致的命名规范:只有两点是必需的: (1)永远不要使用“晦涩的名称”,即以下划线开始或者包含双下划线的名称; (2)总是使用形如ONLY_UPPERCASE_NAMES的全大写字母表示宏,不要考虑使用常见的词或者缩略语作为宏的名称(包括常见的模板参数,比如T和U:像“#define T anything"这样的代码是极容易混淆的)。此外,应该使用一致的、有意义的名称,遵循文件的或者模块的规范。(如果你无法决定自己的命名规范,可以尝试如下命名规则:类、函数和枚举的名称形如LikeThis,即单词首字母大写;变量名形如likeThis,即第一个单词首字母小写,第二个单词首字母大写;私有成员变量名形如ikeThis-:宏名称形如LIKETHIS.)
* 不要规定注释体例(除非需要使用工具从特定的体例中提取出文档) ,应该编写有用的注释:尽可能编写代码而不是写注释(比如,见第16条),不要在注释中重复写代码语义,这样很容易产生不一致。应该编写的是解释方法和原理的说明性注释。

# 1. 在高警告级别干净利落地进行编译

高度重视警告:使用编译器的最高警告级别。应该要求构建是干净利落的(没有警告)。理,解所有的警告。通过修改代码而不是降低警告级别来排除警告。

---

编译器是你的朋友。如果它对某个构造发出警告,这经常是说明你的代码中存有潜在的问题成功的构建应该是无声无息的(没有警告的)。如果不是这样,你很快就会养成不仔细查看输出的习惯,从而漏过真正的问题(见第2条)。

排除警告的正确做法是: (1)把它弄清楚;然后, (2)改写代码以排除警告,并使代码阅读者和编译器都能更加清楚,代码是按编写者的意图执行的。

即使程序一开始似乎能够正确运行,也还是要这样做。即使你能够肯定警告是良性的,仍然要这样做。因为良性警告的后面可能隐藏着未来指向真正危险的警告。

## 例外情况

有时候,编译器可能会发出烦人的甚至虚假的警告(即纯属噪声的警告),但是又没有提供消除的方法,这时忙于修改代码解决这个警告可能是劳而尤功或者事倍功半的。如果遇到了这种罕见的情形,作为团队决定,应该避免对纯粹无益的警告再做无用功:单独禁用这个警告,但是要尽可能在刷部禁用,并且编写一个清晰的注释,说明为什么必须禁用。

# 2. 使用自动构建系统

一次按键就解决问题:使用完全自动化(“单操作”)的构建系统,无需用户干预即可构建整一个项目。

---

单操作的构建过程非常重要。它应该能将源文件可靠和可重复地转换为可以交付的软件包。现在已经有了大量自动构建工具,没有理由不用。所以,选择一种,用起来吧。

我们曾经见到不少开发单位忽略了构建系统“单操作”这一需求。有些开发单位认为,用鼠标四处点击几下,运行一些实用工具来注册COM/CORBA服务器,手工复制一些文件,就是很不错的构建过程了。可是,我们都不应该将时间和精力浪费在机器可以干得更快更好的事情上。自动的、可靠的、单操作的构建是非常必要的。

成功的构建应该无声无息,不产生任何警告(见第1条),理想的构建过程不会出现噪声,只会出现一条日志信息: “构建成功"。

==构建有两种模式:增量构建和完全构建。==增量构建只重新构建上次构建(可以是增量的或者完全的)以来发生改变的部分。注意:两次连续增量构建中的第二次构建不应该编写任何输出文件;否则,可能会出现依赖循环(见第22条),构建系统也可能会执行不必要的操作(比如,编写假的肯定要丢弃的临时文件)。

一个项目的完全构建可能有不同形式。可以考虑通过改变许多基本特性来参数化控制构建过程的参数;候选的特性包括目标架构,调试模式还是发布模式,以及范围(基本文件、所有文件、还是完整的安装文件)。一种构建设置能够生成产品的基本可执行文件和库,另一种设置可能还会生成附属文件,而完全构建则可能生成包括所有文件、第三方可重发行文件和安装代码在内的安装文件。

随着项目日渐发展,不使用自动构建所带来的成本也会逐渐增加。如果没有从一开始就使用自动构建,时间和资源的浪费就将无可避免。更糟糕的情况是,到了不得不使用自动构建的时候,你所面临的压力将比项目开始时大得多。大型项目可能应该设置一个“构建管理员”,他的工作就是负责构建系统。

# 3. 使用版本控制系统

请使用==版本控制系统(version control system, VCS)==。永远不要让文件长时间地登出。在新的单元测试通过之后,应该频繁登入。确保登入的代码不会影响构建成功。

---

几乎所有大一点的项目都需要一个以上的开发人员和(或)一周以上的开发时间。在这样的项目中,将需要比较同一文件的各个历史版本,以确定修改是何时(以及/或者由谁)进行的。需要控制和管理源代码的变更。

如果有多个开发人员,他们将会并行地进行修改,可能会在同一时间修改同一文件的不同部分。此时,就需要能对文件进行自动登出/版本管理的工具了,有些情况下还需要并发编辑的合并功能。版本控制系统能够自动化和控制登出、版本管理及合并操作。版本控制系统能够比人工实施更快更正确。而且我们也不需要在管理琐事上浪费时间—编写软件才是我们的工作。

即使是单独工作的开发人员,也有脑子短路的瞬间,需要搞清楚何时为什么引入了某个错误,或者进行了某个修改。我们都难免如此。==版本控制系统能够自动地跟踪每个文件的历史==,使我们能够“让时光倒流”。问题并不在于你是否想从历史中寻找答案,而在于你到底何时需要。

不要破坏构建。版本控制系统中的代码必须总能构建成功。

由于目前能够找到大量的版本控制系统,我们没有任何借口拒之门外。最廉价也最流行的版本控制系统是cvs,这个工具非常灵活,提供了TCP/P访问功能,可以选择增强安全性(提供使用ssh协议作为后端),可以通过脚本编程实现极佳的管理功能,甚至还有图形界面。许多其他的版本控制系统产品要么将cvs作为模仿的标准,要么是以其为基础再构建新的功能。

## 例外情况

只有一个程序员且从头至尾只需一周的项目,可能不需要版本控制系统。

# 4. 在代码审查上投入

审查代码:更多的关注有助于提高质量。==亮出自己的代码,阅读别人的代码。==互相学习,彼此都会受益。

---

好的代码审查过程对开发团队有许多方面的益处,它能够

- 通过来自同伴的良性压力提高代码质量。
- 找出错误、不可移植的代码(如果适用)和潜在的扩展问题。
- 通过思想交流获得更好的设计和实现。
- 快速培养新同事和初入门者。
- 在团队中形成共同的价值观和集体主义。
- 增强整体实力,提升自信心、动力和职业荣誉感。

许多开发单位现在既不奖励高质量的代码和高质量的团队,也不投入时间和资金予以鼓励。我们估计几年之内这种情况仍然会存在,但是趋势已经在缓慢变化,这部分是因为软件安全性需求的不断增加。代码审查恰恰有助于提高软件的安全性,而且还是内部培训的一种极佳方法(而且没有成本)!

如果老板现在还不支持代码审查过程,那就先从提高管理层的认识做起(提示:一开始先给他们看看这本书),同时尽最大努力想各种办法腾出时间进行审查。这种时间是值得花的。代码审查应该成为软件开发周期中的常规环节。如果能够与同事就奖惩制度(根据积极因素,·可能还有消极因素)达成一致,那就更好了。

代码审查无需太形式主义,最好通过书面形式进行—一封简单的电子邮件就足够了。这样能够更容易地跟踪你自己的过程,避免重复。在审查别人的代码时,可能需要保存一份核对表以备参考。我们举贤不避亲地推荐,本书的目录就是一个很好的核对表。愿你使用愉快!小结:我们知道这里有些老调重弹了,但还是不得不说。我们的天性都讨厌代码审查,但是内心又有一个小小的天才程序员乐此不疲,因为它富于成效,而且能够获得更好的代码和更可靠的应用程序。

# 5.  一个实体应该只有一个紧凑的职责

一次只解决一个问题:只给一个实体(变量、类、函数、名称空间、模块和库)赋予一个定义良好的职责。随着实体变大,其职责范围自然也会扩大,但是职责不应该发散。

---

如果一个实体有几个不同的目的,则给使用带来的难度往往会激增,因为这种实体除了会增加理解难度、复杂性和各部分中的错误外,还会导致其他问题。这种实体不仅更大(常常毫无合理理由),而且更难以使用和维护。此外,这种实体经常会为自身的一些特定用途提供有问题的接口,因为各个功能领域之间的部分重叠,会影响干净利落地实现每个功能所需的洞察力。

具有多个不同职责的实体通常都是难于设计和实现的。“多个职责”经常意味着“多重性格”一可能的行为和状态的各种组合方式。==应该选择目的单一的函数(见第39条),小而且目的单一的类,和边界清晰的紧凑模块。==

应该用较小的低层抽象构建更高层次的抽象。要避免将几个低层抽象集合成一个较大的低层次抽象聚合体。用几个简单的行为来实现一个复杂的行为,比反其道而行之更加容易。

# 6. 正确、简单和清晰第一

软件简单为美( Keep It Simple Software, KISS):正确优于速度。==简单优于复杂。清晰优于机巧。安全优于不安全==(见第83条和第99条)。

---

简单设计和清晰代码的价值怎么强调都不过分。代码的维护者将因为你编写的代码容易理解而感谢你-而且这个维护者往往就是未来的你,要努力回忆起6个月前的所思所想。由是有了下面这些经典的格言警句:

程序必须为阅读它的人而编写,只是顺便用于机器执行.-Harold Abelson和Gerald JaySussman

编写程序应该以人为本,计算机第二.-Steve McConnell

计算机系统中最便宜、最快速、最可靠的组件都还不存在.-Gordon Bell

所缺的恰是最精确(永不出错),最安全(坚不可摧),以及设计、文档编写、测试和维护起来最容易的部分,简单设计的重要性怎么强调也不过分.-Jon Bentley

本书中的许多条款都能够自然地产生易于修改的设计和代码,而清晰性是易于维护、易于重构的程序最必需的特征。自己不能充分理解的设计和代码,就更无法充满自信地进行修改了。这里最常见的紧张关系恐怕就在代码清晰和代码优化(见第7条、第8条和第9条)之间。

使一个正确的程序变快,比使一个快速的程序正确要容易得多。要避免使用程序设计语言中的冷僻特性。应该使用最简单的有效技术。

# 7. 编程中应知道何时和如何考虑可伸缩性

小心数据的爆炸性增长:不要进行不成熟的优化,但是要密切关注渐近复杂性。处理用户数据的算法对所处理的数据量耗费的时间应该是可预测的,最好不差于线性关系。如果能够证明优化必要而且非常重要,尤其在数据量逐渐增长的情况下,那么应该集中精力改善算法的O(N)复杂性,而不是进行小型的优化,比如节省一个多余的加法运算。

---

防范可能的未来,也就是说我们要避免设计中含有面对更大的文件、更大的数据库、更多像·素、更多窗口、更多进程和更多线路上传输的数据时会出现的性能陷阱的现象。C++标准库能够成功防范未来的重大因素之一,就是它已经保证了STL容器操作和算法的性能复杂性。

过这种情况,而且我们知道你们也都会碰到,也许已经碰到了。当然,我们可以进行修补,然后给客户发布补厂,但最好还是能避免这样的尴尬和返上。既然所有事物都是平等的(包括清晰性与可读性),那么应该预先做这些事情:

* 使用灵活的、动态分配的数据,不要使用固定大小的数组:那种“比我所需要的最大数组还要大”的数组,在正确性和安全性方面都存在严重问题(见第77条),只有在编译时大小固定不变的数组才是可接受的。
* 了解算法的实际复杂性:要留心那些不易发觉的陷阱,比如看似线性的算法实际上要调用其他线性操作,结果算法实际上是二次的。(见第81条中的例子。)
* 优先使用线性算法或者尽可能快的算法:常数时间复杂性的算法,比如push-back和散列表查询,是最完美的(见第76条和第80条),O(logN)对数复杂性的算法,比如set/map操作和带有随机迭代器的lower_bound和upper_bound,也不错(见第76条、第85条和第86条), O(N)线性复杂性的算法,比如vector:insert和for_each,也可以接受(见第76条、第81条和第84条)。
* 尽可能避免劣于线性复杂性的算法:例如,如果面对的是一个O(NlogN)或者O(N^2^)算法,就必须花费精力寻找替代方案,这样代码才不全于在数据量显著增长的情况下陷入深度激增的性能深潭。
* 永远不要使用指数复杂性的算法,除非你已经山穷水尽,确实别无选择:在决定接受指数算法之前,必须尽力寻找替代方案,因为对于指数算法来说,即使是数据量的有限增加,也会使算法的性能急剧下降。

# 8. 不要进行不成熟的优化

拉丁谚语云,快马无需鞭策:不成熟优化的诱惑非常大,而它的无效性也同样严重。优化的第一原则就是:不要优化。优化的第二原则(仅适用于专家)是:还是不要优化。再三测试,而后优化。

---

我们将不成熟的优化定义为这样的行为:以性能为名,使设计或代码更加复杂,从而导致可读性更差,但是并没有经过验证的性能需求(比如实际的度量数据和与目标的比较结果)作为正当理由,因此本质上对程序没有真正的好处。毫无必要而且无法度量的优化行为其实根本不能使程序运行得更快,这种情况简直是太常见了。

因此,默认时,不要把注意力集中在如何使代码更快上;首先关注的应该是使代码尽可能地清晰和易读(见第6条)。==清晰的代码更容易正确编写,更容易理解,更容易重构-当然也更容易优化。==使事情复杂的行为,包括优化,总是以后再进行的--而且只在必要的时候进行。

不成熟的优化经常并不能使程序更快,这主要有两方面原因。一方面,我们程序员在估计哪些代码应该更快或者更小,以及代码中哪里会成为瓶颈上名声很臭。包括本书的作者,也包括读者你。考虑一下这些事实吧:现代计算机都具有极为复杂的计算模型,经常是几个流水线处理单元并行工作,深高速缓存层次结构,猜测执行(speculative execution) ,分支预测…这还只是CPU芯片。在硬件之上,编译器也在尽其所能地猜测,将源代码转换为最能发掘硬件潜力的机器码。而在这些复杂的架构之上,还有…还有你-程序员的猜测。所以,如果只是猜测的话,你的那些目标不明确的微观优化就很难有机会显著地改善代码。因此,优化之前必须进行度量;而度量之前必须确定优化的目标。在需求得到验证之前,注意力应该放在头号优先的事情上一为人编写代码。(当有什么人要求你进行优化的时候,请进行需求验证。)

另一方面,在现代程序,许多操作越来越不受CPU的限制。它们可能更受内存的限制、网络的限制、硬盘的限制,需要等待Web Service,或等待数据库。即使在最好的情况下,优化这些操作的应用程序代码,也只不过能使等待操作更快。==这也意味若程序员浪费了宝贵的时间去改善没有必要改善的地方,却没有进行需要的有价值的改善。==

##  例外情况

在编写程序库的时候,预测哪些操作最后会用于性能敏感的代码中更加困难。但即使是程序库的编写者,在实施容易令人糊涂的优化之前,也会对很大范围内的客户代码进行性能测试。

# 9. 不要进行不成熟的劣化

放松自己,轻松编程:在所有其他事情特别是代码复杂性和可读性都相同的情况下,一些高效的设计模式和编程惯用法会从你的指尖自然流出,而且不会比悲观的替代方案更难写。这并不是不成熟的优化,而是避免不必要的劣化(pessimization)。

---

避免不成熟的优化并不意味着必然损害性能。所谓不成熟的劣化一词,我们指的就是编写如下这些没有必要的、可能比较低效的程序:

- 在可以用通过引用传递的时候,却定义了通过值传递的参数(见第25条)。
- 在使用前缀++操作符很合适的场合,却使用后缀版本(见第28条)
- 在构造函数中使用赋值操作而不是初始化列表(见第48条)。

如果减少对象的伪临时副本(尤其是在内循环中)并不影响代码的复杂性,那么这个优化就算不上是成熟的优化。在第18条中,我们提倡尽可能将变量声明为局部的,但是又提到了一个例外情况,即有时候将变量从循环中提出来是有好处的。大多数时候,这一点也不会混淆代码的意图,相反,实际上这有助于澄清循环内部执行了哪些功能,哪些计算是不随循环变化的。当然,应该优先使用算法,而不是显式的循环(见第84条)。

构造既清晰又有效的程序有两种重要的方式:使用抽象(见第11条和第36条)和库(见第84条),例如,使==用标准库的vector, list, map, find, sort和其他设施,这些都是由世界级的专家标准化并实现的,不仅能使你的代码更加清晰,更容易理解,而且启动也经常更快。==避免不成熟的劣化在编写库的时候尤其重要。要了解库所使用的所有上下文,通常是不可能的,因此可能需要达到一种平衡,在更加倾向效率和可复用性的同时,又不能因为一小部分潜在的调用者的利益过分提高效率。其中的界限需要你来划定,但是正如第7条所说明的,更需要关注的是可伸缩性,而不是挤掉一个小小的循环。

# 10. 尽量减少全局和共享数据

共享会导致冲突:==避免共享数据,尤其是全局数据。共享数据会增加耦合度,从而降低可维护性,通常还会降低性能。==

---

避免使用名字空间作用域中具有外部连接的数据或者作为静态类成员的数据。这些数据会使程序逻辑变得更加复杂,使程序不同的(而且可能更糟,距离较远的)部分耦合得更加紧密。共享数据对单元测试会产生不良影响,因为使用共享数据的代码片断的正确性不仅取决于数据变化的过程,更取决于以后会使用该数据的未知代码区域的机能。

全局名字空间中的对象名称还会污染全局名字空间

如果必须使用全局的、名字空间作用域的或者静态的类对象,一定要仔细地对其进行初始化。这种对象在不同编译单位中这种对象的初始化顺序是未定义的,正确处理它们需要特殊的技术(参阅本条的参考文献)。初始化顺序规则是非常难于掌握的,应该尽量避免使用;如果不得不用的话,则应该充分了解,小心使用。

名字空间作用域中的对象、静态成员对象或者跨线程或跨进程共享的对象会减少多线程和多处理器环境中的并行性,往往是产生性能和可伸缩性瓶颈的源头(见第7条)。为“无共享”而奋斗吧,用通信方式(比如消息队列)代替数据共享。

应该尽量降低类之间的耦合,尽量减少交互。

# 11. 隐藏信息

不要泄密:==不要公开提供抽象的实体的内部信息。==

---

为了尽量减少操作抽象的调用代码和抽象的实现之间的依赖性,必须隐藏实现内部的数据。否则,调用代码就能够访问—或者更糟,操作—该信息,而原本应属于内部的信息就泄漏给了调用代码所依赖的抽象。应该公开抽象(如果有的话,还是公开领域抽象更好,但至少应该是get/set 抽象),而不是数据。

信息隐藏主要从下列两个方面降低了项目的成本,提高了项目的进度,减少了项目的风险。

- 它限制了变化的影响范围:信息隐藏缩小了变化所引起的“连锁反应”的范围,也降低了由此带来的成本。
- 它强化了不变式:它限制了负责维护(如果有错误的话,也可能是破坏)程序不变式的代码(见第41条)。

不要从任何提供抽象的实体中公开数据(另见第10条)。数据只是抽象、概念性状态的一种可能的具体化而已。如果将注意力集中在概念而不是其表示形式上,就能够提供富于提示性的接口,并按需要对实现进行调整--比如缓存还是实时地计算,又比如使用不同的表示方式,针对某种使用模式(如极坐标与笛卡儿坐标)进行优化。

==绝对不要将类的数据成员设为public== (见第41条),或者公开指向它们的指针或句柄(见第42条)而使其公开,这是一个很常见的信息隐藏的例子,但是它同样适用于更大的实体比如程序库-程序库同样不能暴露内部信息。模块和程序库同样应该提供定义抽象和其中信息流的接口,从而使与调用代码的通信比采用数据共享方式更安全,耦合度更低。

## 例外情况

测试代码经常需要对被测试类或者模块进行白箱访问。值的聚合("C语言式的struct")只是简单地将数据绑在了一起,并没有提供任何抽象,所以它不需要隐藏数据,数据本身就是接口(见第41条)。

# 12. 懂得何时和如何进行并发性编程

如果应用程序使用了多个线程或者进程,应该知道如何尽量减少共享对象(见第10条),以及如何安全地共享必须共享的对象。

---

其中最重要的问题是避免死锁、活锁(livelock) 和恶性的竞争条件(包括加锁不足导致的崩溃)。C++经常而且广泛地用于编写坚固的多线程代码。如果应用程序需要跨线程共享数据,请如下安全行事;

- 参考目标平台的文档,了解该平台的同步化原语:典型的原语包括从轻量级的原子整数操作到内存障栅(memory barrier) ,再到进程内和跨进程的互斥体。
- 最好将平台的原语用自己设计的抽象包装起来:在需要跨平台移植性的时候,这样做尤其有益。或者,也可以使用程序库(比如pthreads [Butenho97)为我们代劳。
- 确保正在使用的类型在多线程程序中使用是安全的:说得具体一些,就是类型必须至少做到以下两个方面。
  - 保证非共享的对象独立:两个线程能够自由地使用不同的对象,无需调用者的任何特殊操作。
  - 记载调用者在不同线程中使用该类型的同一个对象需要做什么:许多类型要求对这种共享对象进行串行访问,但是有些类型却不要求这样。后者通常要么从设计中去掉加锁需求,要么自己进行内部加锁,无论哪种情况,仍然需要留意内部加锁粒度的局限。

在自己编写可用于多线程程序的类型时,也必须完成两项任务:

- 必须保证不同线程能够不加锁地使用该类型的不同对象(注意:具有可修改的静态数据的类型通常不能保证这一点)。
- 必须在文档中说明使用者在不同线称中使用该类型的同一个对象需要做什么,基本的设计问题是如何在类及其客户之间分配正确执行(即无竞争和无死锁地执行)的职责。主要的选择有下列几个方面。
  - 外部加锁:调用者负责加锁,在这种选择下,由使用对象的代码负责了解是否跨线程共字了对象,而且如果是,则还要负责串行化所有对该对象的使用。
  - 内部加锁:每个对象将所有对自己的访问串行化,通常采用为每个公用成员函数加锁的方法来实现、这样调用者就可以不用串行化对象的使用了。

---

- 必须事先知道该类型的对象几乎总是要被跨线程共享的,否则到头来只不过进行了无效加锁。请注意大多数类型都不会遇到这种情况,即使是在多线程处理分量很重的程序中,大多数对象也不会被跨线程共享
- 必须事先知道成员函数级加锁的粒度是合适的,而且能满足大多数调用者的需要。具体而言,类型接口的设计应该有利于粗粒度的、自给自足的操作。如果调用者总是需要对多个而不是一个操作加锁,那么就不能满足需要了,只能通过增加更多的(外部)锁,将单独加锁的函数组装成一个更大规模的已加锁工作单位。
- 不加锁的设计,包括不变性(只读对象):无需加锁。常见的例子是不变对象,它无需加锁,因为它从不发生变化;例如,对于一个不变的字符串类型而言,字符串对象.旦创建就不会改变,每个字符串操作都会创建新的字符串。

# 13. ,确保资源为对象所拥有。使用显式的RAll和智能指针

 C++的“资源获取即初始化" (resource acquisition is initialization,, RAll)惯用法是正确处理资源的利器。RAII使编译器能够提供强大且自动的保证,这在其他语言中可是需要脆弱的手工编写的惯用法才能实现的。分配原始资源的时候,应该立即将其传递给属主对象。永远不要在一条语句中分配一个以上的资源。

---

C++语言所强制施行的构造函数/析构函数对称反映了资源获取释放函数对比如fopen/fclose/lock/unlock和new/delete的本质的对称性。这使具有资源获取的构造函数和具有资源释放的析构函数的基于栈(或引用计数)的对象成为了自动化资源管理和清除的‘’极佳工具。

这种自动化很容易实现优雅、低成本而且天生防错。如果不予采用,就需要手工将调用正确配对,包括存在分支控制流和异常的情形,这可是很不容易而且需要注意力高度集中的任务。既然C++已经通过易用的RAlI提供了如此直接的自动化,这种C语言式的仍然依赖于对资源解除分配的微观管理方式就是不可接受的了。

每当处理需要配对的获取/释放函数调用的资源时,都应该将资源封装在一个对象中,让对象为我们强制配对,并在其析构函数中执行资源释放。

确保所有资源都为对象所有。最好用智能指针而不是原始指针来保存动态分配的资源。同样,应该在自己的语句中执行显式的资源分配(比如new),而且每次都应该马上将分配的资源赋予管理对象(比如shared_ptr),否则,就可能泄漏资源,因为函数参数的计算顺序是未定义的。

## 例外情况

智能指针有可能会被过度使用。如果被指向的对象只对有限的代码(比如纯粹在类的内部,诸如一个Tree类的内部节点导航指针)可见,那么原始指针就够用了。

# 14. 宁要编译时和连接时错误,也不要运行时错误

能够在编译时做的事情,就不要推迟到运行时:编写代码时,应该在编译期间使用编译器检查不变式(invariant) ,而不应该在运行时再进行检查。运行时检查取决于控制流和数据的具体情况,这意味着很难知道检查是否彻底。相比而言,编译时检查与控制流和数据无关,一般情况下能够获得更高的可信度。

---

C++语言为我们提供了许多机会,能够通过将错误检查推迟到编译时而“加速”这一过程。充分利用这些静态检查功能,可以带来下列好处:

- 静态检查与数据和控制流无关:静态检查能够提供独立于程序输入和执行流程的保证。相反,要确保运行时检查足够可靠,需要使用对所有输入都具有代表性的用例进行测试。即使对于最简单的系统而言这也是一件令人生畏的工作。
- 静态表示的模型更加可靠:通常,如果程序较少地依赖于运行时检查,而更多地依赖于编译时检查,就说明它的设计比较出色,因为程序所创建的模型能够正确地使用C++的类型系统来表达。这种情况下,你和编译器将成为伙伴,对程序的不变式有着一致的看法;而运行时检查则经常只是在检查能够静态进行,但是无法精确地在语言中表达的情况下,作为一种应变手段而已。
- 静态检查不会带来运行时开销:用静态检查替换动态检查,所生成的可执行文件会更快,而且不会影响正确性。

C++最强大的静态检查工具之一,就是其自身的静态类型检查。在类型应该如何检查这一问题上,各种语言分成了静态(C++, Java, ML, Haskell)和动态(Smaltak, Ruby, Python, Lisp)两大阵营,争论仍在继续而且依旧激烈。总体而言,这个问题并无定论,支持两种检查方式的语言和开发风格据说都取得了良好的效果。静态检查阵营辩称,采取静态检查可以很容易地省去一大类运行时的错误处理,从而使程序更加牢固。另一方面,动态检查阵营则说,编译器只能检查出一 部分潜在的错误,所以,既然反正无论如何都要写单元测试,那么根本就无需劳神费心地进行静态检在,这样还能拥有一个宽松的编程环境。

有一件事情是肯定的:在静态类型语言C++的环境中(其中提供了强大的静态检查,而对自动运行时检查的支持则很少),程序员肯定应该尽可能地使用能带来优势的类型系统。同时,对于与数据和控制流有关的检查(如数组边界检查或者输入数据验证)来说,使用运行时检查也是明智的选择

## 例外情况

有些情况下,无法在编译时检查,必须进行运行时检查。对于这些情况,应该使用断言来检查内部编程错误,对于其他运行时错误比如与数据相关的错误,则要遵循“错误处理与异常”部分的其他建议进行处理。

# 15.  积极使用const

const是我们的朋友:不变的值更易于理解、跟踪和分析,所以应该尽可能地使用常量代替变量,定义值的时候,应该把const作为默认的选项:常量很安全,在编译时会对其进行检查(见第14条),而且它与C++的类型系统已浑然一体。不要强制转换const的类型,除非要调用常量不正确的函数(见第94条)。

---

常量能够简化代码,因为只需查看定义处的代码就能知道它在各处的值了。

常量正确性是值得实现的,它已经得到证实而且非常有效,应该大力推荐。理解程序状态变化的方式和位置是非常重要的, const将此直接记录在了代码中,编译器可以帮助我们实施这一点。正确编写const自助于更好地理解设计,使代码更牢固、更安全。如果发现有哪个成员函数不可能是const的,通常会使我们更好地理解成员函数修改对象状态的方式。还可以理解哪些数据成员在物理常量性和逻辑常量性之间架起了桥梁。

不要强制转换const,除非要调用常量不止确的函数,或若在一些很罕见的情况下,为了解决老编译器中不支持mutable的问题。

# 16. 避免使用宏

宏是C和C++语言的抽象设施中最生硬的工具,它是披着函数外衣的饥饿的狼,很难驯服,它会我行我素地游走于各处。要避免使用宏。

---

由于几方面的原因,宏已经成为讨厌、恶心、杂乱的混合体,其中最主要的原因在于它们被吹捧为一种文本替换设施,其效果在预处理阶段就产生了,而此时C++的语法和语义规则都还没有起作用。

C++的宏的主要问题在于,它们表面上看起来很好,而实际上做的却是另一回事。宏会忽略作用域,忽略类型系统,忽略所有其他的语言特性和规则,而且会劫持它为文件其余部分所定义(#define)的符号。宏调用看上去很像符号或者函数调用,但实际上并非如此。宏不太“卫生”,也就是说,它会根据自己被使用时所处的环境引人注目而且令人惊奇地展开为各种东西。宏需要进行文本替换,因此编写远距离也正确的宏接近于一种魔法,而精通这种魔法既无意义又无趣味。

不少人都认为与模板相关的错误足最难以解读的,他们可能还没有看到误写和误用的宏所引起的那些错误。模板是C++类型系统的一部分,因此编译器可以更好地对它们进行处理,而宏天生是与语言本身割裂开来的,因此很难处理。更糟的是,与模板不同,宏可能展开为在偶然情况下能够编译的“传输线噪声”。最后,宏中的错误可能只有在宏展开之后才能被报告出来,而不是在定义时。

## 例外情况

宏仍然是几个重要任务的惟一解决方案,比如#include保护符(guard) (见第24条),条件编译中的#idef和#idefined,以及assert的实现(见第68条)。

在条件编译(如与系统有关的部分)中,要避免在代码中到处杂乱地插入#ifdef.相反,应该对代码进行组织,利用宏来驱动一个公共接口的多个实现,然后始终使用该接口。

# 17. 避免使用"魔数"

要避免在代码中使用诸如42和3.14159这样的文字常量。它们本身没有提供任何说明,并且因为增加了难于检测的重复而使维护更加复杂。可以用符号名称和表达式替换它们.

---

名称能够增加信息,并提供单一的维护点,而程序中到处重复的原始数据是无名的,维护起来很麻烦。常量应该是枚举符或者const值,有合适的作用域和名称。

# 18. 尽可能局部地声明变量

避免作用域膨胀,对于需求如此,对于变量也是如此。变量将引入状态,而我们应该尽可能。·少地处理状态,变量的生存期也是越短越好。这是第10条的一个特例,但值得单独阐述。

---

变量的生存期超过必需的长度时会产生以下几个缺点:

- 它们会使程序更难以理解和维护
- 它们的名字会污染上下文:这一点的直接后果,就是可见性最好的名字空间级变量,问题也最大(见第10条)。
- 它们不能总是被合理地初始化:在能够合理地初始化一个变量之前,决不要声明它。未初始化的变量是所有C和C++程序中普遍的错误来源。我们需要对此高度重视,因为编译器并不总能将其检查出来(见第19条)

要特别说明的是, C99之前的C语言版本曾要求只能在作用域开始处定义变量;这种方式在C中已经过时了。这一限制的严重问题在于,在作用域的开始,经常还没有足够的相关信息进行变量初始化。因此我们只有两种选择--要么用某个默认的空值(比如零)来初始化,这通常都是一种浪费,而且如果变量在拥有有效状态之前被使用,还会导致错误;要么让变量保持未初始化,而这是很危险的。用户定义类型的未初始化变量将会自行初始化为某个空值。

解决方案很简单:尽可能局部地定义每个变量,通常就是在你有了足够的数据进行初始化的·时候,而且恰恰就在首次使用变量之前。

# 19. 总是初始化变量

一切从白纸开始:未初始化的变量是C和C++程序中错误的常见来源。养成在使用内存之前先清除的习惯,可以避免这种错误,在定义变量的时候就将其初始化。

---

按照C和C+相同的低层高效率传统,通常并不要求编译器初始化变量,除非你显式地这样做(比如,局部变量,构造函数初始式列表中遗漏的成员)。应该显式地初始化变量。

几乎没有理由不对变量进行初始化。实际上没有任何理由值得冒未定义行为可能带来的危险

使用过程式语言(如Pascal, C. Fortran或Cobol)的人,可能有这样的习惯:独立于使用它们的代码来定义变量,然后在要使用的时候再赋值。这种方式已经过时了,是不可取的(见第18条)。

关于未初始化变量,有一个常见的误解:它们会使程序崩溃,因此通过简单的测试就能很快地发现分布在各处的那些为数不多的未初始化变量。但事实恰恰相反,`如果内存布局碰巧满足了程序需求,带有未初始化变量的程序能够毫无问题地运行上数年`。在此之后,如果从不同环境中调用,或者重新编译,或者程序的另一个部分进行了修改,都可能导致各种故障发生,轻则出现难以琢磨的行为,重则发生间歇性的崩溃。

## 例外情况

硬件或者其他进程直接写入的输入缓冲区数据和volatile型数,不需要程序对其进行初始1

# 20. 避免函数过长,避免嵌套过深

短胜于长,平优于深:过长的函数和嵌套过深的代码块的出现,经常是因为没能赋予一个函数以一个紧凑的职责所致(见第5条),这两种情况通常都能够通过更好的重构予以解决。

---

每个函数都应该是顾其名而能思其义,易于理解的工作单元(见第5条和第70条中的讨论)。如果与此相反,函数试图将多个这样的小概念单元合并到一个长的函数体中,那么它最终将不堪重负。

过长的函数和嵌套过深的代码块(比如ift for, while和try代码块)是使函数更难于理解和维护的密不可分的两大元凶(而且经常毫无必要)。

每级嵌套都会增加阅读代码时的脑力消耗,因为需要在脑子里维护一个“栈”(比如,进入条件语句、进入循环、进入try、进入条件语句 )。你是否有过这样的可怕经历:在别人编写的代码里众多的for. while和if语句中为一个右括号寻找匹配?应该做进一步的功能分解,从而避免使代码的阅读者一次记住太多的上下文。

请遵循这样的常识和常理:限制函数的长度和嵌套深度。

- 尽量紧凑:对一个函数只赋予一种职责(见第5条)。
- 不要自我重复:优先使用命名函数,而不要让相似的代码片断反复出现。
- 优先使用&&:在可以使用&条件判断的地方要避免使用连续嵌套的if
- 不要过分使用try:优先使用析构函数进行自动清除而避免使用try代码块(见第13条)。
- 优先使用标准算法:算法比循环嵌套要少,通常也更好(见第84条)。不要根据类型标签(typetag)进行分支(switch),优先使用多态函数(见第90条)。

## 例外情况

如果一个函数的功能无法合理地重构为多个独立的子任务(因为任何重构尝试都需要传递许多局部变量和上下文,使重构结果的可读性非但不好,反而更差),那么它的较长和嵌套较多就是合理的。但是如果有几个这样的函数都具有相似的参数,那么它们就有可能成为一个新类的成员。

# 21. 避免跨编译单元的初始化依赖

保持(初始化)顺序:不同编译单元中的名字空间级对象决不应该在初始化上互相依赖,因为其初始化顺序是未定义的。这样做会惹出很多麻烦,轻则在项目中稍做修改就会引发奇怪的崩溃,重则出现严重的不可移植问题--即使是同一编译器的新版本也不行。

---

在不同的编译单元中定义两个名字空间级的对象时,先调用哪一个对象的构造函数是没有定义的。经常(但并非总是)工具可能会碰巧按照编译单元目标文件的连接顺序初始化,但这种假设并不总是可靠的;即使确实如此,你总不会希望自己代码的正确性难以捉摸地依赖于makefile或者项目文件。(更多顺序依赖的恶果,另见第59条。)

因此,在任何名字空间级对象的初始化代码中,不能假设其他编译单元中定义的任何其他对象都已经初始化了。

请注意,甚至在使用构造函数构造之前,名字空间级对象就已经用0静态初始化过了(与自动对象等初始时包含无用数据相反),有些自相矛盾的是,这种零初始化会使错误更难以检查,因为静态的零初始化不会迅速使程序崩溃,而是使未初始化对象显现出一种看似合法的表象。你可能认为字符串是空的,指针是空的,整数型变量为0,而事实上,代码已经费劲地将它们初始化了。

为了避免这一问题,应该尽可能地避免使用名字空间级的变量,它们很危险(见第10条)。如果确实需要可能依赖于另一个变量的此种变量,可以考虑使用Singleton (单体)设计模式;使用时要小心一些,可以通过确保对象在第一次访问时被初始化,来避免隐含的依赖性。Singleton本质上也是全局变量(另见第10条),它会因为相互依赖或者循环依赖而被破坏(同样,零初始化只会使情况更复杂)。

# 22. 尽量减少定义性依赖。避免循环依赖

不要过分依赖:如果用前向声明(forward declaration )能够实现,那么就不要包含(#include)定义。不要互相依赖:循环依赖是指两个模块直接或者间接地互相依赖。所谓模块就是一个紧凑的发布单元(见“名字空间与模块”部分的引言部分)。互相依赖的多个模块并不是真正的独立模块,而是紧紧胶着在一起的一个更大的模块,一个更大的发布单元。因此,循环依赖有碍于模块性,是大型项目的祸根。请避免循环依赖。

---

除非确实需要类型定义,否则应该优先使用前向声明。

- 需要知道C对象的大小时:例如,在栈中分配一个c,或者作为另一个类型直接具有的成员分配一个c.
- 需要命名或者调用C的成员时:例如,调用成员函数时。

一般而言,应该在模块层次上考虑依赖性及其循环。模块是一同发布的类和函数的紧凑集合(见第5条和“名字空间与模块”部分的引言部分)

为了打破循环,可以应用[Martin96a]和[Martin00] (另见第36条)中记载的依赖倒置原理(Dependency Inversion Principle):不要让高层模块依赖于低层模块;相反,应该让两者都依赖于抽象。

依赖有一种特殊形式,一些设计颇受其害:派生类的传递依赖(transitive dependency),即基类依赖于所有的派生类,包括直接的和同接的。Visitor (访问器)设计模式的一些实现就会导致这种依赖。它只对极为稳定的类层次而言是可以接受的。否则可能需要修改设计,例如使用Acyclic Visitor (非循环访问器)模式[Martin98]。

过度相互依赖的一个症状,就是局部发生变化时需要进行增量构建,不得不重新编译项目中的很大一部分代码(见第2条),

## 例外情况

类之间的依赖循环并不一定都是坏事-只要类被认为属于同模块,一起测试,一起发布。诸如Command和Visitor等设计模式的原始实现就会产生大量相互依赖的接口。这种相互依赖可以被打破,但是需要进行明确的设计才行

# 23. 头文件应该自给自足

各司其责:应该确保所编写的每个头文件都能够独自进行编译,为此需要包含其内容所依赖的所有头文件。

---

如果一个文件包含某个头文件时,还要包含另一个头文件才能工作的话,就会增加交流障碍,给头文件的用户增添不必要的负担。

多年前,有些专家曾建议头文件不应该包含其他头文件,因为多次打开和分析带包含保护符(#incude guard)的头文件会增加开销。幸运的是,这基本上已经过时了,许多现代的C++编译器能够自动识别头文件保护符(见第24条),甚至不会两次打开同一个头文件。有些编译器还提供了预编译的头文件,有助于确保不会经常分析那些常用而且很少变化的头文件。

但是,不要包含并不需要的头文件,它们只会带来零乱的依赖性。

可以考虑采用这种有助于使头文件自给自足的技术:构建时,独立编译每个头文件,并确认没有产生错误或者警告。

# 24. 总是编写内部#include保护符,决不要编写外部#include保护符

为头(文件)添加保护:在所有头文件中使用带有惟一名称的包含保护符(#include guard)防止无意的多次包含。

---

应该用内部包含保护符保护每个头文件,以避免在多次包含时重新定义。

定义包含保护符时,应该遵守如下规则:

- 保护符使用惟一名称:确保名称至少在你的应用程序中是惟一的。上面的代码中采用了流行的命名规范,保护符名称可以包含应用程序名称,还有一些工具,能够生成包含随机数的保护符名称。
- 不要自作聪明:不要在受保护部分的前后放置代码或者注释,要谨遵上面的标准形式。,虽然如今的预处理器能够检测出包含保护符,但是它们的智商有限,只认识正好位于头文件开始和结束处的保护代码。

## 例外情况

在一些非常罕见的情况下,可能需要多次包含一个头文件。

# 25. 正确地选择通过值、(智能)指针或者引用传递参数

正确选择参数:分清输入参数、输出参数和输入/输出参数,分清值参数和引用参数。正确地传递参数。

---

正确选择参数是通过值、通过引用还是通过指针传递,是一种能够最大程度提高安全性和效率的好习惯。

虽然效率不应该是我们预先关注的首要问题(见第8条),但我们当然也没有必要在所有其他因素包括清晰性都相同的情况下编写低效的代码(见第9条)。

选择如何传递参数时,应该遵循以下准则。对于只输入(input-only)参数:

- 始终用const限制所有指向只输入参数的指针和引用。
- 优先通过值来取得原始类型(如char, float)和复制开销比较低的值对象(如Point.complex\<float>)的输入。
- 优先按const的引用取得其他用户定义类型的输入。
- 如果函数需要其参数的副本,则可以考虑通过值传递代替通过引用传递。这在概念上等同于通过const引用传递加上一次复制,能够帮助编译器更好地优化掉临时变量

对于输出参数或者输入/输出参数:

- 如果参数是可选的(这样调用者可以传递null表示“不适用的”或“无需关心的”值),或者函数需要保存这个指针的副本或者操控参数的所有权,那么应该优先通过(智能)指针传递。
- 如果参数是必需的,而且函数无需保存指向参数的指针,或者无需操控其所有权,那么应该优先通过引用传递。这表明参数是必需的,而且调用者必须提供有效对象。

# 26. 保持重载操作符的自然语义

程序员讨厌意外情况:只在有充分理由时才重载操作符,而且应该保持其自然语义;如果做到这一点很困难,那么你可能已经误用了操作符重载。

---

虽然任何人都会同意(我们希望如此)不应该在operator+的实现中实现减法操作,但是还有另外一些微妙的情况存在。例如, Tensor类的operator*是指数积还是向量积呢?operator+=( Tensor& t, unsigned u )是将u加到t的每个元素上,还是重新设置t的大小呢?在这种模糊的或者违反直觉的情况下,应该使用命名函数,避免使本来就像迷一样的代码更加雪上加霜。

对于值类型(但不是所有类型,见第32条): “如果有疑问,就按int类型那样去操作。”[Meyers96]让操作符的行为及它们之间的关系模仿内置类型,能够确保任何人都不会感到惊讶。如果所选择的语义可能使别人吃惊,那么操作符重载可能就不是什么好主意。

程序员通常希望操作符成组出现。

具名函数不大可能有这样的假定关系,因此如果可能对语义产生疑问,要改进代码清晰度时,应该优先采用具名函数。

## 例外情况

有些非常专门的程序库(如分析器生成程序和正则表达式引擎)为操作符定义了特定于领域的规范,与C++语义迥异(如正则表达式引擎可能用operator* 表示"零或者更多"),应该为这种不常见的操作符重载寻找替代方案(比如, [C++TR104]中的正则表达式就使用了字符串,这样可以非常自然地使用*,而无需重载操作符),如果在三思之后,还是不得不选择使用操作符,那么一定要为你的规范定义一个一致的框架,谨防与任何内置操作符发生冲突。

# 27. 优先使用算术操作符和赋值操作符的标准形式

如果要定义a+b,也应该定义a+=b:在定义二元算术操作符时,也应该提供操作符的赋值形式,并且应该尽量减少重复,提高效率。

---

一般而言,对于某个二元操作符@(可能是+、-、*等等),应该定义其赋值形式,使a@=b和a=a@b具有相同的含义(只不过第一种形式可能更高效,它只计算一次a),实现这一目标的标准方法就是用@=来定义@

如果可能,可以将operator@=也设为非成员函数(见第44条)。无论如何,都应将所有非成员操作符放入像T这样的同一个名字空间下,这样既便于调用者使用,又可以避免名字查找问题（见第57条)。

## 例外情况

在一些情况下(比如操作于复数的operator *=),操作符可能要显著地改变其左参数,此时用operator *实现operator *=可能会比反过来更有利。

# 28. 优先使用++和--的标准形式。优先调用前缀形式

如果定义++c,也要定义c++:递增和递减操作符很麻烦,因为它们都有前缀和后缀形式,而两种形式语义又略有不同。定义operator++和operator-时,应该模仿它们对应的内置操作符。如果不需要原值,应该优先调用前缀版本。

---

对于++和--而言,后缀形式返回的是原值,而前缀形式返回的是新值。应该用前缀形式实现后缀形式。

在调用代码时,要优先使用前缀形式,除非确实需要后缀形式返回的原值。前缀形式在语义,上与后缀形式是等价的,输入工作量也相当,只是效率会经常略高一些,因为前缀形式少创建了一个对象。这不是不成熟的优化,这是在避免不成熟的劣化(见第9条)。

## 例外情况

表达模板框架将通过不同的方式保持语义。

# 29. 考虑重载以避免隐含类型转换

如无必要勿增对象(奥卡姆剃刀原理):隐式类型转换提供了语法上的便利(但另见第40条)。但是如果创建临时对象的工作并不必要而且适于优化(见第8条),那么可以提供签名与常见参数类型精确匹配的重载函数,而且不会导致转换。

---

不必要地经历创建临时变量的麻烦,只是为了执行一些不重要的操作,然后就把它们丢弃(见第40条)。

# 30. 避免重载&&、||或, (逗号)

明智就是知道何时应该适可而止:内置的&&、||和, (逗号)得到了编译器的特殊照顾。如果重载它们,它们就会变成普通函数,具有完全不同的语义(这将违反第26条和第31条),这肯定会引入微妙的错误和缺陷。不要轻率地重载这些操作符。

---

不能重载operator&&, operator||或operator, (逗号)的主要原因是,无法在三种情况下实现内置操作符的完整语义,而程序员通常都会需要这些语义。说得更具体一些,内置版本的特殊之处在于:从左到右求值,而&&和||还使用短路求值。

内置版本的&&和||首先计算左边的表达式,如果这完全能够决定结果(对&&而言是false,对||而言是true),就无需计算右边的表达式了—而且能够保证不需要。我们都非常习惯这种方便的特性了,以至于经常会让右边表达式的正确性依赖于左边表达式的成功

- 函数调用将总是在执行之前对所有参数进行求值。
- 函数参数的求值顺序是不确定的。(另见第31条。)

另一些代码即使存在这样的立即求值问题,也不会引起核心转储,但是如果它也依赖于两个表达式的求值顺序的话,那么会由于其他原因而不能正确运行。其效果当然也可能是有害的。

逗号操作符也存在同样的脆弱性。与&&和||一样,内置逗号保证其表达式是从左到右求值的(与&&和||不同的是,它总是要对两个表达式都求值),用户定义的逗号操作符无法保证从左到右求值,通常会产生出乎意料之外的结果。

## 例外情况

表达式模板库是一个例外,设计它的目的就是用来捕获所有操作符。

# 31. 不要编写依赖于函数参数求值顺序的代码

保持(求值)顺序:函数参数的求值顺序是不确定的,因此不要依赖具体的顺序。

---

在C语言的早期,处理器中的寄存器是一种宝贵的资源,为了给高级语言中的复杂表达式高效地分配寄存器,编译器承受着很大压力。为了能够生成更快的代码, C语言的创造者们赋予寄存器分配器额外的自由度:在调用函数时,其参数的求值顺序是悬而未定的。这种动机对于今天的处理器而言当然已经不那么重要了(这么说恐怕还有争议),但在C++中求值顺序不确定仍然是事实,而且因为编译器的不同具体情况变化也很大(另见第30条)。

# 32. 弄清所要编写的是哪种类

了解自我:有很多种不同的类。弄清楚要编写的是哪一种。

---

不同种类的类适用于不同用途,因此遵循着不同的规则。值类(如std:pair, std:vector)模仿的是内置类型。一个值类应该:

- 有一个公用析构函数,复制构造函数和带有值语义的赋值。
- 没有虚拟函数(包括析构函数)。
- 是用作具体类,而不是基类(见第35条)。
- 总是在栈中实例化,或者作为另一个类直接包含的成员实例化。

基类是类层次结构的构成要素。一个基类应该:

- 有一个公用而且虚拟,或者保护而且非虚拟的析构函数(见第50条),和一个非公用复制构造函数和赋值操作符(见第53条)。
- 通过虚拟函数建立接口。
- 总是动态地在堆中实例化为具体派生类对象,并通过一个(智能)指针来使用。

不严格地说来, traits类是携带有关类型信息的模板。一个traits类应该:

- 只包含typedef和静态函数。没有可修改的状态或者虚拟函数。
- 通常不实例化(其构造一般是被禁止的)。

异常类提供了不寻常的值与引用语义的混合:它们通过值抛出,但应该通过引用捕获。一个异常类应该:

- 有一个公用析构函数和不会失败(no-fail)的构造函数(特别是一个不会失败的复制构造函数,从异常的复制构造函数抛出将使程序中止)。
- 有虚拟函数,经常实现克隆(见第54条)和访问(visitation)。
- 从std:exception虚拟派生更好。

# 33. 用小类代替巨类

分而治之:小类更易于编写,更易于保证正确、测试和使用。小类更有可能适用于各种不同情况。应该用这种小类体现简单概念,不要用大杂烩式的类,它们要实现的概念既多又复杂(见第5条和第6条)。

---

设计花哨的大类,是刚开始进行面向对象设计时常犯的典型错误。能够毕其功于一役地让一个类提供完整和复杂的功能当然是很诱人的。但是,设计易于组合的更小的、尽量小的类,才是实践中更为成功的方法,这对任何规模的系统都适用

小的类只体现了一个概念,粒度层次恰到好处。而巨类则很可能体现了几个不同的概念,使用这样的类将增加其他人的脑力耗费(见第5条和第11条)。

小的类更易于理解,被人使用和重用的可能性也越大。

小的类更易于部署。而巨类必须经常以一个笨重而又不可分的单位来部署。例如,一个巨大的Matrix (矩阵)类可能要实现并部署一些比较特殊的功能,比如计算矩阵的特征值-即使大多数类的使用者只需要简单的线性代数计算。更好的封装方式,应该是将各种功能域实现为小的Matrix类型的非成员函数。然后这些功能域能够与需要它们的调用者隔离开来,进行测试和部署(见第44 条)。

巨类会削弱封装性。如果类有许多不需要成为成员的成员函数(因此类的私有实现存在不必要的可见性),那么类的私有数据成员将变得与公用变量几乎一样糟糕。

巨类通常是因为试图预测和提供“完整”的问题解决方案而出现的,实践中,这种类从来都没有真正成功过。人们的需求总是在变化的,有时需要更多,有时又想要更少。

巨类更难保证正确和错误安全,因为它们经常要应付多种职责(见第5条和第44条)。

# 34. 用组合代替继承

避免继承带来的重负:继承是C++中第二紧密的耦合关系,仅次于友元关系。紧密的耦合是一种不良现象,应该尽量避免。因此,应该用组合代替继承,除非知道后者确实对设计有好处。

---

人们经常过度地使用继承,即使是有经验的程序员也会如此。软件工程的一条明智原则,就是尽量减少耦合:如果一种关系不只有一种表示方式,那么应该用可行的最弱关系。

考虑到继承几乎是C++中所能表达的最强关系(仅次于友元关系),因此只有在没有更弱的等价替代选择时,才适合使用。如果用组合就能表示类的关系,那么应该优先使用。

与继承相比,组合有如下重要优点:

- 在不影响调用代码的情况下具有更大的灵活性:私有数据成员是在我们控制之下的。在不破坏客户代码的前提下,可以将通过值保存切换为通过(智能)指针或者Pimpl (见第43条)保存;只需要修改类自身(使用了私有数据成员的)成员函数的实现代码即可。如果决定使用不同的功能,则改变成员类型或者保存成员的方式都很容易,同时又能保持类的公用接口不变。相反,如果一开始就使用公用继承关系,则使用者很可能已经开,始依赖于这种继承关系了;因此,类必须遵守这种关系,以后再想改变其基类设计就难了（见第37条)。
- 更好的编译时隔离,更短的编译时间:通过指针(用智能指针最好)保存对象,而不是以直接成员或者基类的形式,能够减少头文件的依赖性,因为声明对象的指针不需要对象的完整的类定义。相反,继承则总是要求基类的完整定义可见。常用的一种技术是将所有私有成员聚合在一个不透明的指针后面,这个指针就称为Pimpl (见第43条)。
- 减少奇异现象:从一个类型继承,会导致名字查找涉及与该类型同一名字空间中定义的函数和函数模板。这是非常复杂的,很难进行调试(另见第58条)。
- 更广的适用性:有些类一开始并不是想设计成基类(另见第35条)。但是,大多数类都,能充当一个成员的角色。
- 更健壮、更安全:继承的较强耦合性使编写错误安全代码更加困难(见[Sutter021 523)。
- 复杂性和脆弱性降低:继承会带来更多额外的复杂情况,比如名字隐藏,而以后基类的改变也会带来其他麻烦。

## 例外情况

即使不需要为所有调用者都提供可替换性关系,但是如果有以下任何一种需要,那么还是要用到非公用的继承,下面是按最常用(头两点)到极为罕用(其余)排序的:

- 如果需要改写虚拟函数。
- 如果需要访问保护成员。
- 如果需要在基类之前构造已使用过的对象,或者在基类之后销毁此对象。
- 如果需要操心虚拟基类。
- 如果能够确定空基类优化能带来好处,包括这种情况下优化的确很重要,以及这种情况下目标编译器确实能实施这种优化(见第8条)。
- 如果需要控制多态。相当于说,如果需要可替换性关系,但是关系应该只对某些代码可见(通过友元)。

# 35. 避免从并非要设计成基类的类中继承

要独立使用的类所遵守的设计蓝图与基类不同(见第32条)。将独立类用作基类是一种严重的设计错误,应该避免。要添加行为,应该添加非成员函数而不是成员函数(见第44条),要添加状态,应该使用组合而不是继承(见第34条),要避免从具体的基类中继承。

---

人们经常过度地使用继承,即使是有经验的程序员也会如此。软件工程的一条明智原则,就是尽量减少耦合:如果一种关系不只有一种表示方式,那么应该用可行的最弱关系。
