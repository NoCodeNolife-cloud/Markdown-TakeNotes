# 0. 不要拘泥于小节

只规定需要规定的事情:不要强制施加个人喜好或者过时的做法。

---

有些问题只是个人喜好,并不影响程序的正确性或者可读性,所以这些问题不应该出现在编程规范中。任何专业程序员都可以很容易地阅读和编写与其习惯的格式略有不同的代码。应该在每个源文件乃至每个项目中都使用一致的格式,因为同一段代码中要在几种编程风格(style)之间换来换去是很不舒服的。但是无需在多个项目或者整个公司范围内强制实施一致的格式。

* 不要规定缩进多少,应该规定要用缩进来体现代码的结构:缩进空格的数量可以遵照个人习惯,但是至少在每个文件中应该保持一致。
* 不要强制行的具体长度,应该保证代码行的长度有利于阅读:可以遵照个人习惯来决定行长,但是不要过长。研究表明,文字长度不超过10个单词最利于阅读。
* 不要在命名方面规定过多,应该规定的是使用一致的命名规范:只有两点是必需的: (1)永远不要使用“晦涩的名称”,即以下划线开始或者包含双下划线的名称; (2)总是使用形如ONLY_UPPERCASE_NAMES的全大写字母表示宏,不要考虑使用常见的词或者缩略语作为宏的名称(包括常见的模板参数,比如T和U:像“#define T anything"这样的代码是极容易混淆的)。此外,应该使用一致的、有意义的名称,遵循文件的或者模块的规范。(如果你无法决定自己的命名规范,可以尝试如下命名规则:类、函数和枚举的名称形如LikeThis,即单词首字母大写;变量名形如likeThis,即第一个单词首字母小写,第二个单词首字母大写;私有成员变量名形如ikeThis-:宏名称形如LIKETHIS.)
* 不要规定注释体例(除非需要使用工具从特定的体例中提取出文档) ,应该编写有用的注释:尽可能编写代码而不是写注释(比如,见第16条),不要在注释中重复写代码语义,这样很容易产生不一致。应该编写的是解释方法和原理的说明性注释。

# 1. 在高警告级别干净利落地进行编译

高度重视警告:使用编译器的最高警告级别。应该要求构建是干净利落的(没有警告)。理,解所有的警告。通过修改代码而不是降低警告级别来排除警告。

---

编译器是你的朋友。如果它对某个构造发出警告,这经常是说明你的代码中存有潜在的问题成功的构建应该是无声无息的(没有警告的)。如果不是这样,你很快就会养成不仔细查看输出的习惯,从而漏过真正的问题(见第2条)。

排除警告的正确做法是: (1)把它弄清楚;然后, (2)改写代码以排除警告,并使代码阅读者和编译器都能更加清楚,代码是按编写者的意图执行的。

即使程序一开始似乎能够正确运行,也还是要这样做。即使你能够肯定警告是良性的,仍然要这样做。因为良性警告的后面可能隐藏着未来指向真正危险的警告。

## 例外情况

有时候,编译器可能会发出烦人的甚至虚假的警告(即纯属噪声的警告),但是又没有提供消除的方法,这时忙于修改代码解决这个警告可能是劳而尤功或者事倍功半的。如果遇到了这种罕见的情形,作为团队决定,应该避免对纯粹无益的警告再做无用功:单独禁用这个警告,但是要尽可能在刷部禁用,并且编写一个清晰的注释,说明为什么必须禁用。

# 2. 使用自动构建系统

一次按键就解决问题:使用完全自动化(“单操作”)的构建系统,无需用户干预即可构建整一个项目。

---

单操作的构建过程非常重要。它应该能将源文件可靠和可重复地转换为可以交付的软件包。现在已经有了大量自动构建工具,没有理由不用。所以,选择一种,用起来吧。

我们曾经见到不少开发单位忽略了构建系统“单操作”这一需求。有些开发单位认为,用鼠标四处点击几下,运行一些实用工具来注册COM/CORBA服务器,手工复制一些文件,就是很不错的构建过程了。可是,我们都不应该将时间和精力浪费在机器可以干得更快更好的事情上。自动的、可靠的、单操作的构建是非常必要的。

成功的构建应该无声无息,不产生任何警告(见第1条),理想的构建过程不会出现噪声,只会出现一条日志信息: “构建成功"。

==构建有两种模式:增量构建和完全构建。==增量构建只重新构建上次构建(可以是增量的或者完全的)以来发生改变的部分。注意:两次连续增量构建中的第二次构建不应该编写任何输出文件;否则,可能会出现依赖循环(见第22条),构建系统也可能会执行不必要的操作(比如,编写假的肯定要丢弃的临时文件)。

一个项目的完全构建可能有不同形式。可以考虑通过改变许多基本特性来参数化控制构建过程的参数;候选的特性包括目标架构,调试模式还是发布模式,以及范围(基本文件、所有文件、还是完整的安装文件)。一种构建设置能够生成产品的基本可执行文件和库,另一种设置可能还会生成附属文件,而完全构建则可能生成包括所有文件、第三方可重发行文件和安装代码在内的安装文件。

随着项目日渐发展,不使用自动构建所带来的成本也会逐渐增加。如果没有从一开始就使用自动构建,时间和资源的浪费就将无可避免。更糟糕的情况是,到了不得不使用自动构建的时候,你所面临的压力将比项目开始时大得多。大型项目可能应该设置一个“构建管理员”,他的工作就是负责构建系统。

# 3. 使用版本控制系统

请使用==版本控制系统(version control system, VCS)==。永远不要让文件长时间地登出。在新的单元测试通过之后,应该频繁登入。确保登入的代码不会影响构建成功。

---

几乎所有大一点的项目都需要一个以上的开发人员和(或)一周以上的开发时间。在这样的项目中,将需要比较同一文件的各个历史版本,以确定修改是何时(以及/或者由谁)进行的。需要控制和管理源代码的变更。

如果有多个开发人员,他们将会并行地进行修改,可能会在同一时间修改同一文件的不同部分。此时,就需要能对文件进行自动登出/版本管理的工具了,有些情况下还需要并发编辑的合并功能。版本控制系统能够自动化和控制登出、版本管理及合并操作。版本控制系统能够比人工实施更快更正确。而且我们也不需要在管理琐事上浪费时间—编写软件才是我们的工作。

即使是单独工作的开发人员,也有脑子短路的瞬间,需要搞清楚何时为什么引入了某个错误,或者进行了某个修改。我们都难免如此。==版本控制系统能够自动地跟踪每个文件的历史==,使我们能够“让时光倒流”。问题并不在于你是否想从历史中寻找答案,而在于你到底何时需要。

不要破坏构建。版本控制系统中的代码必须总能构建成功。

由于目前能够找到大量的版本控制系统,我们没有任何借口拒之门外。最廉价也最流行的版本控制系统是cvs,这个工具非常灵活,提供了TCP/P访问功能,可以选择增强安全性(提供使用ssh协议作为后端),可以通过脚本编程实现极佳的管理功能,甚至还有图形界面。许多其他的版本控制系统产品要么将cvs作为模仿的标准,要么是以其为基础再构建新的功能。

## 例外情况

只有一个程序员且从头至尾只需一周的项目,可能不需要版本控制系统。

# 4. 在代码审查上投入

审查代码:更多的关注有助于提高质量。==亮出自己的代码,阅读别人的代码。==互相学习,彼此都会受益。

---

好的代码审查过程对开发团队有许多方面的益处,它能够

- 通过来自同伴的良性压力提高代码质量。
- 找出错误、不可移植的代码(如果适用)和潜在的扩展问题。
- 通过思想交流获得更好的设计和实现。
- 快速培养新同事和初入门者。
- 在团队中形成共同的价值观和集体主义。
- 增强整体实力,提升自信心、动力和职业荣誉感。

许多开发单位现在既不奖励高质量的代码和高质量的团队,也不投入时间和资金予以鼓励。我们估计几年之内这种情况仍然会存在,但是趋势已经在缓慢变化,这部分是因为软件安全性需求的不断增加。代码审查恰恰有助于提高软件的安全性,而且还是内部培训的一种极佳方法(而且没有成本)!

如果老板现在还不支持代码审查过程,那就先从提高管理层的认识做起(提示:一开始先给他们看看这本书),同时尽最大努力想各种办法腾出时间进行审查。这种时间是值得花的。代码审查应该成为软件开发周期中的常规环节。如果能够与同事就奖惩制度(根据积极因素,·可能还有消极因素)达成一致,那就更好了。

代码审查无需太形式主义,最好通过书面形式进行—一封简单的电子邮件就足够了。这样能够更容易地跟踪你自己的过程,避免重复。在审查别人的代码时,可能需要保存一份核对表以备参考。我们举贤不避亲地推荐,本书的目录就是一个很好的核对表。愿你使用愉快!小结:我们知道这里有些老调重弹了,但还是不得不说。我们的天性都讨厌代码审查,但是内心又有一个小小的天才程序员乐此不疲,因为它富于成效,而且能够获得更好的代码和更可靠的应用程序。

# 5.  一个实体应该只有一个紧凑的职责

一次只解决一个问题:只给一个实体(变量、类、函数、名称空间、模块和库)赋予一个定义良好的职责。随着实体变大,其职责范围自然也会扩大,但是职责不应该发散。

---

如果一个实体有几个不同的目的,则给使用带来的难度往往会激增,因为这种实体除了会增加理解难度、复杂性和各部分中的错误外,还会导致其他问题。这种实体不仅更大(常常毫无合理理由),而且更难以使用和维护。此外,这种实体经常会为自身的一些特定用途提供有问题的接口,因为各个功能领域之间的部分重叠,会影响干净利落地实现每个功能所需的洞察力。

具有多个不同职责的实体通常都是难于设计和实现的。“多个职责”经常意味着“多重性格”一可能的行为和状态的各种组合方式。==应该选择目的单一的函数(见第39条),小而且目的单一的类,和边界清晰的紧凑模块。==

应该用较小的低层抽象构建更高层次的抽象。要避免将几个低层抽象集合成一个较大的低层次抽象聚合体。用几个简单的行为来实现一个复杂的行为,比反其道而行之更加容易。

# 6. 正确、简单和清晰第一

软件简单为美( Keep It Simple Software, KISS):正确优于速度。==简单优于复杂。清晰优于机巧。安全优于不安全==(见第83条和第99条)。

---

简单设计和清晰代码的价值怎么强调都不过分。代码的维护者将因为你编写的代码容易理解而感谢你-而且这个维护者往往就是未来的你,要努力回忆起6个月前的所思所想。由是有了下面这些经典的格言警句:

程序必须为阅读它的人而编写,只是顺便用于机器执行.-Harold Abelson和Gerald JaySussman

编写程序应该以人为本,计算机第二.-Steve McConnell

计算机系统中最便宜、最快速、最可靠的组件都还不存在.-Gordon Bell

所缺的恰是最精确(永不出错),最安全(坚不可摧),以及设计、文档编写、测试和维护起来最容易的部分,简单设计的重要性怎么强调也不过分.-Jon Bentley

本书中的许多条款都能够自然地产生易于修改的设计和代码,而清晰性是易于维护、易于重构的程序最必需的特征。自己不能充分理解的设计和代码,就更无法充满自信地进行修改了。这里最常见的紧张关系恐怕就在代码清晰和代码优化(见第7条、第8条和第9条)之间。

使一个正确的程序变快,比使一个快速的程序正确要容易得多。要避免使用程序设计语言中的冷僻特性。应该使用最简单的有效技术。

# 7. 编程中应知道何时和如何考虑可伸缩性

小心数据的爆炸性增长:不要进行不成熟的优化,但是要密切关注渐近复杂性。处理用户数据的算法对所处理的数据量耗费的时间应该是可预测的,最好不差于线性关系。如果能够证明优化必要而且非常重要,尤其在数据量逐渐增长的情况下,那么应该集中精力改善算法的O(N)复杂性,而不是进行小型的优化,比如节省一个多余的加法运算。

---

防范可能的未来,也就是说我们要避免设计中含有面对更大的文件、更大的数据库、更多像·素、更多窗口、更多进程和更多线路上传输的数据时会出现的性能陷阱的现象。C++标准库能够成功防范未来的重大因素之一,就是它已经保证了STL容器操作和算法的性能复杂性。

过这种情况,而且我们知道你们也都会碰到,也许已经碰到了。当然,我们可以进行修补,然后给客户发布补厂,但最好还是能避免这样的尴尬和返上。既然所有事物都是平等的(包括清晰性与可读性),那么应该预先做这些事情:

* 使用灵活的、动态分配的数据,不要使用固定大小的数组:那种“比我所需要的最大数组还要大”的数组,在正确性和安全性方面都存在严重问题(见第77条),只有在编译时大小固定不变的数组才是可接受的。
* 了解算法的实际复杂性:要留心那些不易发觉的陷阱,比如看似线性的算法实际上要调用其他线性操作,结果算法实际上是二次的。(见第81条中的例子。)
* 优先使用线性算法或者尽可能快的算法:常数时间复杂性的算法,比如push-back和散列表查询,是最完美的(见第76条和第80条),O(logN)对数复杂性的算法,比如set/map操作和带有随机迭代器的lower_bound和upper_bound,也不错(见第76条、第85条和第86条), O(N)线性复杂性的算法,比如vector:insert和for_each,也可以接受(见第76条、第81条和第84条)。
* 尽可能避免劣于线性复杂性的算法:例如,如果面对的是一个O(NlogN)或者O(N^2^)算法,就必须花费精力寻找替代方案,这样代码才不全于在数据量显著增长的情况下陷入深度激增的性能深潭。
* 永远不要使用指数复杂性的算法,除非你已经山穷水尽,确实别无选择:在决定接受指数算法之前,必须尽力寻找替代方案,因为对于指数算法来说,即使是数据量的有限增加,也会使算法的性能急剧下降。

# 8. 不要进行不成熟的优化

拉丁谚语云,快马无需鞭策:不成熟优化的诱惑非常大,而它的无效性也同样严重。优化的第一原则就是:不要优化。优化的第二原则(仅适用于专家)是:还是不要优化。再三测试,而后优化。

---

我们将不成熟的优化定义为这样的行为:以性能为名,使设计或代码更加复杂,从而导致可读性更差,但是并没有经过验证的性能需求(比如实际的度量数据和与目标的比较结果)作为正当理由,因此本质上对程序没有真正的好处。毫无必要而且无法度量的优化行为其实根本不能使程序运行得更快,这种情况简直是太常见了。

因此,默认时,不要把注意力集中在如何使代码更快上;首先关注的应该是使代码尽可能地清晰和易读(见第6条)。==清晰的代码更容易正确编写,更容易理解,更容易重构-当然也更容易优化。==使事情复杂的行为,包括优化,总是以后再进行的--而且只在必要的时候进行。

不成熟的优化经常并不能使程序更快,这主要有两方面原因。一方面,我们程序员在估计哪些代码应该更快或者更小,以及代码中哪里会成为瓶颈上名声很臭。包括本书的作者,也包括读者你。考虑一下这些事实吧:现代计算机都具有极为复杂的计算模型,经常是几个流水线处理单元并行工作,深高速缓存层次结构,猜测执行(speculative execution) ,分支预测…这还只是CPU芯片。在硬件之上,编译器也在尽其所能地猜测,将源代码转换为最能发掘硬件潜力的机器码。而在这些复杂的架构之上,还有…还有你-程序员的猜测。所以,如果只是猜测的话,你的那些目标不明确的微观优化就很难有机会显著地改善代码。因此,优化之前必须进行度量;而度量之前必须确定优化的目标。在需求得到验证之前,注意力应该放在头号优先的事情上一为人编写代码。(当有什么人要求你进行优化的时候,请进行需求验证。)

另一方面,在现代程序,许多操作越来越不受CPU的限制。它们可能更受内存的限制、网络的限制、硬盘的限制,需要等待Web Service,或等待数据库。即使在最好的情况下,优化这些操作的应用程序代码,也只不过能使等待操作更快。==这也意味若程序员浪费了宝贵的时间去改善没有必要改善的地方,却没有进行需要的有价值的改善。==

##  例外情况

在编写程序库的时候,预测哪些操作最后会用于性能敏感的代码中更加困难。但即使是程序库的编写者,在实施容易令人糊涂的优化之前,也会对很大范围内的客户代码进行性能测试。

# 9. 不要进行不成熟的劣化

放松自己,轻松编程:在所有其他事情特别是代码复杂性和可读性都相同的情况下,一些高效的设计模式和编程惯用法会从你的指尖自然流出,而且不会比悲观的替代方案更难写。这并不是不成熟的优化,而是避免不必要的劣化(pessimization)。

---

避免不成熟的优化并不意味着必然损害性能。所谓不成熟的劣化一词,我们指的就是编写如下这些没有必要的、可能比较低效的程序:

- 在可以用通过引用传递的时候,却定义了通过值传递的参数(见第25条)。
- 在使用前缀++操作符很合适的场合,却使用后缀版本(见第28条)
- 在构造函数中使用赋值操作而不是初始化列表(见第48条)。

如果减少对象的伪临时副本(尤其是在内循环中)并不影响代码的复杂性,那么这个优化就算不上是成熟的优化。在第18条中,我们提倡尽可能将变量声明为局部的,但是又提到了一个例外情况,即有时候将变量从循环中提出来是有好处的。大多数时候,这一点也不会混淆代码的意图,相反,实际上这有助于澄清循环内部执行了哪些功能,哪些计算是不随循环变化的。当然,应该优先使用算法,而不是显式的循环(见第84条)。

构造既清晰又有效的程序有两种重要的方式:使用抽象(见第11条和第36条)和库(见第84条),例如,使==用标准库的vector, list, map, find, sort和其他设施,这些都是由世界级的专家标准化并实现的,不仅能使你的代码更加清晰,更容易理解,而且启动也经常更快。==避免不成熟的劣化在编写库的时候尤其重要。要了解库所使用的所有上下文,通常是不可能的,因此可能需要达到一种平衡,在更加倾向效率和可复用性的同时,又不能因为一小部分潜在的调用者的利益过分提高效率。其中的界限需要你来划定,但是正如第7条所说明的,更需要关注的是可伸缩性,而不是挤掉一个小小的循环。

# 10. 尽量减少全局和共享数据

共享会导致冲突:==避免共享数据,尤其是全局数据。共享数据会增加耦合度,从而降低可维护性,通常还会降低性能。==

---

避免使用名字空间作用域中具有外部连接的数据或者作为静态类成员的数据。这些数据会使程序逻辑变得更加复杂,使程序不同的(而且可能更糟,距离较远的)部分耦合得更加紧密。共享数据对单元测试会产生不良影响,因为使用共享数据的代码片断的正确性不仅取决于数据变化的过程,更取决于以后会使用该数据的未知代码区域的机能。

全局名字空间中的对象名称还会污染全局名字空间

如果必须使用全局的、名字空间作用域的或者静态的类对象,一定要仔细地对其进行初始化。这种对象在不同编译单位中这种对象的初始化顺序是未定义的,正确处理它们需要特殊的技术(参阅本条的参考文献)。初始化顺序规则是非常难于掌握的,应该尽量避免使用;如果不得不用的话,则应该充分了解,小心使用。

名字空间作用域中的对象、静态成员对象或者跨线程或跨进程共享的对象会减少多线程和多处理器环境中的并行性,往往是产生性能和可伸缩性瓶颈的源头(见第7条)。为“无共享”而奋斗吧,用通信方式(比如消息队列)代替数据共享。

应该尽量降低类之间的耦合,尽量减少交互。

# 11. 隐藏信息

不要泄密:==不要公开提供抽象的实体的内部信息。==

---

为了尽量减少操作抽象的调用代码和抽象的实现之间的依赖性,必须隐藏实现内部的数据。否则,调用代码就能够访问—或者更糟,操作—该信息,而原本应属于内部的信息就泄漏给了调用代码所依赖的抽象。应该公开抽象(如果有的话,还是公开领域抽象更好,但至少应该是get/set 抽象),而不是数据。

信息隐藏主要从下列两个方面降低了项目的成本,提高了项目的进度,减少了项目的风险。

- 它限制了变化的影响范围:信息隐藏缩小了变化所引起的“连锁反应”的范围,也降低了由此带来的成本。
- 它强化了不变式:它限制了负责维护(如果有错误的话,也可能是破坏)程序不变式的代码(见第41条)。

不要从任何提供抽象的实体中公开数据(另见第10条)。数据只是抽象、概念性状态的一种可能的具体化而已。如果将注意力集中在概念而不是其表示形式上,就能够提供富于提示性的接口,并按需要对实现进行调整--比如缓存还是实时地计算,又比如使用不同的表示方式,针对某种使用模式(如极坐标与笛卡儿坐标)进行优化。

==绝对不要将类的数据成员设为public== (见第41条),或者公开指向它们的指针或句柄(见第42条)而使其公开,这是一个很常见的信息隐藏的例子,但是它同样适用于更大的实体比如程序库-程序库同样不能暴露内部信息。模块和程序库同样应该提供定义抽象和其中信息流的接口,从而使与调用代码的通信比采用数据共享方式更安全,耦合度更低。

## 例外情况

测试代码经常需要对被测试类或者模块进行白箱访问。值的聚合("C语言式的struct")只是简单地将数据绑在了一起,并没有提供任何抽象,所以它不需要隐藏数据,数据本身就是接口(见第41条)。

# 12. 懂得何时和如何进行并发性编程

如果应用程序使用了多个线程或者进程,应该知道如何尽量减少共享对象(见第10条),以及如何安全地共享必须共享的对象。

---

其中最重要的问题是避免死锁、活锁(livelock) 和恶性的竞争条件(包括加锁不足导致的崩溃)。C++经常而且广泛地用于编写坚固的多线程代码。如果应用程序需要跨线程共享数据,请如下安全行事;

- 参考目标平台的文档,了解该平台的同步化原语:典型的原语包括从轻量级的原子整数操作到内存障栅(memory barrier) ,再到进程内和跨进程的互斥体。
- 最好将平台的原语用自己设计的抽象包装起来:在需要跨平台移植性的时候,这样做尤其有益。或者,也可以使用程序库(比如pthreads [Butenho97)为我们代劳。
- 确保正在使用的类型在多线程程序中使用是安全的:说得具体一些,就是类型必须至少做到以下两个方面。
  - 保证非共享的对象独立:两个线程能够自由地使用不同的对象,无需调用者的任何特殊操作。
  - 记载调用者在不同线程中使用该类型的同一个对象需要做什么:许多类型要求对这种共享对象进行串行访问,但是有些类型却不要求这样。后者通常要么从设计中去掉加锁需求,要么自己进行内部加锁,无论哪种情况,仍然需要留意内部加锁粒度的局限。

在自己编写可用于多线程程序的类型时,也必须完成两项任务:

- 必须保证不同线程能够不加锁地使用该类型的不同对象(注意:具有可修改的静态数据的类型通常不能保证这一点)。
- 必须在文档中说明使用者在不同线称中使用该类型的同一个对象需要做什么,基本的设计问题是如何在类及其客户之间分配正确执行(即无竞争和无死锁地执行)的职责。主要的选择有下列几个方面。
  - 外部加锁:调用者负责加锁,在这种选择下,由使用对象的代码负责了解是否跨线程共字了对象,而且如果是,则还要负责串行化所有对该对象的使用。
  - 内部加锁:每个对象将所有对自己的访问串行化,通常采用为每个公用成员函数加锁的方法来实现、这样调用者就可以不用串行化对象的使用了。

---

- 必须事先知道该类型的对象几乎总是要被跨线程共享的,否则到头来只不过进行了无效加锁。请注意大多数类型都不会遇到这种情况,即使是在多线程处理分量很重的程序中,大多数对象也不会被跨线程共享
- 必须事先知道成员函数级加锁的粒度是合适的,而且能满足大多数调用者的需要。具体而言,类型接口的设计应该有利于粗粒度的、自给自足的操作。如果调用者总是需要对多个而不是一个操作加锁,那么就不能满足需要了,只能通过增加更多的(外部)锁,将单独加锁的函数组装成一个更大规模的已加锁工作单位。
- 不加锁的设计,包括不变性(只读对象):无需加锁。常见的例子是不变对象,它无需加锁,因为它从不发生变化;例如,对于一个不变的字符串类型而言,字符串对象.旦创建就不会改变,每个字符串操作都会创建新的字符串。

# 13. ,确保资源为对象所拥有。使用显式的RAll和智能指针

 C++的“资源获取即初始化" (resource acquisition is initialization,, RAll)惯用法是正确处理资源的利器。RAII使编译器能够提供强大且自动的保证,这在其他语言中可是需要脆弱的手工编写的惯用法才能实现的。分配原始资源的时候,应该立即将其传递给属主对象。永远不要在一条语句中分配一个以上的资源。

---

C++语言所强制施行的构造函数/析构函数对称反映了资源获取释放函数对比如fopen/fclose/lock/unlock和new/delete的本质的对称性。这使具有资源获取的构造函数和具有资源释放的析构函数的基于栈(或引用计数)的对象成为了自动化资源管理和清除的‘’极佳工具。

这种自动化很容易实现优雅、低成本而且天生防错。如果不予采用,就需要手工将调用正确配对,包括存在分支控制流和异常的情形,这可是很不容易而且需要注意力高度集中的任务。既然C++已经通过易用的RAlI提供了如此直接的自动化,这种C语言式的仍然依赖于对资源解除分配的微观管理方式就是不可接受的了。

每当处理需要配对的获取/释放函数调用的资源时,都应该将资源封装在一个对象中,让对象为我们强制配对,并在其析构函数中执行资源释放。

确保所有资源都为对象所有。最好用智能指针而不是原始指针来保存动态分配的资源。同样,应该在自己的语句中执行显式的资源分配(比如new),而且每次都应该马上将分配的资源赋予管理对象(比如shared_ptr),否则,就可能泄漏资源,因为函数参数的计算顺序是未定义的。

## 例外情况

智能指针有可能会被过度使用。如果被指向的对象只对有限的代码(比如纯粹在类的内部,诸如一个Tree类的内部节点导航指针)可见,那么原始指针就够用了。

# 14. 宁要编译时和连接时错误,也不要运行时错误

能够在编译时做的事情,就不要推迟到运行时:编写代码时,应该在编译期间使用编译器检查不变式(invariant) ,而不应该在运行时再进行检查。运行时检查取决于控制流和数据的具体情况,这意味着很难知道检查是否彻底。相比而言,编译时检查与控制流和数据无关,一般情况下能够获得更高的可信度。

---

C++语言为我们提供了许多机会,能够通过将错误检查推迟到编译时而“加速”这一过程。充分利用这些静态检查功能,可以带来下列好处:

- 静态检查与数据和控制流无关:静态检查能够提供独立于程序输入和执行流程的保证。相反,要确保运行时检查足够可靠,需要使用对所有输入都具有代表性的用例进行测试。即使对于最简单的系统而言这也是一件令人生畏的工作。
- 静态表示的模型更加可靠:通常,如果程序较少地依赖于运行时检查,而更多地依赖于编译时检查,就说明它的设计比较出色,因为程序所创建的模型能够正确地使用C++的类型系统来表达。这种情况下,你和编译器将成为伙伴,对程序的不变式有着一致的看法;而运行时检查则经常只是在检查能够静态进行,但是无法精确地在语言中表达的情况下,作为一种应变手段而已。
- 静态检查不会带来运行时开销:用静态检查替换动态检查,所生成的可执行文件会更快,而且不会影响正确性。

C++最强大的静态检查工具之一,就是其自身的静态类型检查。在类型应该如何检查这一问题上,各种语言分成了静态(C++, Java, ML, Haskell)和动态(Smaltak, Ruby, Python, Lisp)两大阵营,争论仍在继续而且依旧激烈。总体而言,这个问题并无定论,支持两种检查方式的语言和开发风格据说都取得了良好的效果。静态检查阵营辩称,采取静态检查可以很容易地省去一大类运行时的错误处理,从而使程序更加牢固。另一方面,动态检查阵营则说,编译器只能检查出一 部分潜在的错误,所以,既然反正无论如何都要写单元测试,那么根本就无需劳神费心地进行静态检在,这样还能拥有一个宽松的编程环境。

有一件事情是肯定的:在静态类型语言C++的环境中(其中提供了强大的静态检查,而对自动运行时检查的支持则很少),程序员肯定应该尽可能地使用能带来优势的类型系统。同时,对于与数据和控制流有关的检查(如数组边界检查或者输入数据验证)来说,使用运行时检查也是明智的选择

## 例外情况

有些情况下,无法在编译时检查,必须进行运行时检查。对于这些情况,应该使用断言来检查内部编程错误,对于其他运行时错误比如与数据相关的错误,则要遵循“错误处理与异常”部分的其他建议进行处理。

# 15.  积极使用const

const是我们的朋友:不变的值更易于理解、跟踪和分析,所以应该尽可能地使用常量代替变量,定义值的时候,应该把const作为默认的选项:常量很安全,在编译时会对其进行检查(见第14条),而且它与C++的类型系统已浑然一体。不要强制转换const的类型,除非要调用常量不正确的函数(见第94条)。

---

常量能够简化代码,因为只需查看定义处的代码就能知道它在各处的值了。

常量正确性是值得实现的,它已经得到证实而且非常有效,应该大力推荐。理解程序状态变化的方式和位置是非常重要的, const将此直接记录在了代码中,编译器可以帮助我们实施这一点。正确编写const自助于更好地理解设计,使代码更牢固、更安全。如果发现有哪个成员函数不可能是const的,通常会使我们更好地理解成员函数修改对象状态的方式。还可以理解哪些数据成员在物理常量性和逻辑常量性之间架起了桥梁。

不要强制转换const,除非要调用常量不止确的函数,或若在一些很罕见的情况下,为了解决老编译器中不支持mutable的问题。

# 16. 避免使用宏

宏是C和C++语言的抽象设施中最生硬的工具,它是披着函数外衣的饥饿的狼,很难驯服,它会我行我素地游走于各处。要避免使用宏。

---

由于几方面的原因,宏已经成为讨厌、恶心、杂乱的混合体,其中最主要的原因在于它们被吹捧为一种文本替换设施,其效果在预处理阶段就产生了,而此时C++的语法和语义规则都还没有起作用。

C++的宏的主要问题在于,它们表面上看起来很好,而实际上做的却是另一回事。宏会忽略作用域,忽略类型系统,忽略所有其他的语言特性和规则,而且会劫持它为文件其余部分所定义(#define)的符号。宏调用看上去很像符号或者函数调用,但实际上并非如此。宏不太“卫生”,也就是说,它会根据自己被使用时所处的环境引人注目而且令人惊奇地展开为各种东西。宏需要进行文本替换,因此编写远距离也正确的宏接近于一种魔法,而精通这种魔法既无意义又无趣味。

不少人都认为与模板相关的错误足最难以解读的,他们可能还没有看到误写和误用的宏所引起的那些错误。模板是C++类型系统的一部分,因此编译器可以更好地对它们进行处理,而宏天生是与语言本身割裂开来的,因此很难处理。更糟的是,与模板不同,宏可能展开为在偶然情况下能够编译的“传输线噪声”。最后,宏中的错误可能只有在宏展开之后才能被报告出来,而不是在定义时。

## 例外情况

宏仍然是几个重要任务的惟一解决方案,比如#include保护符(guard) (见第24条),条件编译中的#idef和#idefined,以及assert的实现(见第68条)。

在条件编译(如与系统有关的部分)中,要避免在代码中到处杂乱地插入#ifdef.相反,应该对代码进行组织,利用宏来驱动一个公共接口的多个实现,然后始终使用该接口。

