# 嵌入式系统入门

## 什么是嵌入式系统

可以把嵌入式系统理解为一种为特定设备服务的软件硬件可裁剪的计算机
系统。

## 嵌入式系统应用领域

*    家用电器和电子类产品

*    交通工具

*    公共电子设施

## 嵌入式系统发展

嵌入式系统的种类繁多， 按照系统硬件的核心处理器来说， 可以分成嵌入式微控制器和嵌入式微处理器。

### 嵌入式微控制器

嵌入式微控制器也就是传统意义上的单片机， 它可以说是目前嵌入式系统的前身。

单片机就是把一个计算机的主要功能集成到了一个芯片上， 简单说，单片机就是一个计算机。 它的特点是体积小、 结构简单、 便于开发， 以及价格经济。

### 嵌入式微处理器

嵌入式处理器在一个芯片上集成了复杂的功能， 同时一些微处理器还把常见的外部设备控制器也集成到芯片内部。 

由于嵌入式微处理器提供了强大的处理能力， 一些厂商以及计算机爱好者在嵌入式微 处理器上面开发了操作系统， 帮助使用嵌入式系统的人简化开发、 提高工作效率， 这在单片机上是很难实现的。

在一个嵌入式微处理器内部集成了许多外部设备控制器。 这种设计方法大大简化了外部电路的设计和调试， 同时整个系统的硬件体积也大幅缩小。

## 典型的嵌入式系统组成

与传统计算机不同的是，嵌入式系统种类繁多。许多的芯片厂商、软件厂商加入其中，
导致有多种硬件和软件， 甚至解决方案。 一般来说， 不同的嵌入式系统的软、 硬件是很难兼容的， 软件必须修改， 而硬件必须重新设计才能使用。 虽然软、硬件种类繁多， 但是不同的嵌入式系统还是有很多相同之处的。

硬件部分可以分成嵌入式处理器和外部设备。 处理器是整个系统的核心， 负责处理所有的软件程序以及外部设备的信号。 外部设备在不同的系统中有不同的选择。 

软件部分可以分成两层，最靠近硬件的是嵌入式操作系统。操作系统是软硬件的接口，负责管理系统的所有软件和硬件资源。 操作系统还可以通过驱动程序与外部设备打交道。最上层的是应用软件， 应用软件利用操作系统提供的功能开发出针对某个需求的程序， 供用户使用。

# 嵌入式软硬件系统

## 电路基本知识

### 模拟电路

处理模拟信号的电路称做模拟电路。 模拟信号的特点是信号是线性变化的，意思是信号变化是连续的。 

### 数字电路

通常数字电路具有逻辑运算和逻辑处理的功能。

与模拟信号不同，数字信号使用电压的高低或者电流的有无表示逻辑上的1或0,因此数字电路可以方便地表示出二进制数。

数字电路可以分成脉冲电路和逻辑电路两部分， 脉冲电路负责信号变换和测量； 逻辑电路负责处理数字逻辑。

与模拟电路不同， 数字电路关心的是信号状态的变化。 通过数字逻辑可以处理复杂的二进制信息， 因此数字电路是计算机的基础。 

### 数制转换

计算机是由数字电路构成的 ， 其内部数据的传输和处理都使用二进制方式。 

二进制的特点是 “逢2进1”。

与十进制数类似，十六进制数是逢16进1位。

## 计算机组成原理

### 计算机体系的发展

计算机是由硬件系统和软件系统两大部分组成的。 按照功能又可以划分为指令系统、存储系统、 输入输出系统等。 

冯. 诺依曼结构是以数学家 John Von Neumann 的名字命名的，他最早提出了该结构。 该结构把计算机分成了<u>运算器、 控制器、 存储器、 输入设备和输出设备</u>5个部分。 它的工作原理是把让计算机工作的指令（也可理解为程序）存储在存储器内，工作的流程是从存储器取出指令， 由运算器运算指令， 控制器负责处理输入设备和输出设备。

哈佛结构最大的特点就是把指令和数据分开存储。 控制器可以先读取指令，然后交给运算器解码， 得到数据地址后， 控制器读取数据交给运算器：在运算器运算的时候，控制器可以读取下一条指令或者数据。

这种把指令和数据分开存储的方式可以获得较高的执行效率。 

### 中央处理器

中央处理器的英文全称是 Central Process Unit，简称 CPU，是一个计算机系统的核心。

CPU 是由运算器、 控制器、 寄存器和内部总线组成的。 在 CPU 之外再加入总线、 存储设备、 输入输出设备就可以构成 个完整的计算机系统。

输入输出设备就可以构成一个完整的计算机系统。

CPU 有几个重要的参数，包括<u>工作频率、 字长、 指令集和缓存</u>。 工作频率通常是用户最多听到的参数， 一个 CPU 的工作频率包括了主频和外频，以及外部总线频率。 主频是CPU 的实际工作频率，外频是 CPU 工作的基准频率，还有 个是总线的工作频率。

决定 CPU 处理数据能力的是 CPU 的字长，有的教材也称做位宽，它是 CPU 在一个周期期能处理的最大数据宽度。

CPU 内部是通过执行指令工作的。 每种 CPU 都有专门的一组指令， 称为指令集。 

按照指令的执行方式可以把计算机 CPU 指令集分成<u>复杂指令集和精简指令集</u>。 复杂指令集(CISC）的特点是使程序中的指令按照顺序执行。 其优点是结构简单， 便于控制；缺点也很明显， 由于指令顺序执行， 计算机各部分不能同时工作， 执行效率不高。 常见的 CISC指令集 CPU 是 Intel 的 X86 系列。

缓存是 CPU 内部一个重要的器件， 主要用来暂时存储指令和数据， 是由于 CPU 内部和外部工作的速度不同造成的。 一个 CPU 的缓存越大， 相对处理指令的能力就越强。

### 存储系统

由于材料和价格因素的限制， 计算机的存储器件在容量、 速度等方面需要匹配。 存储系统的作用就是设计一个让各种存储器相互配置达到最优性价比的方案。

### 总线系统

总线是CPU连接外部设备的通道。通常包括数据总线（DataBus）、地址总线
( AddressBus）和控制总线（ControlBus）。

地址总线负责向外部设备发送地址信息；数据总线负责从外部设备读取或者写入信息：控制总线负责发送信号控制外部设备。

总线的出现规范了 CPU 和外设之间的通信标准，简化了外部器件的设计。使用一些通用的总线可以有效地降低开发成本。

### 输入输出系统

输入输出系统由外部设备和输入输出控制器组成， 是 CPU 与外部通信的系统。 CPU通过总线与输入输出系统相连。由于外部设备的速度差异， CPU 可以使用不同的方式控制外部设备的访问。 常见的有<u>轮询方式、 中断控制方式和 DMA 方式</u>。

嵌入式系统通常会设计许多的中断信号控制线， 供连接不同的外部设备。

#### DMA

对于这种大量的数据传输可以不通过 CPU 而直接传送到内存，这种方式叫做直接内存访问（ Direct Memory Access ）， 简称 <u>DMA</u>。使用 DMA 方式， 外部 设备在数据准备好之后只需要向 DMA 控制器发送一个命令， 把数据的地址和大小传送过 去， 由 DMA 控制器负责把数据从外部设备直接存放到内存。

## 软件基础知识

嵌入式系统的基础是硬件，软件是嵌入式系统的灵魂。

### 什么是软件

 严格地说， 软件是由程序和文档构成的， 程序是一组按照特 定结构细织的指令和数据集合。

通常软件可以分成系统软件和应用软件，以及目前兴起的介于二者之间的中间件软件。

系统软件是使用计算机提供的基本功能，例如操作系统和数据库系统。
软件的另一个组成部分是文档。 随着软件复杂程度的提高，文档也越来越重要。 常见的软件文档有开发文档和用户文档， 前者面向开发人员，后者面向最终用户。软件开发人员应该养成编写文档的好习惯。

### 软件开发流程

<u>需求分析、 概要设计和详细设计、 编码和调试、 测试和维护</u>

编码调试是最关键的一个环节。该阶段根据需求分析的结果，按照文档的要求在特定的平台和工具环境下完成程序编写和调试的工作。在整个软件开发流程中， 编码调试是占用时间开发流程最长的， 这个过程需要细心和经验丰富的程序员来完成。

测试的目的是找出软件的问题，或者存在的缺陷（Bug）。软件测试可以分成不同层次，代码级别的有单元测试，高层的有集成测试等。测试手段的好坏直接决定了软件的质量。

### 常见的软件开发模型

#### 瀑布模型

瀑布模型把软件开发分成需求阶段、 规格说明阶段、 设计阶段和实现阶段。需求阶段由系统分析师确定整个系统的功能需求， 被认可后制定整体的规格并且建立文档。进入设计阶段后，系统分析员按照模块划分整个系统， 并且设计每个模块的功能和接口。最后在完成阶段由程序员完成模块的编码调试，组合成完整的软件。瀑布模型使线型结构便于管理， 被广泛地应用在软件开发团队中。

#### 增量模型

增量模型的思想是，通过不断增加软件的功能完成整个系统。该模型首先开发出一个基本的软件框架，然后在上面不断增加新的功能。增加功能是按照特定的步骤和策略完成的， 最终的目标是完成所有的需求。增量模型的好处是可以让用户尽早地看到软件产品，可以提出意见促进以后的修改。

#### 统一软件开发模型

统一软件开发模型借鉴了之前的成功经验和失败教训，融入了瀑布模型和增量模型的思想。统一软件开发模型把个软件项目分成初始阶段、 细化阶段、 构造阶段和移交阶段。 在每个阶段中保留了瀑布模型的工作流程。在整体的流程上采用增量模型的迭代思想， 不断演进， 最终达到所有需求完成的目标。 统 个复杂的开发过程，适合大型的软件系统。该模型还制定了过程描述语言UML，可以帮助开发人员减少开发过程中的错误。

### 计算机编程语言

计算机语言可以分成机器语言、 汇编语言和高级语言。 

#### 机器语言

机器语言是供计算机本身识别的， 为二进制串。 

#### 汇编语言

汇编语言是对机器语言的抽象， 其实质与机器语言是相同的。汇编语言的指令与机器语言是一对应的。 此外， 汇编语言还设计了伪指令和宏指令， 帮助编程人员提高开发效率。汇编语言是依赖体系结构的，在一种CPU上能执行的汇编语言在其他CPU上可能就无法执行了。

#### 高级语言

高级语言从程序的功能角度出发， 从各种功能中抽象出计算机可以处理的方法提供给用户。 用户可以像使用类似自然语言样书写程序， 极大地提高了开发效率。 高级语言的一个功能或者说是个函数可能对应汇编语言的若干条指令。嵌入式系统开发中常见的高级语言有C和C＋＋。

#### 解释语言

无论是汇编语言还是高级语言都不能被计算机直接执行， 需要转换为机器语言，这个过程叫做编译。 对于高级语言来说， 还有类解释型的语言，通过特定的解释器可以边解释用户编写的程序内容边输出结果。常见的脚本语言都属于解释语言。

### 数据结构

计算机的本质是处理数据的机器。 数据是计算机加工和处理的对象。 计算机中的数据有很多种类， 如何处理数据就成为了一门学问。 

数据结构包括数据逻辑结构、 物理结构和数据操作3方面的内容。

计算机把处理的数据分成多种类型， 包括一些基本结构类型。 数据结构中认为数据元素是基本的类型。 数据的逻辑结构描述数据元素之间的逻辑关系， 是抽象出来的数学模型， 与具体的机器无关。
数据的物理结构描述数据元素的存储结构， 依赖于具体的计算机实现。

## 操作系统知识

#### 什么是操作系统

操作系统是一类特殊的系统软件。 它管理整个系统的所有硬件和软件， 通常是整个计算机系统中最接近硬件的系统软件。 操作系统屏蔽了硬件的底层特性， 向应用软件提供了一个统一的接口。 对于应用软件来说， 不需要知道硬件的具体特性， 使用操作系统提供的接口即可完成相应的功能。 除此之外， 操作系统通过特定的算法统筹安排整个计算机系统软硬件资源， 使计算机的资源利用率更高， 甚至获得比硬件更多的功能。

#### 操作系统由什么组成

按照软件的结构划分， 操作系统可以分成内核、 驱动程序和程序库。 内核是操作系统的核心， 也是整个系统软件的核心。

*    内核从抽象的层面提供最基本的功能， 通常代码短小精炼。 
*    驱动程序是计算机系统必不可少的一类系统软件， 系统和驱动程序打交道而不会直接访问硬件， 硬件的具体细节由驱动程序完成， 是软硬件的接口。 
*    程序库是操作系统向用户提供的程序接口。

#### 几种操作系统的设计思路

通常内核有简单结构、 层次结构、 微内核结构和虚拟机结构等。

##### 简单结构

简单结构比较好理解， 内核中各种功能没有严格的界限， 混杂在一起。

##### 层次结构

层次结构的设计思想是把内核需要提供的功能划分出层次， 最底层仅提供抽象出来的最基本的功能， 每一层利用下面的一层功能， 以此类推， 最上面的层可以提供丰富的功能。 这种设计思路结构清晰是操作系统内核的一大进步。

##### 微内核结构

其设计思想是内核提供最基本最核心
的功能， 注重把系统的服务功能和基本操作分开。 

### 操作系统分类

按照用户角度可以分成单用户和多用户操作系统。 单用户操作系统仅支持一个用户， 特点是系统利用率低，但是便于管理；多用户操作系统支持数个用户， 并且同时可以运行多个用户的程序，提高了资源利用率，但是管理难度也相应提高。

按照系统对任务的处理相应时间来划分， 可以把操作系统分成分时系统和实时系统。分时系统中，不同用户的进程按照定的策略分别得到 CPU 资源，未能得到资源的用户只能等待。 实时系统则不然， 任务是按照优先级和响应时间分配的， 在一个设定的响应时间内， 任务必须得到响应。

随着网络的发展，现在出现了分布式操作系统。通过把一个网络内的计算机资源共享，个计算任务可以分散在不同的计算机上进行， 最后把结果汇总。 分布式操作系统能最大限度地利用现有的资源， 得到强大的计算能力， 是未来科学计算领域的一个发展趋势。

# ARM处理器

ARM 既是一种嵌入式处理器体系结构的缩写，也是一家公司的名字。

## 微处理器和微控制器

微处理器并不是因为制造工艺高超而出名的。现代计算机可以把功能复杂的
CPU，以及一些外部器件都集成在一个芯片上，微处理器因此而得名。

## ARM处理器介绍

ARM 是英文 Advanced RISC Machines 的缩写，中文译为高性能RISC 机器。从名称可以看出， ARM 是一种基于RISC 架构的高性能处理器。

### ARM 微处理器的应用领域

*    工业控制
*    无线通信
*    网络应用
*    消费电子产品

### ARM 的功能特点

ARM核心的处理器采用RISC体系结构， 具有以卡优点：

*    芯片体积小，功耗低， 制造成本低， 性能优异。
*    支持Thumb ( 16位）和ARM (32位）指令集， 8位和16位设备兼容性好。
*    由于采用RISC架构，在内部大量使用寄存器，执行指令速度快。
*    大部分的指令都是操作寄存器， 只有很少指令会访问外部内存。
*    采用多级流水线结构处理速度快。
*    支持多种寻址方式， 数据存取方式灵活。
*    指令长度固定， 便于编译器操作以及执行指令。

## ARM指令集

指令集指 个微处理器所有指令的集合， 每种微处理器都有自己的指令集。

ARM处 理器使用RISC(精简指令集)。

精简指令集的最大特点是所有的指令占用相同的存储空间。

### 算术运算指令

算术运算指令用于普通数据计算。常见的指令有ADD、ADC、SUB和SBC。

#### ADD指令

ADD指令用于普通的加法运算。

```
ADD{条件}{S}<dest>,<op_1>,<op_2> 
//dest是目的寄存器，op 1和op 2是操作数dest = op_1 + op_2
```

ADD指令把两个操作数 op_1和 op_2 相加， 结果存放到目的寄存器 dest 中。 操作数op_1 和 op_2 可以是寄存器或者是 个立即数。

#### ADC指令

ADC 指令用于带进位的加法运算。

```
ADC{条件}{S}<dest>, <op_1>, <op_2> 
//dest是目的寄存器，op_l和op_2是操作数dest = op_1＋ op_2 + carry  
```

ADC 指令把两个操作数 op_1 和 op_2 相加， 结果存放到目的寄存器 dest 中。 ADC 指在使用一个进位标志位， 可以进行大于 32 位的加法操作。 如计算两个 32 位数的和， 结果可以存放到一个64位数中。

#### SUB指令

SUB指令用于普通的减法运算。

```
SUB{条件}{S}<dest>, <op_1>, <op_2>
//dest是目的寄存器，op l 和 op 2是操作数dest = op 1 - op 2 
```

SUB指令使用操作数op_1减去操作数op_2， 结果存放到目的寄存器dest中。

#### SBC指令

SBC指令用于带借位的减法运算。

```
SBC｛条件｝｛S} <dest>, <op 1>, <op 2> 
//dest是目的寄存器，op_1 和 op_2是操作数dest = op_1 - op_2 - !carry
```

SBC指令的作用是两个操作数的减法， 结果存放到目的寄存器中。SBC指令支持借位标志， 因此可以支持大于32位数的减法操作。

### 逻辑运算指令	

#### AND指令

AND指令求两个操作数的逻辑与的结果。

```
AND｛条件｝｛S} <dest>, <op l>, <op 2>
//dest是目的寄存器，op_1 和 op_2是操作数dest = op_1 AND op_2 
```


AND指令在两个操作数op_1和op_2之间做逻辑与操作，结果存放到目的寄存器dest

#### EOR指令

EOR指令对两个操作数做异或运算。

```
EOR{条件}{S}<dest>, <op_1>, <op_2> 
//dest是目的寄存器，op_1 和 op_2 是操作数 dest ＝ op_1 EOR op_2
```

EOR 指令的作用是对两个操作数 op_1 和 op_2 做逻辑异或操作，结果存放到目的寄存器中， 常被用于设置某个特定位反转。 EOR 指令中， op_1 是寄存器， op_2 可以是寄存器或者立即数。

#### MOV指令

MOY 可以在两个操作数之间复制数据。

```
MOV{条件}{S}<dest>, <op_1> 
//dest是目的寄存器，op_1是操作数dest = op_1
```

MOY 指令的作用是把另一个寄存器或者立即数复制到目的寄存器中， 支持操作数的移位操作。

#### 分支指令

在汇编语言中， 代码的跳转都是通过分支指令来完成， ARM 的分支指令比较简单

B 指令可以根据设置的条件跳转到指定的代码地址。

```
B{条件}<地址>
```

B指令是分支跳转指令。 程序中遇到B指令会立即跳转到指定地址， 然后继续从新的地址开始运行程序。 高级语言（例如C语言）的 goto 语句常被翻译成B指令。

#### 数据传送指令

数据传送指令用于 CPU 和存储器之间的数据传送，是 ARM 处理器唯一能与外部存储器交换数据的一类指令。

##### 单一数据传送指令

单一数据传送指令用于向内存装载和存储一个字节或者一个字长的数据。

```
LDR{条件}  Rd,＜地址>
STR{条件}   Rd, ＜地址>
LDR{条件}B   Rd, ＜地址>
STR{条件}B   Rd, ＜地址>
```

单一数据传送指令 STR 和 LDR 可以在内存和寄存器之间装载或者存储一个或多个字节的数据，并且提供了灵活的寻址方式。 Rd 是要操作的数值，地址可以是基址寄存器Rbase和变址寄存器Rindex 指定的地址。 在条件后加入标志B代表一次传送1字节数据。 

```
STR Rd, [Rbase] 		；存储Rd到Rbase所包含的有效地址
STR Rd, [Rbase, Rindex]    ；存储Rd到Rbase+Rindex所合成的有效地址
STR Rd, [Rbase, #index]    ；存储Rd到Rbase+index所合成的有效地址。index是立即数
```

#### 多数据传送指令

多数据传送指令用于向内存装载和存储多个字节或字的数据。

```
xxM{条件}{类型} Rn {!}，＜寄存器列表＞{^}
```

其中， xx 可以是LD， 表示装载， 也可以为ST，表示存储。 多数据传送指令用于寄存器和内存之间多个数据的复制。

```
LDMED LDMIB                             ;装载前增加地址，相当于c语言的++p
LDMFD LDMIA                            ;装载后增加地址，相当于c语言的p++
LDMEA LDMDB                           ;装载前减小值，相当于C语言的++*p
LDMFA LDMDA                           ;装载后减小值，相当于C语言的*p++
STMFA STMIB                              ;存储前增加地址
STMEA STMIA                             ;存储后增加地址
STMFD STMDB                            ;存储前增加值
STMED STMDA                           ;存储后增加值
```

多数据传送指令用在大量数据传送场合， 充分利用了RISC体系多寄存器的优点。

## ARM的结构

基于ARM的芯片有许多， 功能结构也不同， 但是最基本的是ARM核。 

### ARM 体系结构的命名方法

ARM体系结构的命名可以分成两部分，一部分是ARM体系版本的命名， 另一部分是ARM体系版本的处理器命名。

#### ARM体系结构指令集列表

| 指令集缩写 | 含义                 |
| ---------- | -------------------- |
| T          | Thumb指令集          |
| J          | 支持Java加速器       |
| M          | 长乘法指令集         |
| SIMD       | 多媒体功能扩展指令集 |
| E          | 增强 DSP 指令集      |

在同一个版本的ARM体系下，可以支持不同的指令集。

#### ARM处理器功能命名列表

| 功能缩写 | 含义                    |
| -------- | ----------------------- |
| T        | 支持 Thumb 指令集       |
| E        | 支持增强 DSP 指令       |
| D        | 支持片上调试            |
| J        | 支持 Java 程序加速      |
| M        | 支持快速乘法器          |
| F        | 支持浮点运算单元        |
| I        | 支持嵌入式 ICE 调试     |
| -S       | 综合版本， 支持所有功能 |

>    ARM7TD阳表示基于ARM 内核的第7个版本， 支持Thumb指令集、 片上调试、 快速乘法器， 以及嵌入式ICE调试； 三星的S3C2440A芯片是ARM920T-S类型的处理器， 表示ARM核版本是 9， 支持所有的功能。

### 处理器工作模式

ARM微处理器的两种工作状态：Thumb状态和ARM状态。 

Thumb状态就是一种执行Thumb指令集的状态， 这种状态下指令都是16位的， 并且是双字节对齐的。

ARM状态下执行32位的ARM指令。 

ARM微处理器可以在工作中随时切换状态。

ARM体系要求在处理器启动的时候应该处于ARM状态。 ARM处理器使用操作寄存器的 0 位表示工作状态， 取值是l时代表Thumb状态， 取值是0时代表ARM 状态。 可以使用BX指令切换状态。 当处理器启动的时候操作寄存器取值为0， 保证了默认进入ARM状态。

#### ARM 处理器的工作模式

| 工作模式名称           | 含义                                    |
| ---------------------- | --------------------------------------- |
| 用户模式（usr)         | 正常的程序执行状态                      |
| 快速中断模式（fiq)     | 高速数据传输和通道处理                  |
| 外部中断模式（irq)     | 通用中断处理                            |
| 管理模式（svc)         | 操作系统使用（相当于x86体系的保护模式） |
| 数据访问终止模式（abt) | 虚拟内存和存储保护使用                  |
| 系统模式（sys)         | 运行具有特权的操作系统任务              |
| 未定义模式（und)       | 执行了不存在的指令进入该模式            |

系统软件和外部中断都可以改变ARM处理器的工作模式。 应用程序运行在用户模式下， 此时， 一些被保护的资源是不能被用户访问的。 除用户模式外， 另外6种模式都称做特权模式。 特权模式的响应代码由操作系统提供， 用户是不能直接访问的。 

<u>**ARM处理器收到异常后， 把当前模式下一条指令的地址存入LR寄存器，把CPSR寄存器内容复制到SPSR寄存器中，然后根据异常类型设置CPSR的运行模式， 处理器进入对应的异常模式。 异常处理结束后，处理器把LR寄存器保留的指令地址写回PC寄存器，然后复制SPSR内容到CPSR寄存器。 如果异常处理程序设置了中断屏蔽， 则需要清除。 经过这些步骤， 处理器返回异常处理前的工作模式。**</u>

### 存储系统

嵌入式微处理器大多采用一种线性的存储管理方式，ARM也是如此。 

系统内所有的存储器和外部设备都被安排到一个统一的地址空间内， 通过地址映射到不同的设备， 在访问某个设备时， 只需要访问该设备映射的内存地址即可。 线性地 址空间便于处理器的管理和用户操作。

在操作超过8位的数据时， 存在两种不同的访问方法： 大字端模式和小字端模式。 

两种模式的区别是读取数据的先后顺序不同。大字端模式第1字节数据在高位， 小字端正好相反。 通常， 在网络上传输的数据都采用大字端模式， 使用这种方式也称做网络序；此外， 把小字端称做主机序。

MMU( Memory Manager Unit，内存管理单元）。ARM用了线性地址空间， 当一个程序访问外部设备时， 是通过访问一个内存地址实现的。

ARM处理器中还有一项FCSE ( Fast Context Switch Extension）快速上下文切换的技术。 该技术的特点是通过修改系统中不同进程的虚拟地址， 避免了进程切换中物理地址和虚拟地址的映射， 提高了进程的切换速度。 

### 寻址方式

寻址就是根据指令中的地址码找出操作数地址的过程， 是计算机中很重要的一个部分。 对编写程序来说， 不同的寻址方式是存取速度和存取空间权衡的一个考虑因素。

#### 立即寻址

立即寻址方式中操作数已经写在了指令里面， 取出指令时会把操作数也取出来。 这是 最简单的寻址方式。 

```
SUBS R0, R0, #1            ；R0减一写回R0
MOV R0, #0xff00         ；给 R0 赋值0xff00
```

立即寻址使用 “ ＃ ”表示数值。

#### 寄存器寻址方式

该寻址方式中， 操作数存放在寄存器中， 指令直接读取寄存器即得到操作数。

```
MOV R1, R2              ；把R2的值赋给R1
SUB R0, R1, R2         ；把R1-R2的值写入R0
```

#### 寄存器偏移寻址

该寻址方式把寄存器的值移位得到结果。 

```
MOV R0, R1, LSL #3                        ；把R1的值左移3位写入R0，即R0=R1*8
ANDS R0， R1， R2， LSL #R3        ；把R2的值左移R3位，然后与R1做与操作，结果写入R0
```

#### ARM处理器支持的移位操作

| 操作名称                                                 | 功能                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| LSL ( Logical Shift Left）逻辑左移                       | 寄存器的二进制位从右往左移动， 空出的位补0。                 |
| LSR ( Logical Shift Right）逻辑右移                      | 寄存器的二进制位从左往右移动， 空出的位补0                   |
| ASR (Arithmetic Shift Right）算术右移                    | 移位过程中保持符号位不变， 即如果源操作数为正数，贝lj字的高端空出的位补 0，否则补 l |
| ROR (Rotate Right）循环右移                              | 寄存器的低端移出的位填入手的高端空町的位                     |
| RRX ( Rotate Right eXtended by I place) 带扩展的循环右移 | 操作数右移一位，高端空出的位用原C标志值填充                  |

#### 寄存器间接寻址

该方式把寄存器的值当做地址， 然后从对应的内存中取出数据。

```
LDR R0, [R1]                     ；把R1的值当做地址，从内存中取出数据存放到R0
SWP R0, R0, [R1]              ；把Rl的值当做地址， 从内存中取出数据与RO交换
```

#### 基址寻址

该方式把寄存器的内容与指定的偏移相加， 得到数据地址， 然后从内存取得数据。

```
LDR R0,[R1,#0xf]      ;把R1的数值与Oxf相加得到数据地址
STR R0, [R1, #-2]     ;把R1的数值减去2得到数据地址
```

#### 多寄存器寻址

该方式允许一次可以传输多个寄存器的值。

```
LDMIA R1!,{R2-R7,R12}  ;把R1单元中的数据读出到R2～R7和R12,Rl指定的地址自动加l
STMIA R0!,{R3-R6,R10}  ;把R3～R6和R1O中的数据保存到R0指向的地址，R0的地址自动加1
```

#### 栈寻址

校是一个特殊的数据结构， 数据采取 “ 先进后出 ” 的方式。找寻址通过一个战指针寄存器寻址。 

```
STMFD SP!,{R0~R7,LR}   ;把R0～R7和LR的内容压入堆栈
LDMFD SP!,{RO~R7,LR}   ;从堆栈中取出数据到R0～R7和LR
```

## ARM的功能选型

### ARM 的选型原则

#### ARM核心

使用 Windows CE或者Linux之类的操作系统可以减少开发时间， 但是至少需要选择ARM720T以上并且带有MMU C内存管理单元） 的芯片，ARM920T、 ARM922T等核心的芯片都可 以很好地支持Linux。

#### 时钟控制器

ARM芯片的处理能力由时钟速度起决定作用。

不同的处理器时钟处理方式也不同， 在一个处理器上可以有一个或者多个时钟。 
一般来说，处理器的时钟频率越高， 处理能力也越强。

#### 内部存储器

许多ARM芯片都带有内部存储器FLASH和RAM。 带有内部存储器的芯片， 无论是安装还是调试都很方便， 而且减少了外围器件， 降低了成本。

##### 常见几种ARM芯片内部容量列表

| 芯片型号   | 供应商  | FLASH容量/B | RAM容量/B |
| ---------- | ------- | ----------- | --------- |
| AT91FR4081 | ATMEL   | 1M          | 128K      |
| SAA7750    | Philips | 384K        | 64K       |
| HMS30C7202 | Hynix   | 192K        | 无        |
| LC67F500   | Snayo   | 640K        | 32K       |

####  中断控制器

标准的ARM核仅支持快速中断(FIQ)和标准中断(IRQ)两种中断。

#### GPIO

GPIO的数量也是一个重要指标。嵌入式微处理器主要用来处理各种外围设备数据，如果一个芯片支持较多的GPIO引脚，无疑对用户的开发和以后扩展都留有很大余地。

#### 实时钟RTC

RTC是英文Real Time Clock的简称，称为实时钟控制器。

用户可以通过RTC控制器的数据寄存器直接得到当前的日期和时间。

#### 串行控制器

串行通信是嵌入式开发必备的 个功能。用户在开发的时候都需要用到串口， 查看调试输出信息， 甚至提供给客户的命令行界面也都是通过串口控制的。 几乎所有的ARM芯片都集成了UART控制器， 用于支持串口操作。

#### WatchDog

目前， 几乎所有的ARM芯片都提供了看门狗计数器， 操作也很简单。

#### 电源管理功能

一般的芯片都有省电模式、 睡眠模式和关闭模式。

#### DMA控制器

直接访问硬盘等外部高速数据设备。

#### $I^2C$接口

$I^2C$是常见的一种芯片间的通信方式。

#### ADC和DAC控制器

有的ARM芯片集成了ADC和DAC控制器，可以方便地与处理模拟信号的设备互联。

模数转换器(ADC)，将模拟信号转换成数字信号。

数模转换器(DAC)，将数字信号转换成模拟信号。

#### LCD控制器

提供界面。如果需要向客户提供一个LCD屏界面，选择一个带有LCD控制器的芯片可以极大地降低开发成本。

#### USB 接口

USB ( Universal Serial Bus，通用串行总线）是目前最流行的数据接口。在嵌入式产品中提供一个USB接口很大程度上方便了用户的数据传输。许多ARM芯片都提供了USB 控制器，有些芯片甚至同时提供了USB主机控制器和USB设备控制器，例如S3C2440A处理器。

#### $I^2S$接口

$I^2S$是Integrate Interface of Sound的简称，中文意思是集成音频接口。使用该接口可以把解码后的音频数据输出到音频设备上。如果是开发音频类产品，例如MP3这个接口是必需的。

### 几种常见的ARM核处理器选型参考

#### Intel的IXP处理器

IXP系列处理器是Intel推出的针对网络处理的嵌入式芯片。该芯片基于ARMS内核， 并且专门为网络应用设计的微引擎用于网络数据包转发。

#### Philips的LPC处理器

LPX21XX系列处理器是飞利浦公司推出的基于ARM7TDMI内核的微控制器。其特点是体积小， 集成了丰富的外部设备控制器， 并且具有很强的处理和控制功能， 在测量和工业控制领域有很多应用。

#### 三星的S3C244X处理器

三星的S3C244X系列处理器是基于ARM920T内核的嵌入式微处理器。该处理器集成 了丰富的外部控制器和多种总线， 在消费类电子领域有广泛应用。

# 嵌入式Linux

## 常见的嵌入式操作系统

嵌入式操作系统， 通俗地说就是为嵌入式系统设计的操作系统， 是运行在嵌入式硬件上的 类系统软件。 嵌入式系统负责管理系统资源， 为用户提供调用接口， 方便用户应用程序开发。 

嵌入式操作系统是由启动程序（Boot loader）、 核心（ Kernel）、 根文 件系统（ Root File System）组成的。 通过特殊的烧录工具把编译好的嵌入式系统文件映像烧写到目标板的只读存储器(ROM）或者 Flash存储器中。

### VxWorks 

VxWorks 是美国 WindRiver 公司（国内也称做风河公司）开发的高性能实时嵌入式操作系统。 其特点是使用了自己开发的WIND内核， 有着很高的实时性能。 该系统支持多种处理器， 包括 PowerPC、 x86、 MIPS、 ARM 等， 内核具备很好的裁剪能力， 支持应用程序
动态下载和链接。 

VxWorks 系统内核是由进程管理、存储管理、 设备管理、 文件管理、 网络协议等组成。内核占用很小的存储􀂇间， 最小的W卧ID内核可以配置到编译后仅有十几KB大小。 精炼的内核保证了优异的实时性能。

### Windows CE

Windows CE 是微软公司为嵌入式产品设计的一种嵌入式操作系统，主要针对需要多线程、 多任务而且资源有限的设备。 该系统采用模块化设计， 开发人员可以定制不同的功能。 Windows CE 系统支持丰富的外部硬件设备， 包括键盘、 鼠标、 触摸板、 串口、 网 口、 USB、音频设备等。 并且该系统有与 Windows 一致的图形界面， 可以很好地提高用户体验。

### PalmOS

Palm 是 3Com 公司开发的一种掌上电脑产品。 PalmOS 是为该掌上电脑专门设计的一 种 32 位嵌入式操作系统。

Palm OS 最大限度地考虑了节能和硬件资源问题， 提供了良好的电源管理功能和合理的内存管理功能。Palm 设备的内存都是可读写的 RAM，所以访问速度非常快。此外 PalmOS还有很强的同步能力， 可以与 PC 同步数据。

### Symbian

Symbian OS 中文名称叫做塞班系统， 是由诺基亚、 索尼爱立信、 摩托罗拉等几家移动通信设备制造商联合设计的嵌入式操作系统。 塞班系统主要针对于机， 设计目标是简单易用。

塞班系统有一个强大的核心， 支持对象导向系统和Sun Java语言。 该系统的应用程序主要使用C＋＋和Java开发， 从应用开发角度来说， 可以缩短开发周期。 塞班系统本身支持 多种外部设备， 而且为厂商和用户留有丰富的接口并且提供了开发工具。

## **Linux 是什么与如何学习**

### **Linux** **是什么**

Linux系统是一个免费使用的类似UNIX的操作系统， 最初运行在x86体系结构， 目前己经被移植到数十种处理器上。

由于不同的硬件他的功能函数并不相同，例如 IBM 的 Power CPU 与 Intel 的 x86 架构就是不一样！所以同一套操作系统是无法在不同的硬件平台上面运作的！

如果你想要让 x86 上面跑的那套操作系统也能够在 Power CPU 上运作时，就得要将该操作系统进行修改才行。如果能够参考硬件的功能函数并据以修改你的操作系统程序代码， 那经过改版后的操作系统就能够在另一个硬件平台上面运作了。 这个动作我们通常就称为<u>『软件移植』</u>了！

Linux不仅支持丰富的硬件设备、 文件系统， 更主要的是它提供了完整 的源代码和开发工具，对于嵌入式开发来说， 使用Linux系统可以帮助用户从底层了解嵌入式开发的全过程， 以及一个操作系统内部是如何运作的。 

### GPL 版权协议介绍

GPL是自由软件基金会为促进开放源代码软件发展而设计的一种版权协议。 GPL版权协议规定， 使用该协议的软件作者必须公开全部源代码， 源代码的版权归作者所有。 GPL还规定了使用带有GPL版权协议的软件， 必须公开源代码且遵守GPL版权协议。 从GPL 版权协议可以看出， 它是一种递归的定义， 凡是采用GPL版权协议的软件， 按照协议的规 定无论如何发展． 最终都是开放源代码的。

### Linux发行版

#### Red Hat

当今世界使用数量最多的 Linux 发行版可能就是 Red Hat 公司的 Linux 发行版了。 

Red Hat 公司发行两个系列的 Linux 发行版。其中，Red Hat Enterprise Linux ( RHEL） 是企业版本， 是一种收费的 Linux 发行版；还有一种 Red Hat Fedora Core 是由自由软件社区维护的免费版本。 Red Hat 公司推荐使用RHEL 版本。Red Hat 公司出品的 Linux 发行版的特点是用户数量多，因此在遇到问题时有众多的技术支持资源。 此外， Red Hat 开发了自己的 RPM 软件包管理器， 也是 Linux 系统上使用最多的软件管理器。 读者可以通过网络下载或者到软件商店购买 Red Hat 的发行版。

#### Debian

Debian 是自由软件社区使用最多的发行版。 Debian 的发行可以算是最遵守 GNU 规范的，它的系统把每个版本都分成 stable （稳定版）、 testing （测试版）和 unstable （不稳定版）。 其中，unstable 版包含最新的软件包，但是不保证系统是稳定的，适合桌面用户使用；testing是正在测试的版本， 相对 unstable 稳定： stable 是经过测试的稳定版本， 适合服务器或者软件开发者使用。

#### Ubuntu

Ubuntu 是基于 Debian 的 个 Linux 发行版。 Ubuntu 最大的特点就是继承了 Debian 强 大的软件包管理， 并且安装非常容易。 此外 Ubuntu 的更新速度也比 Debian 要快， 新的软件包很快就被集成到 Ubuntu 系统中。

此外， Ubuntu 的图形界面在 目前主流的 Linux 发行版中也是最完善的， 对桌面用户来说， 安装和使用都非常容易。

### 常见的嵌入式Linux系统

#### RT-Linux嵌入式系统

RT-Linux系统强调的是实时处理能力。

该系统设计的思想是在Linux内核之外设计了一个精巧的内核，把传统的Linux作为一个 应用程序执行。用户程序也可以和传统的内核并列工作，由新设计的实时内核统一调度， 达到了良好的实时性。RT-Linux的设计思想兼顾了实时调度，又保留了Linux内核的强大功能，是一种优秀的嵌入式Linux系统。

#### µClinux嵌入式系统

Linux内核本身支持MMU（内存管理单元），对于一些没有MMU的处理器，Linux 无法在上面工作。µClinux是针对这类没有MMU的处理器设计的，它去掉了传统Linux 内核的MMU功能，并且移植到了多种平台上。

### Linux历史

*    Unix 的前身是由贝尔实验室(Bell lab.)的 Ken Thompson 利用汇编语言写成的， 后来在 1971-1973 年间由Dennis Ritchie 以C 程序语言进行改写，才称为 Unix。
*    1977 年由Bill Joy 释出 BSD (Berkeley Software Distribution)，这些称为Unix-like 的操作系统。
*    1984 年由Andrew Tanenbaum 开始制作Minix 操作系统，该系统可以提供原始码以及软件；
*    1984 年由Richard Stallman 提倡 GNU 计划，倡导自由软件(Free software)， 强调其软件可以『自由的取得、复制、修改与再发行』，并规范出 GPL 授权模式， 任何GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。
*    1991 年由芬兰人Linus Torvalds 开发出Linux 操作系统。简而言之，Linux 成功的地方主要在于：<u>Minix(Unix), GNU, Internet, POSIX 及虚拟团队的产生。</u>

### 总结

操作系统(Operation System)主要在管理与驱动硬件，因此必须要能够管理内存、管理装置、 负责行程管理以及系·    统呼叫等等。因此，只要能够让硬件准备妥当(Ready)的情况， 就是一个健全的操作系统了。

*    符合 Open source 理念的授权相当多，比较知名的如 Apache / BSD / GPL / MIT 等。
*    Linux 本身就是个最阳春的操作系统，其开发网站设立在 http://www.kernel.org，我们亦称 Linux 操作系统最底层的数据为『核心(Kernel)』。
*    从 Linux kernel 3.0 开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本 (MainLine) 为依据， 并提供长期支持版本 (longterm) 来加强某些功能的持续维护。
*    Linux distributions 的组成含有：『Linux Kernel + Free Software + Documentations(Tools) + 可完全安装的程序』所制成的一套完整的系统。
*    常见的 Linux distributions 分类有『商业、社群』分类法，或『RPM、DPKG』分类法
*    学习 Linux 最好从头由基础开始学习，找到一本适合自己的书籍，加强实作才能学会

# **计算机：辅助人脑的好工具**

## 计算机硬件的五大单元

关于计算机的硬件组成部分，其实你可以观察你的桌面计算机来分析一下，依外观来说这家伙主要可分为三部分，分别是：

*    输入单元：包括键盘、鼠标、卡片阅读机、扫描仪、手写板、触控屏幕等等一堆；
*    主机部分：这个就是系统单元，被主机机壳保护住了，里面含有一堆板子、CPU 与主存储器等；
*    输出单元：例如屏幕、打印机等等

整部主机的重点在于中央处理器 (Central Processing Unit, CPU)，CPU 为一个具有特定功能的芯片， 里头含有<u>微指令集</u>，如果你想要让主机进行什么特异的功能，就得要参考这颗 CPU 是否有相关内建的微指令集才可以。

综合上面所说的，我们会知道其实计算机是由几个单元所组成的，包括<u>输入单元、 输出单元、CPU 内部的控制单元、算数逻辑单元与主存储器五大部分</u>。

## 一切设计的起点： CPU 的架构

### **精简指令集 (Reduced Instruction Set Computer, RISC)**

这种 CPU 的设计中，<u>微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳； 但是若要做复杂的事情，就要由多个指令来完成</u>。

CPU 主要例如甲骨文 (Oracle) 公司的 SPARC 系列、 IBM 公司的 Power Architecture (包括 PowerPC) 系列、与安谋公司 (ARM Holdings) 的 ARM CPU 系列等。

目前世界上使用范围最广的 CPU 可能就是 ARM 这种架构

### **复杂指令集(Complex Instruction Set Computer, CISC)**

CISC 在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长， 但每条个别指令可以处理的工作较为丰富。

常见的 CISC 微指令集 CPU 主要有 AMD、Intel、VIA 等的 x86 架构的 CPU。

### 位

所谓的位指的是CPU 一次数据读取的最大量

64 位CPU 代表 CPU 一次可以读写 64bits这么多的数据，32 位 CPU 则是 CPU 一次只能读取 32 位的意思。 

因为 CPU 读取数据量有限制，因此能够从内存中读写的数据也就有所限制。

## 计算机上面常用的计算单位 (容量、速度等)

### **容量单位**

计算机对数据的判断主要依据有没有通电来记录信息，所以理论上对于每一个纪录单位而言，它只认识 0 与 1 而已。0/1 这个二进制的的单位我们称为 bit。

1 Byte = 8 bits

| 进位制 | Kilo | Mega  | Giga  | Tera  | Peta  | Exa   | Zetta |
| ------ | ---- | ----- | ----- | ----- | ----- | ----- | ----- |
| 二进制 | 1024 | 1024K | 1024M | 1024G | 1024T | 1024P | 1024E |
| 十进制 | 1000 | 1000K | 1000M | 1000G | 1000T | 1000P | 1000E |

### **速度单位**

CPU 的指令周期常使用 MHz 或者是 GHz 之类的单位，这个 Hz 其实就是秒分之一。

而在网络传输方面，由于网络使用的是 bit 为单位，因此网络常使用的单位为 Mbps 是 Mbits per second，亦即是每秒多少 Mbit。

## **个人计算机架构与相关设备组件**

### 南北桥

#### 北桥

负责链接速度较快的 CPU、主存储器与显示适配器界面等组件

不过由于北桥最重要的就是 CPU 与主存储器之间的桥接，<u>因此目前的主流架构中， 大多将北桥内存控制器整合到 CPU 封装当中了</u>。

#### 南桥

负责连接速度较慢的装置接口， 包括硬盘、USB、网络卡等等。

### 执行脑袋运算与判断的 CPU

目前(2015)主流的 CPU 都是双核以上的架构了！原本的单核心 CPU 仅有一个运算单元，所谓的多核心则是在一颗 CPU 封装当中嵌入了两个以上的运算核心， 简单的说，就是一个实体的 CPU 外壳中，含有两个以上的 CPU 单元就是了。

不同的微指令集会导致 CPU 工作效率的优劣。

频率就是 CPU 每秒钟可以进行的工作次数。 所以频率越高表示这颗 CPU 单位时间内可以作更多的事情。

#### **CPU** **的工作频率：外频与倍频**

因为所有的设备都得掉透过北桥来连结，因此每个设备的工作频率应该要相同。

但因为 CPU 的指令周期比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。

所谓的外频指的是 CPU 与外部组件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作效能的一个倍数， 两者相乘才是 CPU 的频率速度。

#### **32** **位与** **64** **位的** **CPU** **与总线『宽度』**

CPU 每次能够处理的数据量称为字组大小(word size)， 字组大小依据 CPU 的设计而有 32 位与 64 位。我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的。

#### **CPU** **等级**

由于 x86 架构的 CPU 在 Intel 的 Pentium 系列(1993 年)后就有不统一的脚位与设计，为了将不同种类的 CPU 规范等级，所以就有 i386,i586,i686 等名词出现了。

#### **超线程** **(Hyper-Threading, HT)**

在每一个 CPU 内部将重要的缓存器 (register) 分成两群， 而让程序分别使用这两群缓存器。也就是说，可以有两个程序『同时竞争 CPU 的运算单元』，而非透过操作系统的多任务切换。

### 内存

CPU 所使用的数据都是来自于主存储器(main memory)，不论是软件程序还是数据，都必须要读入主存储器后 CPU 才能利用。 个人计算机的主存储器主要组件为<u>动态随机存取内存</u>(Dynamic Random Access Memory, DRAM)， 随机存取内存只有在通电时才能记录与使用，断电后数据就消失了。因此我们也称这种 RAM 为挥发性内存。

DRAM 根据技术的更新又分好几代，而使用上较广泛的有所谓的 SDRAM 与 DDR SDRAM 两种。

新一代的 PC 大多使用 DDR 内存了。

DDR SDRAM 又依据技术的发展，有 DDR, DDR2, DDR3, DDR4 等等。

####  **多通道设计**

由于所有的数据都必须要存放在主存储器，所以主存储器的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达 64 位，为了要加大这个宽度，因此芯片组厂商就将两个主存储器汇整在一起，如果一支内存可达 64 位，两支内存就可以达到 128 位了，这就是双通道的设计理念。

#### **DRAM** **与** **SRAM**

最为我们所知的就是CPU 内的第二层高速缓存。 我们现在知道 CPU 的数据都是由主存储器提供，但 CPU 到主存储器之间还是得要透过内存控制器。

如果某些很常用的程序或数据可以放置到 CPU 内部的话，那么 CPU 数据的读取就不需要跑到主存储器重新读取了！

因为第二层快取(L2 cache)整合到 CPU 内部，因此这个 L2 内存的速度必须要 CPU 频率相同。 使用DRAM 是无法达到这个频率速度的，此时就需要静态随机存取内存(Static Random Access Memory,SRAM)的帮忙了。 SRAM 在设计上使用的晶体管数量较多，价格较高，且不易做成大容量，不过由于其速度快， 因此整合到 CPU 内成为高速缓存以加快数据的存取是个不错的方式。

#### 只读存储器(ROM)

BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器(Read Only Memory, ROM)。

ROM 是一种非挥发性的内存。另外，BIOS 对于个人计算机来说是非常重要的， 因为他是系统在开机的时候首先会去读取的一个小程序。

BIOS 对计算机系统来讲是非常重要的，因为他掌握了系统硬件的详细信息与开机设备的选择等等。但是计算机发展的速度太快了， 因此 BIOS 程序代码也可能需要作适度的修改才行，所以你才会在很多主板官网找到 BIOS 的更新程序啊！但是 BIOS 原本使用的是无法改写的 ROM ，因此根本无法修正 BIOS 程序代码！为此，现在的 BIOS 通常是写入类似闪存 (flash) 或 EEPROM中。

### 显示适配器

显示适配器又称为 VGA(Video Graphics Array)，他对于图形影像的显示扮演相当关键的角色。

一般对于图形影像的显示重点在于分辨率与颜色深度，因为每个图像显示的颜色会占用掉内存， 因此显示适配器上面会有一个内存的容量，这个显示适配器内存容量将会影响到你的屏幕分辨率与颜色深度。

| 规格         | 宽度     | 速度     | 带宽          |
| ------------ | -------- | -------- | ------------- |
| PCI          | 32  bits | 33  MHz  | 133  MBytes/s |
| PCI  2.2     | 64  bits | 66  MHz  | 533  MBytes/s |
| PCI-X        | 64  bits | 133 MHz  | 1064 MBytes/s |
| AGP  4x      | 32  bits | 66x4 MHz | 1066 MBytes/s |
| AGP  8x      | 32  bits | 66x8 MHz | 2133 MBytes/s |
| PCIe 1.0 x1  | 无       | 无       | 250  MBytes/s |
| PCIe 1.0 x8  | 无       | 无       | 2  GBytes/s   |
| PCIe 1.0 x16 | 无       | 无       | 4  GBytes/s   |

#### 接口

*    D-Sub (VGA 端子)：为较早之前的连接接口，主要为 15 针的连接，为模拟讯号的传输，当初设计是针对传统映像管屏幕而来。 主要的规格有标准的 640x350px @70Hz、1280x1024px @85Hz 及 2048x1536px @85Hz 等。
*    DVI：共有四种以上的接头，不过台湾市面上比较常见的为仅提供数字讯号的 DVI-D，以及整合数字与模拟讯号的 DVI-I 两种。DVI 常见于液晶屏幕的链接， 标准规格主要有： 1920x1200px @60Hz、2560x1600px @60Hz 等。
*    HDMI：相对于 D-sub 与 DVI 仅能传送影像数据，HDMI 可以同时传送影像与声音，因此被广泛的使用于电视屏幕中！计算机屏幕目前也经常都有支持 HDMI 格式！
*    Display port：与 HDMI 相似的，可以同时传输声音与影像。不过这种界面目前在台湾还是比较少屏幕的支持！

### 硬盘与储存设备

计算机系统上面的储存设备包括有：硬盘、软盘、MO、CD、DVD、磁带机、随身碟(闪存)、还有新一代的蓝光光驱等， 乃至于大型机器的局域网络储存设备(SAN, NAS)等等，都是可以用来储存数据的。

#### **硬盘的物理组成**

在硬盘盒里面其实是由许许多多的圆形磁盘盘、机械手臂、 磁盘读取头与主轴马达所组成的

实际的数据都是写在具有磁性物质的磁盘盘上头，而读写主要是透过在机械手臂上的读取头(head)来达成。实际运作时， 主轴马达让磁盘盘转动，然后机械手臂可伸展让读取头在磁盘盘上头进行读写的动作。

#### **磁盘盘上的数据**

由于磁盘盘是圆的，并且透过机器手臂去读写数据，磁盘盘要转动才能够让机器手臂读写。因此，通常数据写入当然就是以圆圈转圈的方式读写

当初设计就是在类似磁盘盘同心圆上面切出一个一个的小区块，这些小区块整合成一个圆形，让机器手臂上的读写头去存取。 这个小区块就是磁盘的最小物理储存单位，称之为<u>扇区</u> (sector)，那同一个同心圆的扇区组合成的圆就是所谓的<u>磁道(track)</u>。 由于磁盘里面可能会有多个磁盘盘，因此在所有磁盘盘上面的同一个磁道可以组合成所谓的<u>磁柱 (cylinder)</u>。

#### **传输界面**

传统磁盘界面包括有 SATA, SAS, IDE 与 SCSI 等等。 若考虑外接式磁盘，那就还包括了 USB, eSATA 等等界面。不过目前 IDE 已经被 SATA 取代，而 SCSI 则被 SAS 取代。

##### **SATA** **界面**

插槽所使用的<u>扁平电缆</u>比较窄小， 而且每个装置需要使用掉一条 SATA 线。因为 SATA 线比较窄小之故，所以对于安装与机壳内的通风都比较好。

| 版本     | 带宽 (Gbit/s) | 速度 (Mbyte/s) |
| -------- | ------------- | -------------- |
| SATA 1.0 | 1.5           | 150            |
| SATA 2.0 | 3             | 300            |
| SATA 3.0 | 6             | 600            |

##### **SAS** **界面**

接口的速度确实比较快。而且还支持例如热拔插等功能，因此，许多的装置连接会以这种接口来链接。

| 版本   | 带宽 (Gbit/s) | 速度 (Mbyte/s) |
| ------ | ------------- | -------------- |
| SAS  1 | 3             | 300            |
| SAS  2 | 6             | 600            |
| SAS 3  | 12            | 1200           |

##### **USB** **界面**

| 版本     | 带宽 (Mbit/s) | 速度 (Mbyte/s) |
| -------- | ------------- | -------------- |
| USB  1.0 | 12            | 1.5            |
| USB  2.0 | 480           | 60             |
| USB  3.0 | 5G            | 500            |
| USB  3.1 | 10G           | 1000           |

##### **固态硬盘** **(Solid State Disk, SSD)**

固态硬盘最大的好处是，它没有马达不需要转动，而是透过内存直接读写的特性，因此除了没数据延迟且快速之外，还很省电。

每秒读写操作次数 (Input/Output Operations Per Second, IOPS)

### 扩充卡与界面

主板上面通常会预留多个扩充界面的插槽， 这些插槽依据历史沿革，包括 PCI/AGP/PCI-X/PCIe 等等

由于 PCIe速度快到太好用了，因此几乎所有的卡都以 PCIe 来设计

### 主板

#### **发挥扩充卡效能须考虑的插槽位置**

卡插在哪个插槽上面效能最好，卡安装在哪个插槽上面，对效能而言也是影响很大

#### **设备** **I/O** **地址与** **IRQ** **中断信道**

一般来说，不能有两个装置使用同一个 I/O 地址， 否则系统就会不晓得该如何运作这两个装置了。而除了 I/O 地址之外，还有个IRQ 中断(Interrupt)。

各装置可以透过 IRQ 中断信道来告知 CPU 该装置的工作情况，以方便 CPU 进行工作分配的任务。

#### **CMOS** **与** **BIOS**

##### CMOS

CMOS 主要的功能为记录主板上面的重要参数， 包括系统时间、CPU 电压与频率、各项设备的 I/O 地址与 IRQ 等，由于这些数据的记录要花费电力，因此主板上面才有电池。

##### BIOS

BIOS 为写入到主板上某一块 flash 或EEPROM 的程序，他可以在开机的时候执行，以加载 CMOS 当中的参数， 并尝试呼叫储存装置中的开机程序，进一步进入操作系统当中。

#### **连接接口设备的接口**

*    PS/2 界面：这原本是常见的键盘与鼠标的接口，不过目前渐渐被 USB 接口取代，甚至较新的主板可能就不再提供 PS/2 界面了；
*    USB 界面：通常只剩下 USB 2.0 与 USB 3.0，为了方便区分，USB 3.0 为蓝色的插槽颜色喔！
*    声音输出、输入与麦克风：这个是一些圆形的插孔，而必须你的主板上面有内建音效芯片时，才会有这三个东西；
*    RJ-45 网络头：如果有内建网络芯片的话，那么就会有这种接头出现。 这种接头有点类似电话接头，不过内部有八蕊线。接上网络线后在这个接头上会有灯号亮起。
*    HDMI：如果有内建显示芯片的话，可能就会提供这个与屏幕连接的界面。这种接口可以同时传输声音与影像， 目前也是电视机屏幕的主流连接接口。

### 电源供应器

因为 Power 的用料不同，电源供应的稳定度也会差很多。

#### **能源转换率**

电源供应器出厂前会有一些测试数据，最好挑选高转换率的电源供应器。 所谓的高转换率指的是『输出的功率/输入的功率』。

## 数字系统

所谓的十进制指的是逢十进一位， 因此在个位数归为零而十位数写成 1。所以所谓的二进制，就是逢二就前进一位的意思。

### 文字编码系统

当我们要写入文件的文字数据时，该文字数据会由编码对照表将该文字转成数字后，再存入文件当中。同样的，当我们要将文件内容的数据读出时，也会经过编码对照表将该数字转成对应的文字后，再显示到屏幕上。

常用的英文编码表为 ASCII 系统，这个编码系统中， 每个符号(英文、数字或符号等)都会占用 1bytes 的记录， 因此总共会有 28=256 种变化。

Unicode 编码系统， 我们常常称呼的UTF8 或万国码的编码

### **软件程序运作**

#### 机器程序与编译程序

计算机只认识 0 与 1 而已，而且计算机最重要的运算与逻辑判断是在 CPU 内部， 而CPU 其实是具有微指令集的。因此，我们需要 CPU 帮忙工作时，就得要参考微指令集的内容， 然后撰写让 CPU 读的懂的脚本给 CPU 执行，这样就能够让 CPU 运作了。

*    需要了解机器语言：机器只认识 0 与 1，因此你必须要学习直接写给机器看的语言！ 这个地方相当的难呢！
*    需要了解所有硬件的相关功能函数：因为你的程序必须要写给机器看， 当然你就得要参考机器本身的功能， 然后针对该功能去撰写程序代码。例如，你要让 DVD 影片能够放映， 那就得要参考 DVD 光驱的硬件信息才行。万一你的系统有比较冷门的硬件，光是参考技术手册可能会昏倒～
*    程序不具有可移植性：每个 CPU 都有独特的微指令集，同样的，每个硬件都有其功能函数。 因此，你为 A 计算机写的程序，理论上是没有办法在 B 计算机上面运作的！而且程序代码的修改非常困难！ 因为是机器码，并不是人类看的懂得程序语言啊！
*    程序具有专一性：因为这样的程序必须要针对硬件功能函数来撰写， 如果已经开发了一支浏览器程序，想要再开发文件管理程序时，还是得从头再参考硬件的功能函数来继续撰写。

### 机器程序与编译程序

#### 操作系统

在早期想要让计算机执行程序就得要参考一堆硬件功能函数，并且学习机器语言才能够撰写程序。 同时每次写程序时都必须要重新改写，因为硬件与软件功能不见得都一致之故。那如果我能够将所有的硬件都驱动， 并且提供一个发展软件的参考接口来给工程师开发软件的话，那发展软件不就变的非常的简单了？那就是操作系统啦！

##### **操作系统核心**(Kernel)

操作系统(Operating System, OS)其实也是一组程序， 这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。

核心主要在管控硬件与提供相关的能力(例如存取硬盘、网络功能、CPU 资源取得等)， 这些管理的动作是非常的重要的，如果使用者能够直接使用到核心的话，万一用户不小心将核心程序停止或破坏， 将会导致整个系统的崩溃！

<u>核心程序所放置到内存当中的区块是受保护的</u>！ 并且开机后就一直常驻在内存当中。

##### **系统呼叫(System Call)**

计算机系统主要由硬件构成，然后核心程序主要在管理硬件，提供合理的计算机系统资源分配(包括

CPU 资源、内存使用资源等等)， 因此只要硬件不同(如 x86 架构与RISC 架构的 CPU)，核心就得要进行修改才行。

为了保护核心，并且让程序设计师比较容易开发软件，因此操作系统除了核心程序之外，通常还会提供一整组开发接口，那就是<u>系统呼叫层</u>。

*    操作系统的核心层直接参考硬件规格写成， 所以同一个操作系统程序不能够在不一样的硬件架构下运作。
*    操作系统只是在管理整个硬件资源，包括 CPU、内存、输入输出装置及文件系统文件。 
*    <u>应用程序的开发都是参考操作系统提供的开发接口， 所以该应用程序只能在该操作系统上面运作而已，不可以在其他操作系统上面运作的。</u>

##### **核心功能**

*    系统呼叫接口(System call interface)

*    程序管理(Process control).

*    内存管理(Memory management)

     系统所有的程序代码与数据都必须要先存放在内存当中。

*    文件系统管理(Filesystem management)

*    装置的驱动(Device drivers)

### **操作系统与驱动程序**

那操作系统该如何驱动这块新的显示适配器？为了克服这个问题，操作系统通常会提供一个开发接口给硬件开发商，让他们可以根据这个接口设计可以驱动他们硬件的『驱动程序』， 如此一来，只要使用者安装驱动程序后，自然就可以在他们的操作系统上面驱动这块显示适配器了。

*    操作系统必须要能够驱动硬件，如此应用程序才能够使用该硬件功能；
*    一般来说，操作系统会提供开发接口，让开发商制作他们的驱动程序；
*    要使用新硬件功能，必须要安装厂商提供的驱动程序才行；
*    驱动程序是由厂商提供的，与操作系统开发者无关。

### 应用程序

应用程序是参考操作系统提供的开发接口所开发出来<u>软件</u>，这些软件可以让用户操作，以达到某些计算机的功能利用。

## 总结

*    计算器的定义为：『接受用户输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的信息』；
*    计算机的五大单元包括：输入单元、输出单元、控制单元、算数逻辑单元、记忆单元五大部分。其中CPU占有控制、算术逻辑单元，记忆单元又包含主存储器与辅助内存；
*    数据会流进/流出内存是 CPU 所发布的控制命令，而CPU 实际要处理的数据则完全来自于主存储器；
*    CPU 依设计理念主要分为：精简指令集(RISC)与复杂指令集(CISC)系统；
*    关于CPU 的频率部分：外频指的是CPU 与外部组件进行数据传输时的速度，倍频则是CPU 内部用来加速工作效能的一个倍数， 两者相乘才是 CPU 的频率速度；
*    新的 CPU 设计中，已经将北桥的内存控制芯片整合到 CPU 内，而 CPU 与主存储器、显示适配器沟通的总线通常称为系统总线。 南桥就是所谓的输入输出(I/O)总线，主要在联系硬盘、USB、网络卡等接口设备；
*    CPU 每次能够处理的数据量称为字组大小(word size)，字组大小依据 CPU 的设计而有 32 位与 64 位。 我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的！
*    个人计算机的主存储器主要组件为动态随机存取内存(Dynamic Random Access Memory, DRAM)， 至于 CPU内部的第二层快取则使用静态随机存取内存(Static Random Access Memory, SRAM)；
*    BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器(Read Only Memory, ROM)；
*    目前主流的外接卡界面大多为 PCIe 界面，且最新为 PCIe 3.0，单信道速度高达 1GBytes/s
*    常见的显示适配器连接到屏幕的界面有 HDMI/DVI/D-Sub/Display port 等等。HDMI 可同时传送影像与声音。·    传统硬盘的组成为：圆形磁盘盘、机械手臂、 磁盘读取头与主轴马达所组成的，其中磁盘盘的组成为扇区、磁道与磁柱；
*    磁盘连接到主板的界面大多为 SATA 或 SAS，目前桌机主流为 SATA 3.0，理论极速可达 600Mbytes/s。
*    常见的文字编码为 ASCII，繁体中文编码主要有 Big5 及 UTF8 两种，目前主流为 UTF8
*    操作系统(Operating System, OS)其实也是一组程序， 这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。
*    计算机主要以二进制作为单位，常用的磁盘容量单位为 bytes，其单位换算为 1 Byte = 8bits。
*    操作系统仅在驱动与管理硬件，而要使用硬件时，就得需要透过应用软件或者是壳程序(shell)的功能， 来呼叫操作系统操纵硬件工作。目前称为操作系统的，除了上述功能外，通常已经包含了日常工作所需要的应用软件在内了。

# **主机规划与磁盘分区**

## **Linux 与硬件的搭配**

### 认识计算机的硬件配备

计算机主机的硬件配备与这部主机未来的功能是很有相关性的

因此目前硬件评论界有所谓的『每瓦效能』的单位， 每瓦电力所发挥的效能越高，当然代表越省电

并非所有的产品都会支持特定的操作系统，这牵涉到硬件开发商是否有意愿提供适当的驱动程序之故。因此，当我们想要购买或者是升级某些计算机组件时，应该要特别注意该硬件是否有针对您的操作系统提供适当的驱动程序， 否则，买了无法使用

### 选择与Linux 搭配的主机配备

较早期的硬件配备也可能由于保存的问题或者是电子零件老化的问题， 导致这样的计算机系统反而非常容易在运作过程中出现不明的当机情况

*    CPU

CPU 只要不是老旧到会让你的硬件系统当机的都能够支持

*    RAM

主存储器是越大越好！事实上在 Linux 服务器中，主存储器的重要性比 CPU 还要高的多！因为如果主存储器不够大， 就会使用到硬盘的内存置换空间(swap)。 而由计算器概论的内容我们知道硬盘比内存的速度要慢的多， 所以主存储器太小可能会影响到整体系统的效能的！

*    Hard Disk

由于数据量与数据存取频率的不同，对于硬盘的要求也不相同。

>    磁盘阵列(RAID)是利用硬件技术将数个硬盘整合成为一个大硬盘的方法，操作系统只会看到最后被整合起来的大硬盘。 由于磁盘阵列是由多个硬盘组成，所以可以达成速度效能、备份等任务。

*    VGA

对于不需要X Window 的服务器来说，显示适配器算是最不重要的一个组件了！你只要有显示适配器能够让计算机启动，那就够了。 但如果需要 X window 系统时，你的显示适配器最好能够拥有 32MB 以上的内存容量。

*    Network Interface Card

网络卡是服务器上面最重要的组件之一了！目前的主板大多拥有内建 10/100/1000Mbps 的超高速以太网络卡。但要注意的是，不同的网络卡的功能还是有点差异。

*    光盘、软盘、键盘与鼠标

### 各硬件装置在 Linux 中的文件名

『在 Linux 系统中，每个装置都被当成一个文件来对待』

在 Linux 这个系统当中，几乎所有的硬件装置文件都在/dev 这个目录内

| 装置                 | 装置在 Linux 内的文件名                                      |
| -------------------- | ------------------------------------------------------------ |
| SCSI/SATA/USB 硬盘机 | /dev/sd[a-p]                                                 |
| USB 快闪碟           | /dev/sd[a-p] (与 SATA 相同)                                  |
| VirtI/O 界面         | /dev/vd[a-p] (用于虚拟机内)                                  |
| 软盘驱动器           | /dev/fd[0-7]                                                 |
| 打印机               | /dev/lp[0-2] (25 针打印机)  /dev/usb/lp[0-15] (USB 界面)     |
| 鼠标                 | /dev/input/mouse[0-15] (通用)  /dev/psaux (PS/2 界面) /dev/mouse (当前鼠标) |
| CDROM/DVDROM         | /dev/scd[0-1] (通用)  /dev/sr[0-1] (通用，CentOS 较常见)  /dev/cdrom (当前 CDROM) |
| 磁带机               | /dev/ht0 (IDE 界面)  /dev/st0 (SATA/SCSI 界面)  /dev/tape (当前磁带) |
| IDE 硬盘机           | /dev/hd[a-d] (旧式系统才有)                                  |

## **磁盘分区**

### 磁盘连接的方式与装置文件名的关系

个人计算机常见的磁盘接口有两种，分别是SATA 与SAS 接口， 目前的主流是 SATA 接口。

正常的实体机器大概使用的都是 /dev/sd[a-] 的磁盘文件名，至于虚拟机环境底下，为了加速，可能就会使用 /dev/vd[a-p] 这种装置文件名

再以 SATA 接口来说，由于 SATA/USB/SAS 等磁盘接口都是使用 SCSI 模块来驱动的， 因此这些接口的磁盘装置文件名都是/dev/sd[a-p]的格式。 所以 SATA/USB 接口的磁盘根本就没有一定的顺序

>    例题：
>
>    如果你的 PC 上面有两个 SATA 磁盘以及一个 USB 磁盘，而主板上面有六个 SATA 的插槽。这两个 SATA 磁盘分别安插在主板上的 SATA1, SATA5 插槽上， 请问这三个磁盘在 Linux 中的装置文件名为何？
>
>    答：
>
>    由于是使用侦测到的顺序来决定装置文件名，并非与实际插槽代号有关，因此装置的文件名如下：
>
>    \1.  SATA1 插槽上的檔名：/dev/sda
>
>    \2.  SATA5 插槽上的檔名：/dev/sdb
>
>    \3.   USB 磁盘(开机完成后才被系统捉到)：/dev/sdc

磁盘的组成主要有磁盘盘、机械手臂、磁盘读取头与主轴马达所组成， 而数据的写入其实是在磁盘盘上面。磁盘盘上面又可细分出扇区(Sector)与磁道(Track)两种单位， 其中扇区的物理量设计有两种大小，分别是 512bytes 与 4Kbytes。

### MSDOS(MBR) 与 GPT 磁盘分区表(partition table)

通常磁盘可能有多个磁盘盘，所有磁盘盘的同一个磁道我们称为磁柱 (Cylinder)， 通常那是文件系统的最小单位，也就是分区槽的最小单位

#### **MSDOS (MBR)** **分区表格式与限制**

 早期的 Linux 系统为了兼容于 Windows 的磁盘，因此使用的是支持 Windows 的 <u>MBR</u>(Master Boot Record, 主要开机纪录区) 的方式来处理开机管理程序与分区表

*    主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有 446 bytes
*    分区表(partition table)：记录整颗硬盘分区的状态，有 64 bytes由于分区表所在区块仅有 64 bytes 容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码。 

当你的操作系统为Windows 时，那么第一到第四个分区槽的代号应该就是 C, D, E, F。当你有资料要写入 F 槽时， 你的数据会被写入这颗磁盘的 301~400 号磁柱之间的意思。

*    其实所谓的『分区』只是针对那个 64 bytes 的分区表进行设定而已！
*    硬盘默认的分区表仅能写入四组分区信息
*    这四组分区信息我们称为主要(Primary)或延伸(Extended)分区槽
*    分区槽的最小单位『通常』为磁柱(cylinder)
*    当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区槽进行数据的处理

##### 分区原因

*    数据的安全性

因为每个分区槽的数据是分开的！所以，当你需要将某个分区槽的数据重整时，例如你要将计算机中Windows 的C 槽重新安装一次系统时， 可以将其他重要数据移动到其他分区槽，例如将邮件、桌面数据移动到D 槽去，那么 C 槽重灌系统并不会影响到 D 槽！ 所以善用分区槽，可以让妳的数据更安全。

*    系统的效能考虑

由于分区槽将数据集中在某个磁柱的区段，例如上图当中第一个分区槽位于磁柱号码 1~100 号，如此一来当有数据要读取自该分区槽时， 磁盘只会搜寻前面 1~100 的磁柱范围，由于数据集中了，将有助于数据读取的速度与效能！所以说，分区是很重要的！

延伸分区的目的是使用额外的扇区来记录分区信息，延伸分区本身并不能被拿来格式化。

##### MBR 主要分区、延伸分区与逻辑分区的特性：

*    主要分区与延伸分区最多可以有四笔(硬盘的限制)
*    延伸分区最多只能有一个(操作系统的限制)
*    逻辑分区是由延伸分区持续切割出来的分区槽；
*    能够被格式化后，作为数据存取的分区槽为主要分区与逻辑分区。延伸分区无法格式化；
*    逻辑分区的数量依操作系统而不同，在 Linux 系统中 SATA 硬盘已经可以突破 63 个以上的分区限制；

#### **GUID partition table, GPT 磁盘分区表**

*    LBA0 (MBR 相容区块)

与 MBR 模式相似的，这个兼容区块也分为两个部份，一个就是跟之前 446 bytes 相似的区块，储存了第一阶段的开机管理程序！ 而在原本的分区表的纪录区内，这个兼容模式仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式之意。

*    LBA1 (GPT 表头纪录)

这个部份纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区 (就是前面谈到的在最后 34 个 LBA 区块) 放置的位置， 同时放置了分区表的检验机制码 (CRC32)，操作系统可以根据这个检验码来判断 GPT 是否正确。若有错误，还可以透过这个纪录区来取得备份的 GPT(磁盘最后的那个备份区块) 来恢复 GPT 的正常运作！

*    LBA2-33 (实际纪录分区信息处)

从 LBA2 区块开始，每个 LBA 都可以纪录 4 笔分区纪录，所以在默认的情况下，总共可以有 4*32 = 128 笔分区纪录喔！因为每个 LBA 有 512bytes，因此每笔纪录用到 128 bytes 的空间，除了每笔纪录所需要的标识符与相关的纪录之外，GPT 在每笔纪录中分别提供了 64bits 来记载开始/结束的扇区号码，因此，GPT 分区表对于单一分区槽来说， 他的最大容量限制就会在『 264 * 512bytes = 263 * 1Kbytes = 233*TB = 8 ZB 』，要注意 1ZB = 230TB 啦！ 

### 开机流程中的 BIOS 与 UEFI 开机检测程序

#### **BIOS** **搭配** **MBR/GPT** **的开机流程**

<u>CMOS</u> 是记录各项硬件参数且嵌入在主板上面的储存器，<u>BIOS</u> 则是一个写入到主板上的一个韧体(再次说明， 韧体就是写入到硬件上的一个软件程序)。

<u>这个 BIOS 就是在开机的时候，计算机系统会主动执行的第一个程序了！</u>

BIOS 会去分析计算机里面有哪些储存设备，我们以硬盘为例，BIOS 会依据使用者的设定去取得能够开机的硬盘， 并且到该硬盘里面去读取第一个扇区的 MBR 位置。MBR 这个仅有 446 bytes 的硬盘容量里面会放置最基本的开机管理程序， 此时 BIOS 就功成圆满，而接下来就是 MBR 内的开机管理程序的工作了。

流程

*    BIOS**：开机主动执行的韧体，会认识第一个可开机的装置；**
*    MBR**：第一个可开机装置的第一个扇区内的主要启动记录区块，内含开机管理程序；**
*    开机管理程序(boot loader)**：一支可读取核心文件来执行的软件；**
     *    提供选单**：用户可以选择不同的开机项目，这也是多重引导的重要功能！**
     *    载入核心文件**：直接指向可开机的程序区段来开始操作系统；**
     *    转交其他 **loader**：将开机管理功能转交给其他 loader 负责。
          *    开机管理程序除了可以安装在 MBR 之外， 还可以安装在每个分区槽的启动扇区(boot sector)
          *    每个分区槽都拥有自己的启动扇区(boot sector)
          *    图中的系统槽为第一及第二分区槽，
          *    实际可开机的核心文件是放置到各分区槽内的！
          *    loader 只会认识自己的系统槽内的可开机核心文件，以及其他 loader 而已；loader 可直接指向或者是间接将管理权转交给另一个管理程序
*    核心文件：开始操作系统的功能...

#### **UEFI BIOS** **搭配** **GPT** **开机的流程**

UEFI (Unified Extensible Firmware Interface) 这个统一可延伸韧体界面

UEFI 使用 C 程序语言，比起使用汇编语言的传统 BIOS 要更容易开发



#### 传统 BIOS 与 UEFI 的差异

| 比较项目               | 传统 BIOS                                                  | UEFI               |
| ---------------------- | ---------------------------------------------------------- | ------------------ |
| 使用程序语言           | 汇编语言                                                   | C  语言            |
| 硬件资源控制           | 使用中断 (IRQ) 管理不可变的内存存取  不可变得输入/输出存取 | 使用驱动程序与协议 |
| 处理器运作环境         | 16  位                                                     | CPU  保护模式      |
| 扩充方式               | 透过 IRQ 连结                                              | 直接加载驱动程序   |
| 第三方厂商支持         | 较差                                                       | 较佳且可支持多平台 |
| 图形化能力             | 较差                                                       | 较佳               |
| 内建简化操作系统前环境 | 不支援                                                     | 支援               |

与 BIOS 模式相比，虽然 UEFI 可以直接取得 GPT 的分区表，不过最好依旧拥有 BIOS boot 的分区槽支持， 同时，为了与 windows 兼容，并且提供其他第三方厂商所使用的 UEFI 应用程序储存的空间，你必须要格式化一个 vfat 的文件系统， 大约提供 512MB 到 1G 左右的容量，以让其他 UEFI 执行较为方便。

### Linux 安装模式下，磁盘分区的选择(极重要)

#### **目录树结构** **(directory tree)**

整个 Linux 系统最重要的地方就是在于目录树架构。 所谓的目录树架构(directory tree)就是以根目录为主，然后向下呈现分支状的目录结构的一种文件架构。 

所以，整个目录树架构最重要的就是那个根目录(root directory)，这个根目录的表示方法为一条斜线『**/**』， 所有的文件都与目录树有关。

所有的文件都是由根目录(/)衍生来的，而次目录之下还能够有其他的数据存在。

#### 文件系统与目录树的关系(挂载)

所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下； 也就是说， 进入该目录就可以读取该分区槽的意思。

这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。

#### **distributions** **安装时，挂载点与磁盘分区的规划**

**强烈建议使用『自定义安装, Custom 』这个安装模式**

*    自定义安装『Custom』
*    建议分区的方法：预留一个备用的剩余磁盘容量

**选择 Linux 安装程序提供的默认硬盘分区方式**

## 主机的服务规划与硬件的关系

### **打造** **Windows** **与** **Linux** **共存的环境**

开机流程与多重引导

### NAT(达成IP分享器的功能)

通常小型企业或者是学校单位大多仅会有一条对外的联机，然后全公司/学校内的计算机全部透过这条联机连到因特网上。

### SAMBA加入Windows网络上的芳邻)

我们可以使用 Linux 上面的 SAMBA 这个软件来达成加入 Windows 网芳的功能。

SAMBA 的效能不错， 也没有客户端联机数的限制，相当适合于一般学校环境的文件服务器(file server)的角色。

这种服务器由于分享的数据量较大，对于系统的网络卡与硬盘的大小及速度就比较重要， 如果你还针对不同的用户提供文件服务器功能，那么/home 这个目录可以考虑独立出来，并且加大容量。

### Mail邮件服务器

在 mail server 上面，重要的也是硬盘容量与网络卡速度，在此情境中，也可以将/var 目录独立出来，并加大容量。

### **Web(WWW 服务器)**

WWW 服务器几乎是所有的网络主机都会安装的一个功能，因为他除了可以提供 Internet 的 WWW 联机之外， 很多在网络主机上面的软件功能(例如某些分析软件所提供的最终分析结果的画面)也都使用 WWW 作为显示的接口。

### **DHCP(提供客户端自动取得 IP 的功能)**

客户端计算机只要选择『自动取得 IP』，其他的，就是你系统管理员在 DHCP 服务器上面设定一下即可。

### **FTP**

对于 FTP 的硬件需求来说，硬盘容量与网络卡好坏相关性较高。

## 主机硬盘的主要规划

所谓的『数据安全』并不是指数据被网络cracker 所破坏， 而是指『当主机系统的硬件出现问题时，你的文件数据能否安全的保存』之意。

硬盘的分区技巧需要对于 Linux 文件结构有相当程度的认知之后才能够做比较完善的规划

*    最简单的分区方法

仅分区出根目录与内存置换空间( / & swap )即可。

*    稍微麻烦一点的方式

先分析这部主机的未来用途，然后根据用途去分析需要较大容量的目录， 以及读写较为频繁的目录，将这些重要的目录分别独立出来而不与根目录放在一起， 那当这些读写较频繁的磁盘分区槽有问题时，至少不会影响到根目录的系统数据

在默认的CentOS 环境中，底下的目录是比较符合容量大且(或)读写频繁的目录啰：

*    boot
*    /
*    /home
*    /var
*    Swap

## 总结

*    新添购计算机硬件配备时，需要考虑的角度有『游戏机/工作机』、『效能/价格比』、『效能/消耗瓦数』、『支持度』等；
*    旧的硬件配备可能由于保存的问题或者是电子零件老化的问题，导致计算机系统非常容易在运作过程中出现不明的当机情况
*    Red Hat 的硬件支持
*    在 Linux 系统中，每个装置都被当成一个文件来对待，每个装置都会有装置文件名。
*    磁盘装置文件名通常分为两种，实际 SATA/USB 装置文件名为/dev/sd[a-p]，而虚拟机的装置可能为/dev/vd[a-p]

*    磁盘的第一个扇区主要记录了两个重要的信息，分别是： (1)主要启动记录区(Master Boot Record, MBR)： 可以安装开机管理程序的地方，有 446 bytes (1)分区表(partition table)：记录整颗硬盘分区的状态，有 64 bytes；
*    磁盘的 MBR 分区方式中，主要与延伸分区最多可以有四个，逻辑分区的装置文件名号码，一定由 5 号开始；
*    如果磁盘容量大于 2TB 以上时，系统会自动使用 GPT 分区方式来处理磁盘分区。
*    GPT 分区已经没有延伸与逻辑分区槽的概念，你可以想象成所有的分区都是主分区！
*    某些操作系统要使用 GPT 分区时，必须要搭配 UEFI 的新型 BIOS 格式才可安装使用。
*    开机的流程由：BIOS-->MBR-->-->boot loader-->核心文件；
*    boot loader 的功能主要有：提供选单、加载核心、转交控制权给其他 loader
*    boot loader 可以安装的地点有两个，分别是 MBR 与 boot sector
*    Linux 操作系统的文件使用目录树系统，与磁盘的对应需要有『挂载』的动作才行；
*    新手的简单分区，建议只要有/及 swap 两个分区槽即可

# Ubuntu Linux

## 部署系统

* 默认安装

* 桌面->设置分辨率

* 设置VMware tools
  * 虚拟机->设置->CD/DVD ISO映像文件 选择 Linux.ico

  * 压缩包复制到桌面,解压

  * 以terminal打开文件,输入

    ```
    sudo ./vmware-install.pl
    ```

  * 随后默认回车进行安装

* 设置共享文件夹

  * 虚拟机->设置->选项->共享文件夹->总是启用->设置共享文件夹路径
  * 资源管理器->other location->computer->mnt文件夹便是共享文件夹

## 安装、卸载软件

```
apt-get install <软件包名称>
apt-get uninstall <软件包名称>
```

## 配置系统服务

在 Ubuntu 下配置系统服务非常简单，只需一个名为 sysv-rc-conf 的软件包。 使用 sudo apt-get install sysv-rc-conf 命令安装软件包。安装完毕后在 shell 终端输入 sudo sysv-rc-conf, 出现一个文本界面。其中最左边是系统的服务名称，右边依次是系统运行级别1~6。每个系统服务在对应的系统级别下都可以选择 X，表示在该级别下启动， 去掉 X 表示不启动。

用户根据需要选择以后，输入字母q保存退出。

## 安装主要的开发工具

Ubuntu Linux 把主要的开发工具打包放在一起，安装的时候直接安装一个软件包就可以把基本的开发工具和程序都安装到系统内。

*    安装基本的开发工具

```
sudo apt-get install build-essential
```

*    检查开发工具是否安装成功

```
gcc -version//获取gcc版本信息
gdb -version//获取gdb版本信息
```

如果输出 gdb 的版本信息，证明 gdb 调试器已经安装成功。 GNU 的命令行程序几乎都有一个--version参数，使用这个参数可以输出程序的版本信息。

### 安装其他的开发工具和文档

```
sudo apt-get install autoconf automake //生成工程Makefile的工具
sudo apt-get install flex bison        //词法扫描分析工具
sudo apt-get install manpages-dev      //C语言函数用户手册
sudo apt-get install binutils-doc cpp-doc gcc-doc glibc-doc stl-manual               //其他程序的用户手册
```

## Linux shell和常用命令

Linux的命令行是通过一种叫做shell 的程序提供的。shell程序负责接受用户的输入， 解析用户输入的命令 和参数， 调用相应的程序， 并给出结果和出错提示。

在Linux系统中，仅有内核还是不够的 ，需要应用程序支持才能发挥内核提供的功能。

| 命令  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| ls    | 列出指定目录的列表，包括文件和子目录。 默认是当前目录 -l 以列表方式查看 -a 显示隐含文件和目录 -h 以便于阅读的方式查看文件的大小 |
| ln    | 建立连接 -s 软连接 -f 连接是一个目录                         |
| df    | 查看磁盘空间 -h 以便于人阅读的方式查看文件的大小             |
| du    | 查看指定目录占用的空间。默认为当前目录。 -h 以便于人阅读的方式查看文件的大小 |
| pwd   | 显示当前工作目录的绝对路径                                   |
| chmod | 修改文件或目录的读写权限 -R 递归调用                         |
| chgrp | 修改文件或目录的用户组 -R 递归调用                           |
| chown | 修改文件或目录的所有者 -R 递归调用                           |
| date  | 查看日期                                                     |
| cat   | 输出文件内容到屏幕                                           |
| echo  | 回显一个字符串或者环境变量到屏幕                             |
| uname | 查看机器名称                                                 |
| ps    | 查看进程状态 -e 查看系统所有进程                             |
| kill  | 向指定进程发送信号 -9 强制杀死进程                           |

## root超级用户常用命令

Linux是一个支持多用户的系统， 自身有严格的权限机制。 在Linux系统中， 可以有多个用户， 每个用户都属于 个用户组。 系统只有 个用户 root 称为超级用户， 其拥有至高无上的权利， 可以修改系统的任何文件， 访问所有的资源。 除超级用户 root 外， 其他用户都是普通用户， 普通用户访问的资源是受到限制的， 与系统配置有关的文件和命令普通用户几乎都无法运行。 

| 命令     | 作用             |
| -------- | ---------------- |
| ifconfig | 查看和配置网卡   |
| fdisk    | 磁盘分区工具     |
| mkfs     | 磁盘格式化       |
| insmod   | 加载内核模块     |
| lsmod    | 内核模块列表     |
| modprobe | 内核模块管理工具 |
| reboot   | 重启机器         |
| halt     | 停机             |

## 文本编辑工具 vi

vi编辑器的功能十分强大， 并且体积非常小， 适合安装在嵌入式系统使用。 

vi编辑器支持编辑模式、 浏览模式、 插入模式和可视模式4种模式。浏览模式只能查看和删除文档内容， 但是不能修改： 编辑模式用户可以修改文档内容， 与普通的文本编辑器相同：覆盖模式下用户输入的内容会覆盖光标所在位置的文本： 可视模式提供了一种选择文本的方法， 可以使用键盘完成鼠标选择文本的功能。

| 指令 | 含义     |
| ---- | -------- |
| i    | 插入模式 |
| r    | 覆盖模式 |
| v    | 可视模式 |
| w    | 保存文件 |
| q    | 退出     |
| e    | 编辑文件 |

## 搜索工具find和grep

find用于查找文件，grep用于查找文件内容

### grep

grep 支持正则表达式（一种描述字符串特征的语法〉， 通过在一个或多个文件中搜索字符串， 符合的内容被送到屏幕显示。 grep 工具不会修改文件内容。 grep 通过返回值表示搜索状态， 如果出索成功后回0，如果失败返回1，如果搜索的文件不存在则返回2。

| 参数                      | 含义                                              |
| ------------------------- | ------------------------------------------------- |
| -?                        | 显示匹配行的上下各？行，？代表行数                |
| -b, --byte-offset         | 打印匹配行所在的块号码                            |
| -c, --count               | 只打印匹配的行数， 不显示匹配内容                 |
| -f File, --file=File      | 从文件中提取模板                                  |
| -h --no-filename          | 搜索多个文件时， 不显示匹配文件名前缀             |
| -i, --ignore-case         | 忽略英文字母大小写                                |
| -q, --quiet               | 不显示任何信息                                    |
| -l, --files-with-matches  | 打印匹配模板的文件清单                            |
| -L, --files-without-match | 打印不匹配模板的文件清单                          |
| -n, --line-number         | 输出匹配行的行号                                  |
| -s, --silent              | 不显示错误信息                                    |
| -v, --revert-match        | 只显示不匹配的行                                  |
| -w, --word-regexp         | 如果被＼＜和＼＞引用， 就把表达式作为一个单词搜索 |
| -V, --version             | 显示软件版本信息                                  |
| --help                    | 打印帮助信息                                      |

>    举例
>
>    1.   显示main.c文件中以#开头的行
>
>    ```
>    $grep '^#' main.c
>    ```
>
>    2.   显示fs子目录下包含5个字符长度的字符串所在的行
>
>    ```
>    $grep -Rn '\{5\}' fs/*
>    ```
>
>    3.   显示mm 子目录下包含 Kmalloc 或者 kmalloc 的行以及行号
>
>    ```
>    $grep -Rn '[Kk]malloc' mm/
>    ```

### find

在 Linux 系统下，文件的命名是没有固定格式的，仅从文件名上无法推断出文件类型。
因此， 需要指定文件的其他属性帮助用户查找文件， find 工具可以支持复杂的文件查找条件。

```
$ find --help
```

用法： find [-H] [-L] [-P] [-Olevel] [-D help |tree|search|stat|rates|opt|exec] [path...] [expression]

>    举例
>
>    1.    查找系统中apache的配置文件存放位置
>
>    ```
>    $ sudo find / -name 'apache2.conf'
>    ```
>
>    find 是一个所有用户都能使用的命令， 但是普通用户在使用的时候常会出现权限不够的提示， 原因是一些文件只有 root 用户可以访问。
>
>    错误重定向
>
>    ```
>    $ find / -name 'apache2.conf' x>/dev/null
>    ```
>
>    2.   指定查找文件大小或者时间
>
>    ```
>    $ sudo find / -size 10000c
>    ```

## 正则表达式

| 正则表达式符号 | 含义                     |
| -------------- | ------------------------ |
| ^              | 指定从一行的开头匹配。   |
| $              | 指定从一行的结尾匹配。   |
| *              | 匹配任意个数的字符。     |
| []             | 匹配指定范围内的字符。   |
| [^]            | 匹配指定范围以外的字符。 |
| \\(..\\)       | 标记匹配字符。           |
| x\\{m\\}       | 宇符x重复m次。           |
| x\\{m,n\\}     | 字符x至少重复m～n次      |
| \\w            | 匹配字数为w次的字符串。  |

## FTP工具

FTP是标准互联网文件传输协议，应用于网络文件传输，是不同机器间文件传输简单有效的方法。

FTP协议允许传输二进制和文本文件

连接到一个FTP服务器需要合法权限的用户名和密码。在Linux系统上，合法的登录用户就是FTP用户。

FTP命令的格式为“ftp 主机名 [端口号]”，端口号可选，默认的端口号是21。

```
$ ftp 192.168.2.106
```

### FTP工具常用命令

| 命令名称 | 含义                                                      |
| -------- | --------------------------------------------------------- |
| dir      | 列出服务器的目录                                          |
| cd       | 改变服务器上的目录                                        |
| lcd      | 改变本地目录                                              |
| ascii    | 使用文本方式传输文件                                      |
| binary   | 使用二进制方式传输文件                                    |
| bye      | 退出FTP工具                                               |
| hash     | 显示文件传输进度                                          |
| get      | 从服务器下载文件                                          |
| put      | 上传文件到服务器                                          |
| !        | 切换到shell对话框，在shell中使用exit命令可以退回FTP对话框 |

>    举例
>
>    从ftp:://oss.sig.com/www/projects/kdb/download/v4.4/上下载一个内核代码的补丁文件到当前目录
>
>    ```
>    $ ftp oss.sig.com
>    Name (oss.sgi.con:tom): anonymous
>    331 Any password will work
>    Password:
>    230 Any password will work
>    Remote system type is UNIX.
>    ftp>cd www
>    ftp>cd projects
>    ftp>cd kdb
>    ftp>cd download
>    ftp>cd v4.4
>    ftp>binary
>    200 TYPE is now 8-bit binary
>    ftp>hash
>    ftp>get kdb-v4.4-2.6.9-rc4-common-1.bz2
>    ftp>bye
>    ```

## 串口工具minicom

完成复杂的串口通信工作

### 安装

```
sudo apt-get install minicom
```

### 配置

在shell中输入

```
sudo minicom -s
```

用光标键移动高亮条到 Serial Port setup菜单项，按回车键后进入串口参数配置界面

串口配置界面列出了串口的配置， 每个配置前都有一个英文字母， 代表进入配置项的 快捷键。 

设置好串口设备后按回车键，保存参数并且回到提示界面。 输入小写字母e， 进入串口参数配置界面

串口参数界面可以配置串口波特率、数据位、停止位等信息。

### 退出

使用Ctrl+a键，输入字母z，出现minicom的命令菜单，输入大写字母q

## ARM集成开发工具ADS

集成开发环境Integrated development environment，简写IDE。

ARM开发有标准的开发环境ARM Development Studio，简称ADS

### C语言编译器armcc

该编译器支持ANSIC标准，可以编译并生成32位ARM指令。

armcc的基本语法如下

```
armcc [options] <file1> [file2] [file2] ...
```

可以一次编译多个文件，常见的参数如下所述

*    -c：只编译不连接。
*    -D：定义预编译宏。
*    -E：仅对代码做预处理。
*    -O：代码优化选项，共有3个优化级别，0表示不优化：1表示控制代码优化：2表示最大可能的优化。
*    -I：指定头文件目录。
*    -S：编译后生成汇编文件。

### C++语言编译器armcpp

该编译器支持ISO C++和EC++标准的代码，可以编译并生成32位ARM指令。armcpp的使用语法与armcc基本相同。

# Linux基本指令

## 基本命令

### 关机和重启

#### 关机

```
shutdown -h now        立刻关机
shutdown -h 5        5分钟后关机
poweroff         立刻关机
```

#### 重启

```
shutdown -r now        立刻重启
shutdown -r 5        5分钟后重启
reboot                立刻重启
```

#### 帮助命令

--help命令

```
shutdown --help：
ifconfig  --help：查看网卡信息
```

man命令（命令说明书） 

```
man shutdown
```


注意：man shutdown打开命令说明书之后，使用按键q退出

## 目录操作命令

### 目录切换 cd

命令：cd 目录

```
cd /        切换到根目录
cd /usr        切换到根目录下的usr目录
cd ../        切换到上一级目录 或者  cd ..
cd ~        切换到home目录
cd -        切换到上次访问的目录
```

### 目录查看 ls [-al]

命令：ls [-al]

```
ls                查看当前目录下的所有目录和文件
ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）
ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）
ls /dir            查看指定目录下的所有目录和文件   如：ls /usr
```

### 目录操作【增，删，改，查】

#### 创建目录【增】 mkdir

命令：mkdir 目录

```
mkdir    aaa            在当前目录下创建一个名为aaa的目录
mkdir    /usr/aaa    在指定目录下创建一个名为aaa的目录
```

#### 删除目录或文件【删】rm

命令：rm [-rf] 目录

删除文件：

```
rm 文件        删除当前目录下的文件
rm -f 文件    删除当前目录的的文件（不询问）
```

删除目录：

```
rm -r aaa    递归删除当前目录下的aaa目录
rm -rf aaa    递归删除当前目录下的aaa目录（不询问）
```

全部删除：

```
rm -rf *    将当前目录下的所有目录和文件全部删除
rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除
```

注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包

#### 目录修改【改】mv 和 cp

##### 重命名目录

​    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作

##### 剪切目录

```
mv 目录名称 目录的新位置
```

​    示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面     mv /usr/tmp/aaa /usr
​    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作

##### 拷贝目录

```
cp -r 目录名称 目录拷贝的目标位置   -r代表递归
```

​    示例：将/usr/tmp目录下的aaa目录复制到 /usr目录下面     cp /usr/tmp/aaa  /usr
​    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归

#### 搜索目录【查】find

```
find 目录 参数 文件名称
```

示例：find /usr/tmp -name 'a*'    查找/usr/tmp目录下的所有以a开头的目录或文件

## 文件操作命令

### 文件操作【增，删，改，查】

#### 新建文件【增】touch

```
touch 文件名
```

示例：在当前目录创建一个名为aa.txt的文件        touch  aa.txt

#### 删除文件 【删】 rm

```
rm -rf 文件名
```

#### 修改文件【改】 vi或vim

【vi编辑器的3种模式】
    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：

##### 命令行模式(command mode）

​      控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。
​      命令行模式下的常用命令：

```
【1】控制光标移动：↑，↓，j
【2】删除当前行：dd 
【3】查找：/字符
【4】进入编辑模式：i o a
【5】进入底行模式：:
```

##### 编辑模式（Insert mode）

​      只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。
​      编辑模式下常用命令：
​      【1】ESC 退出编辑模式到命令行模式；

##### 底行模式（last line mode）

​     将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。
​     底行模式下常用命令：

```
【1】退出编辑：   :q
【2】强制退出：   :q!
【3】保存并退出：  :wq
```

#### 打开文件

```
vi 文件名
```

示例：打开当前目录下的aa.txt文件     vi aa.txt 或者 vim aa.txt

注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。

#### 编辑文件

使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。

```
i:在光标所在字符前开始插入
a:在光标所在字符后开始插入
o:在光标所在行的下面另起一新行插入
```

保存或者取消编辑

##### 保存文件

```
第一步：ESC  进入命令行模式
第二步：:     进入底行模式
第三步：wq     保存并退出编辑
```

##### 取消编辑

```
第一步：ESC  进入命令行模式
第二步：:     进入底行模式
第三步：q!     撤销本次修改并退出编辑
```

#### 文件的查看【查】

cat/more/less/tail

```
cat：看最后一屏
```

示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容
cat sudo.conf

```
more：百分比显示
```

示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看
more sudo.conf

```
less：翻页查看
```

示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看
less sudo.conf

```
tail：指定行数或者动态查看
```

示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束  
tail -10 sudo.conf

### 权限修改

```
rwx：r代表可读，w代表可写，x代表该文件是一个可执行文件，如果rwx任意位置变为-则代表不可读或不可写或不可执行文件。
```

示例：给aaa.txt文件权限改为可执行文件权限，aaa.txt文件的权限是-rw-------

第一位：-就代表是文件，d代表是文件夹
第一段（3位）：代表拥有者的权限
第二段（3位）：代表拥有者所在的组，组员的权限
第三段（最后3位）：代表的是其他用户的权限

   421  421  421

-  rw-   ---     ---

```
chmod +x aaa.txt
```

或者采用8421法
命令：chmod 100 aaa.txt

## 压缩文件操作

### 打包和压缩

Windows的压缩文件的扩展名  .zip/.rar

```
linux中的打包文件：aa.tar      
linux中的压缩文件：bb.gz    
linux中打包并压缩的文件：.tar.gz
```

Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。
而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。

```
tar -zcvf 打包压缩后的文件名 要打包的文件
```

其中：z：调用gzip压缩命令进行压缩
  c：打包文件
  v：显示运行过程
  f：指定文件名

示例：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar
tar -zcvf ab.tar aa.txt bb.txt 
或：tar -zcvf ab.tar  *

### 解压

```
tar [-zxvf] 压缩文件    
```

其中：x：代表解压
示例：将/usr/tmp 下的ab.tar解压到当前目录下

示例：将/usr/tmp 下的ab.tar解压到根目录/usr下
tar -xvf ab.tar -C /usr------C代表指定解压的位置

## 查找命令

### grep

grep命令是一种强大的文本搜索工具

使用实例：

```
ps -ef | grep sshd  查找指定ssh服务进程 
ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除gerp身 
ps -ef | grep sshd -c 查找指定进程个数  
```

### find

find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。 

find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。

使用实例：

```
find . -name "*.log" -ls  在当前目录查找以.log结尾的文件，并显示详细信息。 
find /root/ -perm 600   查找/root/目录下权限为600的文件 
find . -type f -name "*.log"  查找当目录，以.log结尾的普通文件 
find . -type d | sort   查找当前所有目录并排序 
find . -size +100M  查找当前目录大于100M的文件
```

### locate

locate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。如果数据库中没有查询的数据，则会报出locate: can not stat () `/var/lib/mlocate/mlocate.db': No such file or directory该错误！updatedb即可！

yum -y install mlocate 如果是精简版CentOS系统需要安装locate命令

使用实例：

updatedb
locate /etc/sh 搜索etc目录下所有以sh开头的文件 
locate pwd 查找和pwd相关的所有文件

### whereis

whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。

使用实例：

whereis ls    将和ls文件相关的文件都查找出来

### which

which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。

使用实例：

which pwd  查找pwd命令所在路径 
which java  查找path中java的路径 

## su、sudo

### su

su用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。

su test:切换到test用户，但是路径还是/root目录
su - test : 切换到test用户，路径变成了/home/test
su : 切换到root用户，但是路径还是原来的路径
su - : 切换到root用户，并且路径是/root
su不足：如果某个用户需要使用root权限、则必须要把root密码告诉此用户。

退出返回之前的用户：exit

### sudo

sudo是为所有想使用root权限的普通用户设计的。可以让普通用户具有临时使用root权限的权利。只需输入自己账户的密码即可。

进入sudo配置文件命令：

vi /etc/sudoer或者visudo
案例：
允许hadoop用户以root身份执行各种应用命令，需要输入hadoop用户的密码。
hadoop  ALL=(ALL)   ALL 

案例：
只允许hadoop用户以root身份执行ls 、cat命令，并且执行时候免输入密码。 
配置文件中： 
hadoop  ALL=NOPASSWD:  /bin/ls, /bin/cat 

## 系统服务

```
service iptables status  --查看iptables服务的状态
service iptables start  --开启iptables服务
service iptables stop  --停止iptables服务
service iptables restart  --重启iptables服务
chkconfig iptables off  --关闭iptables服务的开机自启动
chkconfig iptables on  --开启iptables服务的开机自启动
```

## 网络管理

### 主机名配置

[root@node1 ~]# vi /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=node1

### IP 地址配置

[root@node1 ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0

### 域名映射

/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用。所以，你想访问一个什么样的主机名，就需要把这个主机名和它对应的ip地址。

[root@node1 ~]# vi /etc/hosts

在最后加上

192.168.52.201  node1
192.168.52.202  node2
192.168.52.203  node3

## 定时任务指令crontab 配置

crontab是Unix和Linux用于设置定时任务的指令。通过crontab命令，可以在固定间隔时间,执行指定的系统指令或shell脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。

crontab安装：

yum install crontabs
服务操作说明：

service crond start   ## 启动服务 
service crond stop    ## 关闭服务 
service crond restart ## 重启服务

### 命令格式

```
crontab [-u user] file
crontab [-u user] [ -e | -l | -r ]
```

参数说明：

-u user：用来设定某个用户的crontab服务  

file：file是命令文件的名字,表示将file做为crontab的任务列表文件

并载入crontab。

-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前

用户的crontab文件。

-l：显示某个用户的crontab文件内容。如果不指定用户，则表示显示当前

用户的crontab文件内容。

-r：删除定时任务配置，从/var/spool/cron目录中删除某个用户的crontab

文件，如果不指定用户，则默认删除当前用户的crontab文件。

命令示例：

crontab file [-u user] ## 用指定的文件替代目前的crontab
crontab -l [-u user]  ## 列出用户目前的crontab
crontab -e [-u user]  ## 编辑用户目前的crontab

### 配置说明、实例

命令：*   *    *   *   *   command  

解释：分  时  日  月  周  命令

第1列表示分钟1～59 每分钟用*或者 */1表示    

第2列表示小时0～23（0表示0点）

第3列表示日期1～31  

第4列表示月份1～12  

第5列标识号星期0～6（0表示星期天）  

第6列要运行的命令

配置实例：

先打开定时任务所在的文件：
crontab -e

每分钟执行一次date命令 
*/1 * * * * date >> /root/date.txt

每晚的21:30重启apache。 
30 21 * * * service httpd restart

每月1、10、22日的4 : 45重启apache。  
45 4 1,10,22 * * service httpd restart

每周六、周日的1 : 10重启apache。 
10 1 * * 6,0 service httpd restart

每天18 : 00至23 : 00之间每隔30分钟重启apache。
0,30   18-23    *   *   *   service httpd restart
晚上11点到早上7点之间，每隔一小时重启apache

*  23-7/1    *   *   *   service httpd restart
     十、其他命令
     10.1 查看当前目录：pwd
     命令：pwd     查看当前目录路径

## 查看进程：ps -ef

命令：ps -ef    查看所有正在运行的进程

## 结束进程：kill

命令：kill pid 或者 kill -9 pid(强制杀死进程)           pid:进程号

## 网络通信命令：

ifconfig：查看网卡信息

命令：ifconfig 或 ifconfig | more

ping：查看与某台机器的连接情况

命令：ping ip

netstat -an：查看当前系统端口

命令：netstat -an

搜索指定端口
命令：netstat -an | grep 8080

## 配置网络

命令：setup

## 重启网络

命令：service network restart

## 切换用户

命令：su - 用户名

## 关闭防火墙

命令：chkconfig iptables off

或者：

 iptables -L;
 iptables -F;
 service iptables stop

## 修改文件权限

命令：chmod 777

## 清屏

命令：ctrl + l

## vi模式下快捷键

esc后:

保存并退出快捷键：shift+z+z

光标跳到最后一行快捷键：shift+g

删除一行：dd

复制一行内容：y+y

粘贴复制的内容：p

# Linux项目部署

## 安装jdk1.8

先卸载open-jdk

java -version
rpm -qa | grep java

rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64
rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64

开始安装：
mkdir /usr/local/src/java
rz 上传jdk tar包
tar -zxvf jdk-8u181-linux-x64.tar.gz

yum install glibc.i686

配置环境变量：
 vi /etc/profile

 在末尾行添加
  #set java environment
  JAVA_HOME=/usr/local/src/jdk8/jdk1.8.0_181
  CLASSPATH=.:$JAVA_HOME/lib.tools.jar
  PATH=$JAVA_HOME/bin:$PATH
  export JAVA_HOME CLASSPATH PATH

保存退出
source /etc/profile  使更改的配置立即生效
java -version  查看JDK版本信息，如果显示出1.8证明成功

## 安装MySQL5.6

### 上传MySQL5.6的tar包

创建目录：mkdir /usr/local/src/mysql5.6

上传：MySQL-5.6.34-1.rhel5.x86_64.rpm-bundle.tar 到上面的目录中

### 安装

第一步：解压

     命令：tar -xvf MySQL-5.6.34-1.rhel5.x86_64.rpm-bundle.tar

第二步：检测是否已经安装了mysql

     命令：rpm -qa | grep mysql   
    
     如果已经安装了，将其卸载，如：
    
     rpm -e --nodeps  mysql-libs-5.1.71-1.el6.x86_64

第三步：安装MySQL的服务端

     命令：rpm -ivh MySQL-server-5.6.34-1.rhel5.x86_64.rpm

第四步：安装MySQL的客户端

     命令：rpm -ivh MySQL-client-5.6.34-1.rhel5.x86_64.rpm

第五步：查看MySQL服务运行状态

     命令：service mysql status

第六步：启动MySQL服务

     命令：service mysql start

第七步：使用root账号登录mysql

在安装mysql server时有句提示：

注意：这个密码是不安全的，所有需要修改初始密码。

使用密码登录mysql账号：mysql -uroot -p
修改root密码：SET PASSWORD = PASSWORD('root');

### 开机自动启动设置

加入到系统服务：

chkconfig --add mysql

自动启动：

chkconfig mysql on

查询列表：

chkconfig

说明：都没关闭（off）时是没有自动启动。

### 开启远程访问

登录：

mysql -uroot –proot

设置远程访问（使用root密码）：

grant all privileges on *.* to 'root' @'%' identified by 'root';

flush privileges;

退出mysql，在centos环境下打开3306防火墙

/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT

/etc/rc.d/init.d/iptables save

/etc/init.d/iptables status

## 安装tomcat部署项目

准备工作：将web项目打成war包，改名为ROOT.war

### 创建ucenter用户

一般情况下，发布应用程序都不是使用root用户的，需要创建一个普通用户来发布程序；

创建ucenter用户：

useradd -d /ucenter ucenter

设置密码：

passwd ucenter （密码 ucenter）

切换用户：

su - ucenter

### 安装Tomcat

tomcat只要解压就可以使用。

1、创建web目录
mkdir /ucenter/web

2、上传apache-tomcat-7.0.57.tar.gz

3、解压：tar -xvf apache-tomcat-7.0.57.tar.gz

4、重命名：mv apache-tomcat-7.0.57 itcast-usermanage

5、启动tomcat：
     cd itcast-usermanage/bin/
     ./startup.sh 或者 sh startup.sh

6、查看日志：
     tail -f ../logs/catalina.out

7、查看效果 http://192.168.0.160:8080/

发现无法访问：

8、防火墙打开 8080 端口
     /sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT

     /etc/rc.d/init.d/iptables save

9、安装成功

### 部署用户管理项目

1、上传usermanage.sql和ROOT.war到/ucenter/web

2、执行数据库脚本

     cat user_manager.sql | mysql -uroot -p123456

3、部署web程序

3.1 删除webapps下的所有文件

     cd /ucenter/web/usermanage/webapps
    
     rm -rf *

3.2 拷贝ROOT.war到webapps

     cp /ucenter/web/ROOT.war .

3.3 重新启动tomcat

     cd ../bin/
    
     sh startup.sh && tail -f ../logs/catalina.out

3.4 启动浏览器测试

注意事项：Centos环境下部署项目中文乱码问题解决方案

    今天在一台新的CentOS机器上使用c3p0连接池操作mysql数据库出现中文乱码问题，具体表现为：查询时无中文乱码问题，写数据时中文乱码，查看了机器上数据库字符集也是UTF8，应该不会出现中文乱码才对，最后在c3p0配置文件中 jdbcUrl后加上：?useUnicode=true&amp;characterEncoding=UTF8 中文就不会乱码了。

【C3P0配置文件】

<?xml version="1.0" encoding="UTF-8"?>
<c3p0-config>
  <default-config>
    <property name="driverClass">com.mysql.jdbc.Driver</property>
	<property name="jdbcUrl">jdbc:mysql://localhost:3306/user_manager_yun6?useUnicode=true&amp;characterEncoding=UTF8 </property>
	<property name="user">root</property>
	<property name="password">root</property>
	<property name="acquireIncrement">2</property>
	<property name="initialPoolSize">5</property>
	<property name="minPoolSize">1</property>
	<property name="maxPoolSize">5</property>
  </default-config>
</c3p0-config>

## Linux下使用FastDFS

相关的安装包我打包到云盘上了，链接：https://pan.baidu.com/s/13NDYYil4mgLhkb5CYsc2Ww  提取码：66tn

单节点FastDFS

整个安装过程非常复杂，很容易出错，建议进行多次备份。

我们这里不打算安装多台虚拟机，因此会把tracker和storage都安装在一起。

### 安装gcc

GCC用来对C语言代码进行编译运行，使用yum命令安装：

yum -y install gcc
后面会用到解压命令（unzip），所以这里可以用yum把unzip 也装一下

yum install -y unzip zip

### 安装libevent

yum -y install libevent

### 安装libfastcommon-master

解压刚刚上传的libfastcommon-master.zip
unzip libfastcommon-master.zip

进入解压完成的目录
cd libfastcommon-master

编译并且安装：
./make.sh 
./make.sh install

### 安装fastdfs

tar -zxvf FastDFS_v5.08.tar.gz
cd FastDFS
./make.sh
./make.sh install
如果安装成功，会看到/etc/init.d/下看到提供的脚本文件：

ll /etc/init.d/ | grep fdfs


fdfs_trackerd 是tracker启动脚本

fdfs_storaged 是storage启动脚本

能够在 /etc/fdfs/ 目录下看到默认的配置文件模板：

ll /etc/fdfs/


tarcker.conf.sample 是tracker的配置文件模板

storage.conf.sample 是storage的配置文件模板

client.conf.sample 是客户端的配置文件模板

### 配置并启动tracker服务

1）首先将模板文件复制

cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf
2）修改复制后的配置文件：

vim /etc/fdfs/tracker.conf 

修改的内容如下：

base_path=/项目名/tracker                 # 存储日志和数据的根目录
3）新建目录：

mkdir -p /项目名/tracker
注意：关闭防火墙：

chkconfig iptables off
4）启动和停止

service fdfs_trackerd start # 启动fdfs_trackerd服务，停止用stop
检查FastDFS Tracker Server是否启动成功：

ps -ef | grep fdfs_trackerd
设置tracker服务开机启动:

chkconfig fdfs_trackerd on

### 配置并启动storage服务

1）首先将模板文件复制

cp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf
2）修改复制后的配置文件：

vim /etc/fdfs/storage.conf

修改的内容如下:

base_path=/项目名/storage                 # 数据和日志文件存储根目录 

store_path0=/项目名/storage           # 第一个存储目录 

tracker_server=192.168.56.101:22122       #  tracker服务器IP和端口 
3）新建目录：

mkdir -p /项目名/storage
注意关闭防火墙： chkconfig iptables off

4）启动和停止

service fdfs_storaged start  # 启动fdfs_storaged服务，停止用stop
设置storage服务开机启动：

chkconfig fdfs_storaged on
ps -ef | grep fdfs

## 安装fastdfs-nginx-module

### 解压

tar -zxvf fastdfs-nginx-module_v1.16.tar.gz

### 修改config

1）进入src目录

cd fastdfs-nginx-module/src/
2）编辑config

vim config
使用以下底行命令：

:%s+/usr/local/+/usr/+g
将所有的/usr/local替换为 /usr，这个才是正确的目录:

### 配置nginx与FastDFS关联配置文件

复制 fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录， 并修改

cp /usr/local/项目名/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/

vi /etc/fdfs/mod_fastdfs.conf
修改以下配置：

connect_timeout=10                       # 客户端访问文件连接超时时长（单位：秒）

tracker_server=192.168.56.101:22122    # tracker服务IP和端口

url_have_group_name=true                # 访问链接前缀加上组名

store_path0=/leyou/storage            # 文件存储路径
复制 FastDFS 的部分配置文件到/etc/fdfs 目录

cd /usr/local/项目名/FastDFS/conf/
cp http.conf mime.types /etc/fdfs/

## 安装Nginx的插件

### 如果没有安装过nginx

1、安装nginx的依赖库

yum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel
2、解压安装包

tar -zxvf nginx-1.10.0.tar.gz

3、配置nginx安装包，并指定fastdfs-nginx-model

cd nginx-1.10.0

./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/usr/local/leyou/fastdfs-nginx-module/src
注意：在执行./configure配置nginx参数的时候，需要将fastdfs-nginx-moudle源码作为模块编译进去。

4、编译并安装

make && make install

### 如果已经安装过nginx

1、 进入nginx目录：

cd /usr/local/项目名/nginx-1.10.0/
2、 配置FastDFS 模块

./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/usr/local/项目名/fastdfs-nginx-module/src
注意：这次配置时，要添加fastdfs-nginx-moudle模块

3、编译，注意，这次不要安装（install）

make
4、替换nginx二进制文件:

备份：

mv /usr/bin/nginx /usr/bin/nginx-bak
用新编译的nginx启动文件替代原来的：

cp objs/nginx /usr/bin/

### 启动nginx

配置nginx整合fastdfs-module模块

我们需要修改nginx配置文件，在/opt/nginx/config/nginx.conf文件中：

vim  /opt/nginx/conf/nginx.conf
将文件中，原来的server 80{ ...} 部分代码替换为如下代码：

server {
    listen       80;
    server_name  image.项目名.com;
	# 监听域名中带有group的，交给FastDFS模块处理
​    location ~/group([0-9])/ {
​        ngx_fastdfs_module;
​    }
​    location / {
​        root   html;
​        index  index.html index.htm;
​    }
​    error_page   500 502 503 504  /50x.html;
​    location = /50x.html {
​        root   html;
​    }
}
启动nginx：

nginx	# 启动nginx

nginx -s stop	# 停止nginx

nginx -s reload	# 重新载入配置文件

可通过ps -ef | grep nginx查看nginx是否已启动成功

### 设置nginx开机启动

创建一个开机启动的脚本：

vim /etc/init.d/nginx
添加以下内容：

#!/bin/sh
#

nginx - this script starts and stops the nginx daemon

#

chkconfig:   - 85 15

description:  NGINX is an HTTP(S) server, HTTP(S) reverse \

proxy and IMAP/POP3 proxy server

processname: nginx

config:      /etc/nginx/nginx.conf

config:      /etc/sysconfig/nginx

pidfile:     /var/run/nginx.pid

Source function library.

. /etc/rc.d/init.d/functions

Source networking configuration.

. /etc/sysconfig/network

Check that networking is up.

[ "$NETWORKING" = "no" ] && exit 0

nginx="/usr/bin/nginx"
prog=$(basename $nginx)

NGINX_CONF_FILE="/opt/nginx/conf/nginx.conf"

[ -f /etc/sysconfig/nginx ] && . /etc/sysconfig/nginx

lockfile=/var/lock/subsys/nginx

make_dirs() {

make required directories

   user=`$nginx -V 2>&1 | grep "configure arguments:.*--user=" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -`
   if [ -n "$user" ]; then
      if [ -z "`grep $user /etc/passwd`" ]; then
         useradd -M -s /bin/nologin $user
      fi
      options=`$nginx -V 2>&1 | grep 'configure arguments:'`
      for opt in $options; do
          if [ `echo $opt | grep '.*-temp-path'` ]; then
              value=`echo $opt | cut -d "=" -f 2`
              if [ ! -d "$value" ]; then

echo "creating" $value

​                  mkdir -p $value && chown -R $user $value
​              fi
​          fi
​       done
​    fi
}

start() {
    [ -x $nginx ] || exit 5
    [ -f $NGINX_CONF_FILE ] || exit 6
    make_dirs
    echo -n $"Starting $prog: "
    daemon $nginx -c $NGINX_CONF_FILE
    retval=$?
    echo
    [ $retval -eq 0 ] && touch $lockfile
    return $retval
}

stop() {
    echo -n $"Stopping $prog: "
    killproc $prog -QUIT
    retval=$?
    echo
    [ $retval -eq 0 ] && rm -f $lockfile
    return $retval
}

restart() {
    configtest || return $?
    stop
    sleep 1
    start
}

reload() {
    configtest || return $?
    echo -n $"Reloading $prog: "
    killproc $nginx -HUP
    RETVAL=$?
    echo
}

force_reload() {
    restart
}

configtest() {
  $nginx -t -c $NGINX_CONF_FILE
}

rh_status() {
    status $prog
}

rh_status_q() {
    rh_status >/dev/null 2>&1
}

case "$1" in
    start)
        rh_status_q && exit 0
        $1
        ;;
    stop)
        rh_status_q || exit 0
        $1
        ;;
    restart|configtest)
        $1
        ;;
    reload)
        rh_status_q || exit 7
        $1
        ;;
    force-reload)
        force_reload
        ;;
    status)
        rh_status
        ;;
    condrestart|try-restart)
        rh_status_q || exit 0
            ;;
    *)
        echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}"
        exit 2
esac
修改文件权限，并加入服务列表

修改权限

chmod 777 /etc/init.d/nginx 

添加到服务列表

chkconfig --add /etc/init.d/nginx 
设置开机启动

chkconfig nginx on

## 安装Elasticsearch

需要虚拟机JDK1.8及以上

### 新建一个用户leyou

出于安全考虑，elasticsearch默认不允许以root账号运行。

创建用户：

useradd leyou
设置密码：

passwd leyou
切换用户：

su - leyou

### 上传安装包,并解压

我们将安装包上传到：/home/leyou目录

解压缩：

tar -zxvf elasticsearch-6.2.4.tar.gz
我们把目录重命名：

mv elasticsearch-6.3.0/ elasticsearch


进入，查看目录结构：

### 修改配置

我们进入config目录：cd config

需要修改的配置文件有两个：

1、jvm.options

Elasticsearch基于Lucene的，而Lucene底层是java实现，因此我们需要配置jvm参数。

编辑jvm.options：

vim jvm.options
默认配置如下：

-Xms1g
-Xmx1g

内存占用太多了，我们调小一些：

-Xms512m
-Xmx512m

2、elasticsearch.yml

vim elasticsearch.yml
修改数据和日志目录：

path.data: /home/leyou/elasticsearch/data # 数据目录位置
path.logs: /home/leyou/elasticsearch/logs # 日志目录位置
我们把data和logs目录修改指向了elasticsearch的安装目录。但是这两个目录并不存在，因此我们需要创建出来。

进入elasticsearch的根目录，然后创建：

mkdir data
mkdir logs


修改绑定的ip：

network.host: 0.0.0.0 # 绑定到0.0.0.0，允许任何ip来访问
默认只允许本机访问，修改为0.0.0.0后则可以远程访问

### 运行

进入elasticsearch/bin目录，可以看到下面的执行文件：

然后输入命令：

./elasticsearch
或者后台运行：

./elasticsearch -d

### 错误1：内核过低


修改elasticsearch.yml文件，在最下面添加如下配置： 然后重启

bootstrap.system_call_filter: false

### 错误2：文件权限不足


我们用的是leyou用户，而不是root，所以文件权限不足。

首先用root用户登录。直接输入exit命令

然后修改配置文件:

vim /etc/security/limits.conf
添加下面的内容：

* soft nofile 65536

* hard nofile 131072

* soft nproc 4096

* hard nproc 4096
     11.7.7 错误3：线程数不够
     [1]: max number of threads [1024] for user [leyou] is too low, increase to at least [4096]

继续修改配置：

vim /etc/security/limits.d/90-nproc.conf 
修改下面的内容：

* soft nproc 1024
     改为

* soft nproc 4096
     11.7.8 错误4：进程虚拟内存
     [3]: max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]

vm.max_map_count：限制一个进程可以拥有的VMA(虚拟内存区域)的数量，继续修改配置文件， ：

vim /etc/sysctl.conf 
添加下面内容：

vm.max_map_count=655360
然后执行命令：

sysctl -p

### 重启终端窗口

所有错误修改完毕，一定要重启你的 Xshell终端，否则配置无效。

### 安装RabbitMQ

cd /usr/local/myapp

mkdir rabbitmq

cd rabbitmq

### 安装Erlang

1、在线安装

yum install esl-erlang_17.3-1~centos~6_amd64.rpm

yum install esl-erlang-compat-R14B-1.el6.noarch.rpm
2、离线安装

依次执行命令：

1）rpm -ivh esl-erlang-17.3-1.x86_64.rpm --force --nodeps

2）rpm -ivh esl-erlang_17.3-1~centos~6_amd64.rpm --force --nodeps

3）rpm -ivh esl-erlang-compat-R14B-1.el6.noarch.rpm --force --nodeps

### 安装RabbitMQ


安装：

rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm

### 设置配置文件

cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example
/etc/rabbitmq/rabbitmq.config
开启用户远程访问

vi /etc/rabbitmq/rabbitmq.config


注意要去掉后面的逗号。

### 启动、停止

service rabbitmq-server start

service rabbitmq-server stop

service rabbitmq-server restart

### 开启web界面管理工具

rabbitmq-plugins enable rabbitmq_management

service rabbitmq-server restart

### 设置开机启动

chkconfig rabbitmq-server on

### 防火墙开放15672端口

/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT

/etc/rc.d/init.d/iptables save

## redis安装和配置

### 安装

解压

tar -xvf redis-4.0.9.tar.gz
编译安装

 mv redis-4.0.9 redis
 cd redis
 make && make install

### 配置

修改安装目录下的redis.conf文件

vim redis.conf
修改以下配置：

#bind 127.0.0.1 # 将这行代码注释，监听所有的ip地址，外网可以访问
protected-mode no # 把yes改成no，允许外网访问
daemonize yes # 把no改成yes，后台运行

### 启动或停止

redis提供了服务端命令和客户端命令：

redis-server 服务端命令，可以包含以下参数： start 启动 stop 停止

redis-cli 客户端控制台，包含参数： -h xxx 指定服务端地址，缺省值是127.0.0.1 -p xxx 指定服务端端口，缺省值是6379

### 设置开机启动

1) 输入命令，新建文件

vim /etc/init.d/redis
输入下面内容：

#!/bin/sh

chkconfig:   2345 90 10

description:  Redis is a persistent key-value database

PATH=/usr/local/bin:/sbin:/usr/bin:/bin

REDISPORT=6379
EXEC=/usr/local/bin/redis-server
REDIS_CLI=/usr/local/bin/redis-cli

PIDFILE=/var/run/redis.pid

CONF="/usr/local/leyou/redis/redis.conf"

case "$1" in  
    start)  
        if [ -f $PIDFILE ]  
        then  
                echo "$PIDFILE exists, process is already running or crashed"  
        else  
                echo "Starting Redis server..."  
                $EXEC $CONF  
        fi  
        if [ "$?"="0" ]   
        then  
              echo "Redis is running..."  
        fi  
        ;;  
    stop)  
        if [ ! -f $PIDFILE ]  
        then  
                echo "$PIDFILE does not exist, process is not running"  
        else  
                PID=$(cat $PIDFILE)  
                echo "Stopping ..."  
                $REDIS_CLI -p $REDISPORT SHUTDOWN  
                while [ -x ${PIDFILE} ]  
               do  
                    echo "Waiting for Redis to shutdown ..."  
                    sleep 1  
                done  
                echo "Redis stopped"  
        fi  
        ;;  
   restart|force-reload)  
        ${0} stop  
        ${0} start  
        ;;  
  *)  
    echo "Usage: /etc/init.d/redis {start|stop|restart|force-reload}" >&2  
        exit 1  
esac
然后保存退出

注意：以下信息需要根据安装目录进行调整：

EXEC=/usr/local/bin/redis-server # 执行脚本的地址

REDIS_CLI=/usr/local/bin/redis-cli # 客户端执行脚本的地址

PIDFILE=/var/run/redis.pid # 进程id文件地址

CONF="/usr/local/src/redis-3.0.2/redis.conf" #配置文件地址

2）设置权限

chmod 755 /etc/init.d/redis
3）启动测试

/etc/init.d/redis start
启动成功会提示如下信息：

Starting Redis server...
Redis is running...

4）设置开机自启动

chkconfig --add /etc/init.d/redis
chkconfig redis on

# 参考

*    鸟哥的Linux私房菜-基础篇-第四版
*    ARM嵌入式LINUX系统开发详解 第2版  弓雷著

# 附录

## 1. 查询函数

```
linux> man <函数名>
```

