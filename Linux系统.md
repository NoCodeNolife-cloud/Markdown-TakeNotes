# 嵌入式系统入门

## 什么是嵌入式系统

可以把嵌入式系统理解为一种为特定设备服务的软件硬件可裁剪的计算机
系统。

## 嵌入式系统应用领域

*    家用电器和电子类产品

*    交通工具

*    公共电子设施

## 嵌入式系统发展

嵌入式系统的种类繁多， 按照系统硬件的核心处理器来说， 可以分成嵌入式微控制器和嵌入式微处理器。

### 嵌入式微控制器

嵌入式微控制器也就是传统意义上的单片机， 它可以说是目前嵌入式系统的前身。

单片机就是把一个计算机的主要功能集成到了一个芯片上， 简单说，单片机就是一个计算机。 它的特点是体积小、 结构简单、 便于开发， 以及价格经济。

### 嵌入式微处理器

嵌入式处理器在一个芯片上集成了复杂的功能， 同时一些微处理器还把常见的外部设备控制器也集成到芯片内部。 

由于嵌入式微处理器提供了强大的处理能力， 一些厂商以及计算机爱好者在嵌入式微 处理器上面开发了操作系统， 帮助使用嵌入式系统的人简化开发、 提高工作效率， 这在单片机上是很难实现的。

在一个嵌入式微处理器内部集成了许多外部设备控制器。 这种设计方法大大简化了外部电路的设计和调试， 同时整个系统的硬件体积也大幅缩小。

## 典型的嵌入式系统组成

与传统计算机不同的是，嵌入式系统种类繁多。许多的芯片厂商、软件厂商加入其中，
导致有多种硬件和软件， 甚至解决方案。 一般来说， 不同的嵌入式系统的软、 硬件是很难兼容的， 软件必须修改， 而硬件必须重新设计才能使用。 虽然软、硬件种类繁多， 但是不同的嵌入式系统还是有很多相同之处的。

硬件部分可以分成嵌入式处理器和外部设备。 处理器是整个系统的核心， 负责处理所有的软件程序以及外部设备的信号。 外部设备在不同的系统中有不同的选择。 

软件部分可以分成两层，最靠近硬件的是嵌入式操作系统。操作系统是软硬件的接口，负责管理系统的所有软件和硬件资源。 操作系统还可以通过驱动程序与外部设备打交道。最上层的是应用软件， 应用软件利用操作系统提供的功能开发出针对某个需求的程序， 供用户使用。

# 嵌入式软硬件系统

## 电路基本知识

### 模拟电路

处理模拟信号的电路称做模拟电路。 模拟信号的特点是信号是线性变化的，意思是信号变化是连续的。 

### 数字电路

通常数字电路具有逻辑运算和逻辑处理的功能。

与模拟信号不同，数字信号使用电压的高低或者电流的有无表示逻辑上的1或0,因此数字电路可以方便地表示出二进制数。

数字电路可以分成脉冲电路和逻辑电路两部分， 脉冲电路负责信号变换和测量； 逻辑电路负责处理数字逻辑。

与模拟电路不同， 数字电路关心的是信号状态的变化。 通过数字逻辑可以处理复杂的二进制信息， 因此数字电路是计算机的基础。 

### 数制转换

计算机是由数字电路构成的 ， 其内部数据的传输和处理都使用二进制方式。 

二进制的特点是 “逢2进1”。

与十进制数类似，十六进制数是逢16进1位。

## 计算机组成原理

### 计算机体系的发展

计算机是由硬件系统和软件系统两大部分组成的。 按照功能又可以划分为指令系统、存储系统、 输入输出系统等。 

冯. 诺依曼结构是以数学家 John Von Neumann 的名字命名的，他最早提出了该结构。 该结构把计算机分成了<u>运算器、 控制器、 存储器、 输入设备和输出设备</u>5个部分。 它的工作原理是把让计算机工作的指令（也可理解为程序）存储在存储器内，工作的流程是从存储器取出指令， 由运算器运算指令， 控制器负责处理输入设备和输出设备。

哈佛结构最大的特点就是把指令和数据分开存储。 控制器可以先读取指令，然后交给运算器解码， 得到数据地址后， 控制器读取数据交给运算器：在运算器运算的时候，控制器可以读取下一条指令或者数据。

这种把指令和数据分开存储的方式可以获得较高的执行效率。 

### 中央处理器

中央处理器的英文全称是 Central Process Unit，简称 CPU，是一个计算机系统的核心。

CPU 是由运算器、 控制器、 寄存器和内部总线组成的。 在 CPU 之外再加入总线、 存储设备、 输入输出设备就可以构成 个完整的计算机系统。

输入输出设备就可以构成一个完整的计算机系统。

CPU 有几个重要的参数，包括<u>工作频率、 字长、 指令集和缓存</u>。 工作频率通常是用户最多听到的参数， 一个 CPU 的工作频率包括了主频和外频，以及外部总线频率。 主频是CPU 的实际工作频率，外频是 CPU 工作的基准频率，还有 个是总线的工作频率。

决定 CPU 处理数据能力的是 CPU 的字长，有的教材也称做位宽，它是 CPU 在一个周期期能处理的最大数据宽度。

CPU 内部是通过执行指令工作的。 每种 CPU 都有专门的一组指令， 称为指令集。 

按照指令的执行方式可以把计算机 CPU 指令集分成<u>复杂指令集和精简指令集</u>。 复杂指令集(CISC）的特点是使程序中的指令按照顺序执行。 其优点是结构简单， 便于控制；缺点也很明显， 由于指令顺序执行， 计算机各部分不能同时工作， 执行效率不高。 常见的 CISC指令集 CPU 是 Intel 的 X86 系列。

缓存是 CPU 内部一个重要的器件， 主要用来暂时存储指令和数据， 是由于 CPU 内部和外部工作的速度不同造成的。 一个 CPU 的缓存越大， 相对处理指令的能力就越强。

### 存储系统

由于材料和价格因素的限制， 计算机的存储器件在容量、 速度等方面需要匹配。 存储系统的作用就是设计一个让各种存储器相互配置达到最优性价比的方案。

### 总线系统

总线是CPU连接外部设备的通道。通常包括数据总线（DataBus）、地址总线
( AddressBus）和控制总线（ControlBus）。

地址总线负责向外部设备发送地址信息；数据总线负责从外部设备读取或者写入信息：控制总线负责发送信号控制外部设备。

总线的出现规范了 CPU 和外设之间的通信标准，简化了外部器件的设计。使用一些通用的总线可以有效地降低开发成本。

### 输入输出系统

输入输出系统由外部设备和输入输出控制器组成， 是 CPU 与外部通信的系统。 CPU通过总线与输入输出系统相连。由于外部设备的速度差异， CPU 可以使用不同的方式控制外部设备的访问。 常见的有<u>轮询方式、 中断控制方式和 DMA 方式</u>。

嵌入式系统通常会设计许多的中断信号控制线， 供连接不同的外部设备。

#### DMA

对于这种大量的数据传输可以不通过 CPU 而直接传送到内存，这种方式叫做直接内存访问（ Direct Memory Access ）， 简称 <u>DMA</u>。使用 DMA 方式， 外部 设备在数据准备好之后只需要向 DMA 控制器发送一个命令， 把数据的地址和大小传送过 去， 由 DMA 控制器负责把数据从外部设备直接存放到内存。

## 软件基础知识

嵌入式系统的基础是硬件，软件是嵌入式系统的灵魂。

### 什么是软件

 严格地说， 软件是由程序和文档构成的， 程序是一组按照特 定结构细织的指令和数据集合。

通常软件可以分成系统软件和应用软件，以及目前兴起的介于二者之间的中间件软件。

系统软件是使用计算机提供的基本功能，例如操作系统和数据库系统。
软件的另一个组成部分是文档。 随着软件复杂程度的提高，文档也越来越重要。 常见的软件文档有开发文档和用户文档， 前者面向开发人员，后者面向最终用户。软件开发人员应该养成编写文档的好习惯。

### 软件开发流程

<u>需求分析、 概要设计和详细设计、 编码和调试、 测试和维护</u>

编码调试是最关键的一个环节。该阶段根据需求分析的结果，按照文档的要求在特定的平台和工具环境下完成程序编写和调试的工作。在整个软件开发流程中， 编码调试是占用时间开发流程最长的， 这个过程需要细心和经验丰富的程序员来完成。

测试的目的是找出软件的问题，或者存在的缺陷（Bug）。软件测试可以分成不同层次，代码级别的有单元测试，高层的有集成测试等。测试手段的好坏直接决定了软件的质量。

### 常见的软件开发模型

#### 瀑布模型

瀑布模型把软件开发分成需求阶段、 规格说明阶段、 设计阶段和实现阶段。需求阶段由系统分析师确定整个系统的功能需求， 被认可后制定整体的规格并且建立文档。进入设计阶段后，系统分析员按照模块划分整个系统， 并且设计每个模块的功能和接口。最后在完成阶段由程序员完成模块的编码调试，组合成完整的软件。瀑布模型使线型结构便于管理， 被广泛地应用在软件开发团队中。

#### 增量模型

增量模型的思想是，通过不断增加软件的功能完成整个系统。该模型首先开发出一个基本的软件框架，然后在上面不断增加新的功能。增加功能是按照特定的步骤和策略完成的， 最终的目标是完成所有的需求。增量模型的好处是可以让用户尽早地看到软件产品，可以提出意见促进以后的修改。

#### 统一软件开发模型

统一软件开发模型借鉴了之前的成功经验和失败教训，融入了瀑布模型和增量模型的思想。统一软件开发模型把个软件项目分成初始阶段、 细化阶段、 构造阶段和移交阶段。 在每个阶段中保留了瀑布模型的工作流程。在整体的流程上采用增量模型的迭代思想， 不断演进， 最终达到所有需求完成的目标。 统 个复杂的开发过程，适合大型的软件系统。该模型还制定了过程描述语言UML，可以帮助开发人员减少开发过程中的错误。

### 计算机编程语言

计算机语言可以分成机器语言、 汇编语言和高级语言。 

#### 机器语言

机器语言是供计算机本身识别的， 为二进制串。 

#### 汇编语言

汇编语言是对机器语言的抽象， 其实质与机器语言是相同的。汇编语言的指令与机器语言是一对应的。 此外， 汇编语言还设计了伪指令和宏指令， 帮助编程人员提高开发效率。汇编语言是依赖体系结构的，在一种CPU上能执行的汇编语言在其他CPU上可能就无法执行了。

#### 高级语言

高级语言从程序的功能角度出发， 从各种功能中抽象出计算机可以处理的方法提供给用户。 用户可以像使用类似自然语言样书写程序， 极大地提高了开发效率。 高级语言的一个功能或者说是个函数可能对应汇编语言的若干条指令。嵌入式系统开发中常见的高级语言有C和C＋＋。

#### 解释语言

无论是汇编语言还是高级语言都不能被计算机直接执行， 需要转换为机器语言，这个过程叫做编译。 对于高级语言来说， 还有类解释型的语言，通过特定的解释器可以边解释用户编写的程序内容边输出结果。常见的脚本语言都属于解释语言。

### 数据结构

计算机的本质是处理数据的机器。 数据是计算机加工和处理的对象。 计算机中的数据有很多种类， 如何处理数据就成为了一门学问。 

数据结构包括数据逻辑结构、 物理结构和数据操作3方面的内容。

计算机把处理的数据分成多种类型， 包括一些基本结构类型。 数据结构中认为数据元素是基本的类型。 数据的逻辑结构描述数据元素之间的逻辑关系， 是抽象出来的数学模型， 与具体的机器无关。
数据的物理结构描述数据元素的存储结构， 依赖于具体的计算机实现。

## 操作系统知识

#### 什么是操作系统

操作系统是一类特殊的系统软件。 它管理整个系统的所有硬件和软件， 通常是整个计算机系统中最接近硬件的系统软件。 操作系统屏蔽了硬件的底层特性， 向应用软件提供了一个统一的接口。 对于应用软件来说， 不需要知道硬件的具体特性， 使用操作系统提供的接口即可完成相应的功能。 除此之外， 操作系统通过特定的算法统筹安排整个计算机系统软硬件资源， 使计算机的资源利用率更高， 甚至获得比硬件更多的功能。

#### 操作系统由什么组成

按照软件的结构划分， 操作系统可以分成内核、 驱动程序和程序库。 内核是操作系统的核心， 也是整个系统软件的核心。

*    内核从抽象的层面提供最基本的功能， 通常代码短小精炼。 
*    驱动程序是计算机系统必不可少的一类系统软件， 系统和驱动程序打交道而不会直接访问硬件， 硬件的具体细节由驱动程序完成， 是软硬件的接口。 
*    程序库是操作系统向用户提供的程序接口。

#### 几种操作系统的设计思路

通常内核有简单结构、 层次结构、 微内核结构和虚拟机结构等。

##### 简单结构

简单结构比较好理解， 内核中各种功能没有严格的界限， 混杂在一起。

##### 层次结构

层次结构的设计思想是把内核需要提供的功能划分出层次， 最底层仅提供抽象出来的最基本的功能， 每一层利用下面的一层功能， 以此类推， 最上面的层可以提供丰富的功能。 这种设计思路结构清晰是操作系统内核的一大进步。

##### 微内核结构

其设计思想是内核提供最基本最核心
的功能， 注重把系统的服务功能和基本操作分开。 

### 操作系统分类

按照用户角度可以分成单用户和多用户操作系统。 单用户操作系统仅支持一个用户， 特点是系统利用率低，但是便于管理；多用户操作系统支持数个用户， 并且同时可以运行多个用户的程序，提高了资源利用率，但是管理难度也相应提高。

按照系统对任务的处理相应时间来划分， 可以把操作系统分成分时系统和实时系统。分时系统中，不同用户的进程按照定的策略分别得到 CPU 资源，未能得到资源的用户只能等待。 实时系统则不然， 任务是按照优先级和响应时间分配的， 在一个设定的响应时间内， 任务必须得到响应。

随着网络的发展，现在出现了分布式操作系统。通过把一个网络内的计算机资源共享，个计算任务可以分散在不同的计算机上进行， 最后把结果汇总。 分布式操作系统能最大限度地利用现有的资源， 得到强大的计算能力， 是未来科学计算领域的一个发展趋势。

# ARM处理器

ARM 既是一种嵌入式处理器体系结构的缩写，也是一家公司的名字。

## 微处理器和微控制器

微处理器并不是因为制造工艺高超而出名的。现代计算机可以把功能复杂的
CPU，以及一些外部器件都集成在一个芯片上，微处理器因此而得名。

## ARM处理器介绍

ARM 是英文 Advanced RISC Machines 的缩写，中文译为高性能RISC 机器。从名称可以看出， ARM 是一种基于RISC 架构的高性能处理器。

### ARM 微处理器的应用领域

*    工业控制
*    无线通信
*    网络应用
*    消费电子产品

### ARM 的功能特点

ARM核心的处理器采用RISC体系结构， 具有以卡优点：

*    芯片体积小，功耗低， 制造成本低， 性能优异。
*    支持Thumb ( 16位）和ARM (32位）指令集， 8位和16位设备兼容性好。
*    由于采用RISC架构，在内部大量使用寄存器，执行指令速度快。
*    大部分的指令都是操作寄存器， 只有很少指令会访问外部内存。
*    采用多级流水线结构处理速度快。
*    支持多种寻址方式， 数据存取方式灵活。
*    指令长度固定， 便于编译器操作以及执行指令。

## ARM指令集

指令集指 个微处理器所有指令的集合， 每种微处理器都有自己的指令集。

ARM处 理器使用RISC(精简指令集)。

精简指令集的最大特点是所有的指令占用相同的存储空间。

### 算术运算指令

算术运算指令用于普通数据计算。常见的指令有ADD、ADC、SUB和SBC。

#### ADD指令

ADD指令用于普通的加法运算。

```
ADD{条件}{S}<dest>,<op_1>,<op_2> 
//dest是目的寄存器，op 1和op 2是操作数dest = op_1 + op_2
```

ADD指令把两个操作数 op_1和 op_2 相加， 结果存放到目的寄存器 dest 中。 操作数op_1 和 op_2 可以是寄存器或者是 个立即数。

#### ADC指令

ADC 指令用于带进位的加法运算。

```
ADC{条件}{S}<dest>, <op_1>, <op_2> 
//dest是目的寄存器，op_l和op_2是操作数dest = op_1＋ op_2 + carry  
```

ADC 指令把两个操作数 op_1 和 op_2 相加， 结果存放到目的寄存器 dest 中。 ADC 指在使用一个进位标志位， 可以进行大于 32 位的加法操作。 如计算两个 32 位数的和， 结果可以存放到一个64位数中。

#### SUB指令

SUB指令用于普通的减法运算。

```
SUB{条件}{S}<dest>, <op_1>, <op_2>
//dest是目的寄存器，op l 和 op 2是操作数dest = op 1 - op 2 
```

SUB指令使用操作数op_1减去操作数op_2， 结果存放到目的寄存器dest中。

#### SBC指令

SBC指令用于带借位的减法运算。

```
SBC｛条件｝｛S} <dest>, <op 1>, <op 2> 
//dest是目的寄存器，op_1 和 op_2是操作数dest = op_1 - op_2 - !carry
```

SBC指令的作用是两个操作数的减法， 结果存放到目的寄存器中。SBC指令支持借位标志， 因此可以支持大于32位数的减法操作。

### 逻辑运算指令	

#### AND指令

AND指令求两个操作数的逻辑与的结果。

```
AND｛条件｝｛S} <dest>, <op l>, <op 2>
//dest是目的寄存器，op_1 和 op_2是操作数dest = op_1 AND op_2 
```


AND指令在两个操作数op_1和op_2之间做逻辑与操作，结果存放到目的寄存器dest

#### EOR指令

EOR指令对两个操作数做异或运算。

```
EOR{条件}{S}<dest>, <op_1>, <op_2> 
//dest是目的寄存器，op_1 和 op_2 是操作数 dest ＝ op_1 EOR op_2
```

EOR 指令的作用是对两个操作数 op_1 和 op_2 做逻辑异或操作，结果存放到目的寄存器中， 常被用于设置某个特定位反转。 EOR 指令中， op_1 是寄存器， op_2 可以是寄存器或者立即数。

#### MOV指令

MOY 可以在两个操作数之间复制数据。

```
MOV{条件}{S}<dest>, <op_1> 
//dest是目的寄存器，op_1是操作数dest = op_1
```

MOY 指令的作用是把另一个寄存器或者立即数复制到目的寄存器中， 支持操作数的移位操作。

#### 分支指令

在汇编语言中， 代码的跳转都是通过分支指令来完成， ARM 的分支指令比较简单

B 指令可以根据设置的条件跳转到指定的代码地址。

```
B{条件}<地址>
```

B指令是分支跳转指令。 程序中遇到B指令会立即跳转到指定地址， 然后继续从新的地址开始运行程序。 高级语言（例如C语言）的 goto 语句常被翻译成B指令。

#### 数据传送指令

数据传送指令用于 CPU 和存储器之间的数据传送，是 ARM 处理器唯一能与外部存储器交换数据的一类指令。

##### 单一数据传送指令

单一数据传送指令用于向内存装载和存储一个字节或者一个字长的数据。

```
LDR{条件}  Rd,＜地址>
STR{条件}   Rd, ＜地址>
LDR{条件}B   Rd, ＜地址>
STR{条件}B   Rd, ＜地址>
```

单一数据传送指令 STR 和 LDR 可以在内存和寄存器之间装载或者存储一个或多个字节的数据，并且提供了灵活的寻址方式。 Rd 是要操作的数值，地址可以是基址寄存器Rbase和变址寄存器Rindex 指定的地址。 在条件后加入标志B代表一次传送1字节数据。 

```
STR Rd, [Rbase] 		；存储Rd到Rbase所包含的有效地址
STR Rd, [Rbase, Rindex]    ；存储Rd到Rbase+Rindex所合成的有效地址
STR Rd, [Rbase, #index]    ；存储Rd到Rbase+index所合成的有效地址。index是立即数
```

#### 多数据传送指令

多数据传送指令用于向内存装载和存储多个字节或字的数据。

```
xxM{条件}{类型} Rn {!}，＜寄存器列表＞{^}
```

其中， xx 可以是LD， 表示装载， 也可以为ST，表示存储。 多数据传送指令用于寄存器和内存之间多个数据的复制。

```
LDMED LDMIB                             ;装载前增加地址，相当于c语言的++p
LDMFD LDMIA                            ;装载后增加地址，相当于c语言的p++
LDMEA LDMDB                           ;装载前减小值，相当于C语言的++*p
LDMFA LDMDA                           ;装载后减小值，相当于C语言的*p++
STMFA STMIB                              ;存储前增加地址
STMEA STMIA                             ;存储后增加地址
STMFD STMDB                            ;存储前增加值
STMED STMDA                           ;存储后增加值
```

多数据传送指令用在大量数据传送场合， 充分利用了RISC体系多寄存器的优点。

## ARM的结构

基于ARM的芯片有许多， 功能结构也不同， 但是最基本的是ARM核。 

### ARM 体系结构的命名方法

ARM体系结构的命名可以分成两部分，一部分是ARM体系版本的命名， 另一部分是ARM体系版本的处理器命名。

#### ARM体系结构指令集列表

| 指令集缩写 | 含义                 |
| ---------- | -------------------- |
| T          | Thumb指令集          |
| J          | 支持Java加速器       |
| M          | 长乘法指令集         |
| SIMD       | 多媒体功能扩展指令集 |
| E          | 增强 DSP 指令集      |

在同一个版本的ARM体系下，可以支持不同的指令集。

#### ARM处理器功能命名列表

| 功能缩写 | 含义                    |
| -------- | ----------------------- |
| T        | 支持 Thumb 指令集       |
| E        | 支持增强 DSP 指令       |
| D        | 支持片上调试            |
| J        | 支持 Java 程序加速      |
| M        | 支持快速乘法器          |
| F        | 支持浮点运算单元        |
| I        | 支持嵌入式 ICE 调试     |
| -S       | 综合版本， 支持所有功能 |

>    ARM7TD阳表示基于ARM 内核的第7个版本， 支持Thumb指令集、 片上调试、 快速乘法器， 以及嵌入式ICE调试； 三星的S3C2440A芯片是ARM920T-S类型的处理器， 表示ARM核版本是 9， 支持所有的功能。

### 处理器工作模式

ARM微处理器的两种工作状态：Thumb状态和ARM状态。 

Thumb状态就是一种执行Thumb指令集的状态， 这种状态下指令都是16位的， 并且是双字节对齐的。

ARM状态下执行32位的ARM指令。 

ARM微处理器可以在工作中随时切换状态。

ARM体系要求在处理器启动的时候应该处于ARM状态。 ARM处理器使用操作寄存器的 0 位表示工作状态， 取值是l时代表Thumb状态， 取值是0时代表ARM 状态。 可以使用BX指令切换状态。 当处理器启动的时候操作寄存器取值为0， 保证了默认进入ARM状态。

#### ARM 处理器的工作模式

| 工作模式名称           | 含义                                    |
| ---------------------- | --------------------------------------- |
| 用户模式（usr)         | 正常的程序执行状态                      |
| 快速中断模式（fiq)     | 高速数据传输和通道处理                  |
| 外部中断模式（irq)     | 通用中断处理                            |
| 管理模式（svc)         | 操作系统使用（相当于x86体系的保护模式） |
| 数据访问终止模式（abt) | 虚拟内存和存储保护使用                  |
| 系统模式（sys)         | 运行具有特权的操作系统任务              |
| 未定义模式（und)       | 执行了不存在的指令进入该模式            |

系统软件和外部中断都可以改变ARM处理器的工作模式。 应用程序运行在用户模式下， 此时， 一些被保护的资源是不能被用户访问的。 除用户模式外， 另外6种模式都称做特权模式。 特权模式的响应代码由操作系统提供， 用户是不能直接访问的。 

<u>**ARM处理器收到异常后， 把当前模式下一条指令的地址存入LR寄存器，把CPSR寄存器内容复制到SPSR寄存器中，然后根据异常类型设置CPSR的运行模式， 处理器进入对应的异常模式。 异常处理结束后，处理器把LR寄存器保留的指令地址写回PC寄存器，然后复制SPSR内容到CPSR寄存器。 如果异常处理程序设置了中断屏蔽， 则需要清除。 经过这些步骤， 处理器返回异常处理前的工作模式。**</u>

### 存储系统

嵌入式微处理器大多采用一种线性的存储管理方式，ARM也是如此。 

系统内所有的存储器和外部设备都被安排到一个统一的地址空间内， 通过地址映射到不同的设备， 在访问某个设备时， 只需要访问该设备映射的内存地址即可。 线性地 址空间便于处理器的管理和用户操作。

在操作超过8位的数据时， 存在两种不同的访问方法： 大字端模式和小字端模式。 

两种模式的区别是读取数据的先后顺序不同。大字端模式第1字节数据在高位， 小字端正好相反。 通常， 在网络上传输的数据都采用大字端模式， 使用这种方式也称做网络序；此外， 把小字端称做主机序。

MMU( Memory Manager Unit，内存管理单元）。ARM用了线性地址空间， 当一个程序访问外部设备时， 是通过访问一个内存地址实现的。

ARM处理器中还有一项FCSE ( Fast Context Switch Extension）快速上下文切换的技术。 该技术的特点是通过修改系统中不同进程的虚拟地址， 避免了进程切换中物理地址和虚拟地址的映射， 提高了进程的切换速度。 

### 寻址方式

寻址就是根据指令中的地址码找出操作数地址的过程， 是计算机中很重要的一个部分。 对编写程序来说， 不同的寻址方式是存取速度和存取空间权衡的一个考虑因素。

#### 立即寻址

立即寻址方式中操作数已经写在了指令里面， 取出指令时会把操作数也取出来。 这是 最简单的寻址方式。 

```
SUBS R0, R0, #1            ；R0减一写回R0
MOV R0, #0xff00         ；给 R0 赋值0xff00
```

立即寻址使用 “ ＃ ”表示数值。

#### 寄存器寻址方式

该寻址方式中， 操作数存放在寄存器中， 指令直接读取寄存器即得到操作数。

```
MOV R1, R2              ；把R2的值赋给R1
SUB R0, R1, R2         ；把R1-R2的值写入R0
```

#### 寄存器偏移寻址

该寻址方式把寄存器的值移位得到结果。 

```
MOV R0, R1, LSL #3                        ；把R1的值左移3位写入R0，即R0=R1*8
ANDS R0， R1， R2， LSL #R3        ；把R2的值左移R3位，然后与R1做与操作，结果写入R0
```

#### ARM处理器支持的移位操作

| 操作名称                                                 | 功能                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| LSL ( Logical Shift Left）逻辑左移                       | 寄存器的二进制位从右往左移动， 空出的位补0。                 |
| LSR ( Logical Shift Right）逻辑右移                      | 寄存器的二进制位从左往右移动， 空出的位补0                   |
| ASR (Arithmetic Shift Right）算术右移                    | 移位过程中保持符号位不变， 即如果源操作数为正数，贝lj字的高端空出的位补 0，否则补 l |
| ROR (Rotate Right）循环右移                              | 寄存器的低端移出的位填入手的高端空町的位                     |
| RRX ( Rotate Right eXtended by I place) 带扩展的循环右移 | 操作数右移一位，高端空出的位用原C标志值填充                  |

#### 寄存器间接寻址

该方式把寄存器的值当做地址， 然后从对应的内存中取出数据。

```
LDR R0, [R1]                     ；把R1的值当做地址，从内存中取出数据存放到R0
SWP R0, R0, [R1]              ；把Rl的值当做地址， 从内存中取出数据与RO交换
```

#### 基址寻址

该方式把寄存器的内容与指定的偏移相加， 得到数据地址， 然后从内存取得数据。

```
LDR R0,[R1,#0xf]      ;把R1的数值与Oxf相加得到数据地址
STR R0, [R1, #-2]     ;把R1的数值减去2得到数据地址
```

#### 多寄存器寻址

该方式允许一次可以传输多个寄存器的值。

```
LDMIA R1!,{R2-R7,R12}  ;把R1单元中的数据读出到R2～R7和R12,Rl指定的地址自动加l
STMIA R0!,{R3-R6,R10}  ;把R3～R6和R1O中的数据保存到R0指向的地址，R0的地址自动加1
```

#### 栈寻址

校是一个特殊的数据结构， 数据采取 “ 先进后出 ” 的方式。找寻址通过一个战指针寄存器寻址。 

```
STMFD SP!,{R0~R7,LR}   ;把R0～R7和LR的内容压入堆栈
LDMFD SP!,{RO~R7,LR}   ;从堆栈中取出数据到R0～R7和LR
```

## ARM的功能选型

### ARM 的选型原则

#### ARM核心

使用 Windows CE或者Linux之类的操作系统可以减少开发时间， 但是至少需要选择ARM720T以上并且带有MMU C内存管理单元） 的芯片，ARM920T、 ARM922T等核心的芯片都可 以很好地支持Linux。

#### 时钟控制器

ARM芯片的处理能力由时钟速度起决定作用。

不同的处理器时钟处理方式也不同， 在一个处理器上可以有一个或者多个时钟。 
一般来说，处理器的时钟频率越高， 处理能力也越强。

#### 内部存储器

许多ARM芯片都带有内部存储器FLASH和RAM。 带有内部存储器的芯片， 无论是安装还是调试都很方便， 而且减少了外围器件， 降低了成本。

##### 常见几种ARM芯片内部容量列表

| 芯片型号   | 供应商  | FLASH容量/B | RAM容量/B |
| ---------- | ------- | ----------- | --------- |
| AT91FR4081 | ATMEL   | 1M          | 128K      |
| SAA7750    | Philips | 384K        | 64K       |
| HMS30C7202 | Hynix   | 192K        | 无        |
| LC67F500   | Snayo   | 640K        | 32K       |

####  中断控制器

标准的ARM核仅支持快速中断(FIQ)和标准中断(IRQ)两种中断。

#### GPIO

GPIO的数量也是一个重要指标。嵌入式微处理器主要用来处理各种外围设备数据，如果一个芯片支持较多的GPIO引脚，无疑对用户的开发和以后扩展都留有很大余地。

#### 实时钟RTC

RTC是英文Real Time Clock的简称，称为实时钟控制器。

用户可以通过RTC控制器的数据寄存器直接得到当前的日期和时间。

#### 串行控制器

串行通信是嵌入式开发必备的 个功能。用户在开发的时候都需要用到串口， 查看调试输出信息， 甚至提供给客户的命令行界面也都是通过串口控制的。 几乎所有的ARM芯片都集成了UART控制器， 用于支持串口操作。

#### WatchDog

目前， 几乎所有的ARM芯片都提供了看门狗计数器， 操作也很简单。

#### 电源管理功能

一般的芯片都有省电模式、 睡眠模式和关闭模式。

#### DMA控制器

直接访问硬盘等外部高速数据设备。

#### $I^2C$接口

$I^2C$是常见的一种芯片间的通信方式。

#### ADC和DAC控制器

有的ARM芯片集成了ADC和DAC控制器，可以方便地与处理模拟信号的设备互联。

模数转换器(ADC)，将模拟信号转换成数字信号。

数模转换器(DAC)，将数字信号转换成模拟信号。

#### LCD控制器

提供界面。如果需要向客户提供一个LCD屏界面，选择一个带有LCD控制器的芯片可以极大地降低开发成本。

#### USB 接口

USB ( Universal Serial Bus，通用串行总线）是目前最流行的数据接口。在嵌入式产品中提供一个USB接口很大程度上方便了用户的数据传输。许多ARM芯片都提供了USB 控制器，有些芯片甚至同时提供了USB主机控制器和USB设备控制器，例如S3C2440A处理器。

#### $I^2S$接口

$I^2S$是Integrate Interface of Sound的简称，中文意思是集成音频接口。使用该接口可以把解码后的音频数据输出到音频设备上。如果是开发音频类产品，例如MP3这个接口是必需的。

### 几种常见的ARM核处理器选型参考

#### Intel的IXP处理器

IXP系列处理器是Intel推出的针对网络处理的嵌入式芯片。该芯片基于ARMS内核， 并且专门为网络应用设计的微引擎用于网络数据包转发。

#### Philips的LPC处理器

LPX21XX系列处理器是飞利浦公司推出的基于ARM7TDMI内核的微控制器。其特点是体积小， 集成了丰富的外部设备控制器， 并且具有很强的处理和控制功能， 在测量和工业控制领域有很多应用。

#### 三星的S3C244X处理器

三星的S3C244X系列处理器是基于ARM920T内核的嵌入式微处理器。该处理器集成 了丰富的外部控制器和多种总线， 在消费类电子领域有广泛应用。

# 嵌入式Linux

## 常见的嵌入式操作系统

嵌入式操作系统， 通俗地说就是为嵌入式系统设计的操作系统， 是运行在嵌入式硬件上的 类系统软件。 嵌入式系统负责管理系统资源， 为用户提供调用接口， 方便用户应用程序开发。 

嵌入式操作系统是由启动程序（Boot loader）、 核心（ Kernel）、 根文 件系统（ Root File System）组成的。 通过特殊的烧录工具把编译好的嵌入式系统文件映像烧写到目标板的只读存储器(ROM）或者 Flash存储器中。

### VxWorks 

VxWorks 是美国 WindRiver 公司（国内也称做风河公司）开发的高性能实时嵌入式操作系统。 其特点是使用了自己开发的WIND内核， 有着很高的实时性能。 该系统支持多种处理器， 包括 PowerPC、 x86、 MIPS、 ARM 等， 内核具备很好的裁剪能力， 支持应用程序
动态下载和链接。 

VxWorks 系统内核是由进程管理、存储管理、 设备管理、 文件管理、 网络协议等组成。内核占用很小的存储􀂇间， 最小的W卧ID内核可以配置到编译后仅有十几KB大小。 精炼的内核保证了优异的实时性能。

### Windows CE

Windows CE 是微软公司为嵌入式产品设计的一种嵌入式操作系统，主要针对需要多线程、 多任务而且资源有限的设备。 该系统采用模块化设计， 开发人员可以定制不同的功能。 Windows CE 系统支持丰富的外部硬件设备， 包括键盘、 鼠标、 触摸板、 串口、 网 口、 USB、音频设备等。 并且该系统有与 Windows 一致的图形界面， 可以很好地提高用户体验。

### PalmOS

Palm 是 3Com 公司开发的一种掌上电脑产品。 PalmOS 是为该掌上电脑专门设计的一 种 32 位嵌入式操作系统。

Palm OS 最大限度地考虑了节能和硬件资源问题， 提供了良好的电源管理功能和合理的内存管理功能。Palm 设备的内存都是可读写的 RAM，所以访问速度非常快。此外 PalmOS还有很强的同步能力， 可以与 PC 同步数据。

### Symbian

Symbian OS 中文名称叫做塞班系统， 是由诺基亚、 索尼爱立信、 摩托罗拉等几家移动通信设备制造商联合设计的嵌入式操作系统。 塞班系统主要针对于机， 设计目标是简单易用。

塞班系统有一个强大的核心， 支持对象导向系统和Sun Java语言。 该系统的应用程序主要使用C＋＋和Java开发， 从应用开发角度来说， 可以缩短开发周期。 塞班系统本身支持 多种外部设备， 而且为厂商和用户留有丰富的接口并且提供了开发工具。

## **Linux 是什么与如何学习**

### **Linux** **是什么**

Linux系统是一个免费使用的类似UNIX的操作系统， 最初运行在x86体系结构， 目前己经被移植到数十种处理器上。

由于不同的硬件他的功能函数并不相同，例如 IBM 的 Power CPU 与 Intel 的 x86 架构就是不一样！所以同一套操作系统是无法在不同的硬件平台上面运作的！

如果你想要让 x86 上面跑的那套操作系统也能够在 Power CPU 上运作时，就得要将该操作系统进行修改才行。如果能够参考硬件的功能函数并据以修改你的操作系统程序代码， 那经过改版后的操作系统就能够在另一个硬件平台上面运作了。 这个动作我们通常就称为<u>『软件移植』</u>了！

Linux不仅支持丰富的硬件设备、 文件系统， 更主要的是它提供了完整 的源代码和开发工具，对于嵌入式开发来说， 使用Linux系统可以帮助用户从底层了解嵌入式开发的全过程， 以及一个操作系统内部是如何运作的。 

### GPL 版权协议介绍

GPL是自由软件基金会为促进开放源代码软件发展而设计的一种版权协议。 GPL版权协议规定， 使用该协议的软件作者必须公开全部源代码， 源代码的版权归作者所有。 GPL还规定了使用带有GPL版权协议的软件， 必须公开源代码且遵守GPL版权协议。 从GPL 版权协议可以看出， 它是一种递归的定义， 凡是采用GPL版权协议的软件， 按照协议的规 定无论如何发展． 最终都是开放源代码的。

### Linux发行版

#### Red Hat

当今世界使用数量最多的 Linux 发行版可能就是 Red Hat 公司的 Linux 发行版了。 

Red Hat 公司发行两个系列的 Linux 发行版。其中，Red Hat Enterprise Linux ( RHEL） 是企业版本， 是一种收费的 Linux 发行版；还有一种 Red Hat Fedora Core 是由自由软件社区维护的免费版本。 Red Hat 公司推荐使用RHEL 版本。Red Hat 公司出品的 Linux 发行版的特点是用户数量多，因此在遇到问题时有众多的技术支持资源。 此外， Red Hat 开发了自己的 RPM 软件包管理器， 也是 Linux 系统上使用最多的软件管理器。 读者可以通过网络下载或者到软件商店购买 Red Hat 的发行版。

#### Debian

Debian 是自由软件社区使用最多的发行版。 Debian 的发行可以算是最遵守 GNU 规范的，它的系统把每个版本都分成 stable （稳定版）、 testing （测试版）和 unstable （不稳定版）。 其中，unstable 版包含最新的软件包，但是不保证系统是稳定的，适合桌面用户使用；testing是正在测试的版本， 相对 unstable 稳定： stable 是经过测试的稳定版本， 适合服务器或者软件开发者使用。

#### Ubuntu

Ubuntu 是基于 Debian 的 个 Linux 发行版。 Ubuntu 最大的特点就是继承了 Debian 强 大的软件包管理， 并且安装非常容易。 此外 Ubuntu 的更新速度也比 Debian 要快， 新的软件包很快就被集成到 Ubuntu 系统中。

此外， Ubuntu 的图形界面在 目前主流的 Linux 发行版中也是最完善的， 对桌面用户来说， 安装和使用都非常容易。

### 常见的嵌入式Linux系统

#### RT-Linux嵌入式系统

RT-Linux系统强调的是实时处理能力。

该系统设计的思想是在Linux内核之外设计了一个精巧的内核，把传统的Linux作为一个 应用程序执行。用户程序也可以和传统的内核并列工作，由新设计的实时内核统一调度， 达到了良好的实时性。RT-Linux的设计思想兼顾了实时调度，又保留了Linux内核的强大功能，是一种优秀的嵌入式Linux系统。

#### µClinux嵌入式系统

Linux内核本身支持MMU（内存管理单元），对于一些没有MMU的处理器，Linux 无法在上面工作。µClinux是针对这类没有MMU的处理器设计的，它去掉了传统Linux 内核的MMU功能，并且移植到了多种平台上。

### Linux历史

*    Unix 的前身是由贝尔实验室(Bell lab.)的 Ken Thompson 利用汇编语言写成的， 后来在 1971-1973 年间由Dennis Ritchie 以C 程序语言进行改写，才称为 Unix。
*    1977 年由Bill Joy 释出 BSD (Berkeley Software Distribution)，这些称为Unix-like 的操作系统。
*    1984 年由Andrew Tanenbaum 开始制作Minix 操作系统，该系统可以提供原始码以及软件；
*    1984 年由Richard Stallman 提倡 GNU 计划，倡导自由软件(Free software)， 强调其软件可以『自由的取得、复制、修改与再发行』，并规范出 GPL 授权模式， 任何GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。
*    1991 年由芬兰人Linus Torvalds 开发出Linux 操作系统。简而言之，Linux 成功的地方主要在于：<u>Minix(Unix), GNU, Internet, POSIX 及虚拟团队的产生。</u>

### 总结

操作系统(Operation System)主要在管理与驱动硬件，因此必须要能够管理内存、管理装置、 负责行程管理以及系·    统呼叫等等。因此，只要能够让硬件准备妥当(Ready)的情况， 就是一个健全的操作系统了。

*    符合 Open source 理念的授权相当多，比较知名的如 Apache / BSD / GPL / MIT 等。
*    Linux 本身就是个最阳春的操作系统，其开发网站设立在 http://www.kernel.org，我们亦称 Linux 操作系统最底层的数据为『核心(Kernel)』。
*    从 Linux kernel 3.0 开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本 (MainLine) 为依据， 并提供长期支持版本 (longterm) 来加强某些功能的持续维护。
*    Linux distributions 的组成含有：『Linux Kernel + Free Software + Documentations(Tools) + 可完全安装的程序』所制成的一套完整的系统。
*    常见的 Linux distributions 分类有『商业、社群』分类法，或『RPM、DPKG』分类法
*    学习 Linux 最好从头由基础开始学习，找到一本适合自己的书籍，加强实作才能学会

# **计算机：辅助人脑的好工具**

## 计算机硬件的五大单元

关于计算机的硬件组成部分，其实你可以观察你的桌面计算机来分析一下，依外观来说这家伙主要可分为三部分，分别是：

*    输入单元：包括键盘、鼠标、卡片阅读机、扫描仪、手写板、触控屏幕等等一堆；
*    主机部分：这个就是系统单元，被主机机壳保护住了，里面含有一堆板子、CPU 与主存储器等；
*    输出单元：例如屏幕、打印机等等

整部主机的重点在于中央处理器 (Central Processing Unit, CPU)，CPU 为一个具有特定功能的芯片， 里头含有<u>微指令集</u>，如果你想要让主机进行什么特异的功能，就得要参考这颗 CPU 是否有相关内建的微指令集才可以。

综合上面所说的，我们会知道其实计算机是由几个单元所组成的，包括<u>输入单元、 输出单元、CPU 内部的控制单元、算数逻辑单元与主存储器五大部分</u>。

## 一切设计的起点： CPU 的架构

### **精简指令集 (Reduced Instruction Set Computer, RISC)**

这种 CPU 的设计中，<u>微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳； 但是若要做复杂的事情，就要由多个指令来完成</u>。

CPU 主要例如甲骨文 (Oracle) 公司的 SPARC 系列、 IBM 公司的 Power Architecture (包括 PowerPC) 系列、与安谋公司 (ARM Holdings) 的 ARM CPU 系列等。

目前世界上使用范围最广的 CPU 可能就是 ARM 这种架构

### **复杂指令集(Complex Instruction Set Computer, CISC)**

CISC 在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长， 但每条个别指令可以处理的工作较为丰富。

常见的 CISC 微指令集 CPU 主要有 AMD、Intel、VIA 等的 x86 架构的 CPU。

### 位

所谓的位指的是CPU 一次数据读取的最大量

64 位CPU 代表 CPU 一次可以读写 64bits这么多的数据，32 位 CPU 则是 CPU 一次只能读取 32 位的意思。 

因为 CPU 读取数据量有限制，因此能够从内存中读写的数据也就有所限制。

## 计算机上面常用的计算单位 (容量、速度等)

### **容量单位**

计算机对数据的判断主要依据有没有通电来记录信息，所以理论上对于每一个纪录单位而言，它只认识 0 与 1 而已。0/1 这个二进制的的单位我们称为 bit。

1 Byte = 8 bits

| 进位制 | Kilo | Mega  | Giga  | Tera  | Peta  | Exa   | Zetta |
| ------ | ---- | ----- | ----- | ----- | ----- | ----- | ----- |
| 二进制 | 1024 | 1024K | 1024M | 1024G | 1024T | 1024P | 1024E |
| 十进制 | 1000 | 1000K | 1000M | 1000G | 1000T | 1000P | 1000E |

### **速度单位**

CPU 的指令周期常使用 MHz 或者是 GHz 之类的单位，这个 Hz 其实就是秒分之一。

而在网络传输方面，由于网络使用的是 bit 为单位，因此网络常使用的单位为 Mbps 是 Mbits per second，亦即是每秒多少 Mbit。

## **个人计算机架构与相关设备组件**

### 南北桥

#### 北桥

负责链接速度较快的 CPU、主存储器与显示适配器界面等组件

不过由于北桥最重要的就是 CPU 与主存储器之间的桥接，<u>因此目前的主流架构中， 大多将北桥内存控制器整合到 CPU 封装当中了</u>。

#### 南桥

负责连接速度较慢的装置接口， 包括硬盘、USB、网络卡等等。

### 执行脑袋运算与判断的 CPU

目前(2015)主流的 CPU 都是双核以上的架构了！原本的单核心 CPU 仅有一个运算单元，所谓的多核心则是在一颗 CPU 封装当中嵌入了两个以上的运算核心， 简单的说，就是一个实体的 CPU 外壳中，含有两个以上的 CPU 单元就是了。

不同的微指令集会导致 CPU 工作效率的优劣。

频率就是 CPU 每秒钟可以进行的工作次数。 所以频率越高表示这颗 CPU 单位时间内可以作更多的事情。

#### **CPU** **的工作频率：外频与倍频**

因为所有的设备都得掉透过北桥来连结，因此每个设备的工作频率应该要相同。

但因为 CPU 的指令周期比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。

所谓的外频指的是 CPU 与外部组件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作效能的一个倍数， 两者相乘才是 CPU 的频率速度。

#### **32** **位与** **64** **位的** **CPU** **与总线『宽度』**

CPU 每次能够处理的数据量称为字组大小(word size)， 字组大小依据 CPU 的设计而有 32 位与 64 位。我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的。

#### **CPU** **等级**

由于 x86 架构的 CPU 在 Intel 的 Pentium 系列(1993 年)后就有不统一的脚位与设计，为了将不同种类的 CPU 规范等级，所以就有 i386,i586,i686 等名词出现了。

#### **超线程** **(Hyper-Threading, HT)**

在每一个 CPU 内部将重要的缓存器 (register) 分成两群， 而让程序分别使用这两群缓存器。也就是说，可以有两个程序『同时竞争 CPU 的运算单元』，而非透过操作系统的多任务切换。

### 内存

CPU 所使用的数据都是来自于主存储器(main memory)，不论是软件程序还是数据，都必须要读入主存储器后 CPU 才能利用。 个人计算机的主存储器主要组件为<u>动态随机存取内存</u>(Dynamic Random Access Memory, DRAM)， 随机存取内存只有在通电时才能记录与使用，断电后数据就消失了。因此我们也称这种 RAM 为挥发性内存。

DRAM 根据技术的更新又分好几代，而使用上较广泛的有所谓的 SDRAM 与 DDR SDRAM 两种。

新一代的 PC 大多使用 DDR 内存了。

DDR SDRAM 又依据技术的发展，有 DDR, DDR2, DDR3, DDR4 等等。

####  **多通道设计**

由于所有的数据都必须要存放在主存储器，所以主存储器的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达 64 位，为了要加大这个宽度，因此芯片组厂商就将两个主存储器汇整在一起，如果一支内存可达 64 位，两支内存就可以达到 128 位了，这就是双通道的设计理念。

#### **DRAM** **与** **SRAM**

最为我们所知的就是CPU 内的第二层高速缓存。 我们现在知道 CPU 的数据都是由主存储器提供，但 CPU 到主存储器之间还是得要透过内存控制器。

如果某些很常用的程序或数据可以放置到 CPU 内部的话，那么 CPU 数据的读取就不需要跑到主存储器重新读取了！

因为第二层快取(L2 cache)整合到 CPU 内部，因此这个 L2 内存的速度必须要 CPU 频率相同。 使用DRAM 是无法达到这个频率速度的，此时就需要静态随机存取内存(Static Random Access Memory,SRAM)的帮忙了。 SRAM 在设计上使用的晶体管数量较多，价格较高，且不易做成大容量，不过由于其速度快， 因此整合到 CPU 内成为高速缓存以加快数据的存取是个不错的方式。

#### 只读存储器(ROM)

BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器(Read Only Memory, ROM)。

ROM 是一种非挥发性的内存。另外，BIOS 对于个人计算机来说是非常重要的， 因为他是系统在开机的时候首先会去读取的一个小程序。

BIOS 对计算机系统来讲是非常重要的，因为他掌握了系统硬件的详细信息与开机设备的选择等等。但是计算机发展的速度太快了， 因此 BIOS 程序代码也可能需要作适度的修改才行，所以你才会在很多主板官网找到 BIOS 的更新程序啊！但是 BIOS 原本使用的是无法改写的 ROM ，因此根本无法修正 BIOS 程序代码！为此，现在的 BIOS 通常是写入类似闪存 (flash) 或 EEPROM中。

### 显示适配器

显示适配器又称为 VGA(Video Graphics Array)，他对于图形影像的显示扮演相当关键的角色。

一般对于图形影像的显示重点在于分辨率与颜色深度，因为每个图像显示的颜色会占用掉内存， 因此显示适配器上面会有一个内存的容量，这个显示适配器内存容量将会影响到你的屏幕分辨率与颜色深度。

| 规格         | 宽度     | 速度     | 带宽          |
| ------------ | -------- | -------- | ------------- |
| PCI          | 32  bits | 33  MHz  | 133  MBytes/s |
| PCI  2.2     | 64  bits | 66  MHz  | 533  MBytes/s |
| PCI-X        | 64  bits | 133 MHz  | 1064 MBytes/s |
| AGP  4x      | 32  bits | 66x4 MHz | 1066 MBytes/s |
| AGP  8x      | 32  bits | 66x8 MHz | 2133 MBytes/s |
| PCIe 1.0 x1  | 无       | 无       | 250  MBytes/s |
| PCIe 1.0 x8  | 无       | 无       | 2  GBytes/s   |
| PCIe 1.0 x16 | 无       | 无       | 4  GBytes/s   |

#### 接口

*    D-Sub (VGA 端子)：为较早之前的连接接口，主要为 15 针的连接，为模拟讯号的传输，当初设计是针对传统映像管屏幕而来。 主要的规格有标准的 640x350px @70Hz、1280x1024px @85Hz 及 2048x1536px @85Hz 等。
*    DVI：共有四种以上的接头，不过台湾市面上比较常见的为仅提供数字讯号的 DVI-D，以及整合数字与模拟讯号的 DVI-I 两种。DVI 常见于液晶屏幕的链接， 标准规格主要有： 1920x1200px @60Hz、2560x1600px @60Hz 等。
*    HDMI：相对于 D-sub 与 DVI 仅能传送影像数据，HDMI 可以同时传送影像与声音，因此被广泛的使用于电视屏幕中！计算机屏幕目前也经常都有支持 HDMI 格式！
*    Display port：与 HDMI 相似的，可以同时传输声音与影像。不过这种界面目前在台湾还是比较少屏幕的支持！

### 硬盘与储存设备

计算机系统上面的储存设备包括有：硬盘、软盘、MO、CD、DVD、磁带机、随身碟(闪存)、还有新一代的蓝光光驱等， 乃至于大型机器的局域网络储存设备(SAN, NAS)等等，都是可以用来储存数据的。

#### **硬盘的物理组成**

在硬盘盒里面其实是由许许多多的圆形磁盘盘、机械手臂、 磁盘读取头与主轴马达所组成的

实际的数据都是写在具有磁性物质的磁盘盘上头，而读写主要是透过在机械手臂上的读取头(head)来达成。实际运作时， 主轴马达让磁盘盘转动，然后机械手臂可伸展让读取头在磁盘盘上头进行读写的动作。

#### **磁盘盘上的数据**

由于磁盘盘是圆的，并且透过机器手臂去读写数据，磁盘盘要转动才能够让机器手臂读写。因此，通常数据写入当然就是以圆圈转圈的方式读写

当初设计就是在类似磁盘盘同心圆上面切出一个一个的小区块，这些小区块整合成一个圆形，让机器手臂上的读写头去存取。 这个小区块就是磁盘的最小物理储存单位，称之为<u>扇区</u> (sector)，那同一个同心圆的扇区组合成的圆就是所谓的<u>磁道(track)</u>。 由于磁盘里面可能会有多个磁盘盘，因此在所有磁盘盘上面的同一个磁道可以组合成所谓的<u>磁柱 (cylinder)</u>。

#### **传输界面**

传统磁盘界面包括有 SATA, SAS, IDE 与 SCSI 等等。 若考虑外接式磁盘，那就还包括了 USB, eSATA 等等界面。不过目前 IDE 已经被 SATA 取代，而 SCSI 则被 SAS 取代。

##### **SATA** **界面**

插槽所使用的<u>扁平电缆</u>比较窄小， 而且每个装置需要使用掉一条 SATA 线。因为 SATA 线比较窄小之故，所以对于安装与机壳内的通风都比较好。

| 版本     | 带宽 (Gbit/s) | 速度 (Mbyte/s) |
| -------- | ------------- | -------------- |
| SATA 1.0 | 1.5           | 150            |
| SATA 2.0 | 3             | 300            |
| SATA 3.0 | 6             | 600            |

##### **SAS** **界面**

接口的速度确实比较快。而且还支持例如热拔插等功能，因此，许多的装置连接会以这种接口来链接。

| 版本   | 带宽 (Gbit/s) | 速度 (Mbyte/s) |
| ------ | ------------- | -------------- |
| SAS  1 | 3             | 300            |
| SAS  2 | 6             | 600            |
| SAS 3  | 12            | 1200           |

##### **USB** **界面**

| 版本     | 带宽 (Mbit/s) | 速度 (Mbyte/s) |
| -------- | ------------- | -------------- |
| USB  1.0 | 12            | 1.5            |
| USB  2.0 | 480           | 60             |
| USB  3.0 | 5G            | 500            |
| USB  3.1 | 10G           | 1000           |

##### **固态硬盘** **(Solid State Disk, SSD)**

固态硬盘最大的好处是，它没有马达不需要转动，而是透过内存直接读写的特性，因此除了没数据延迟且快速之外，还很省电。

每秒读写操作次数 (Input/Output Operations Per Second, IOPS)

### 扩充卡与界面

主板上面通常会预留多个扩充界面的插槽， 这些插槽依据历史沿革，包括 PCI/AGP/PCI-X/PCIe 等等

由于 PCIe速度快到太好用了，因此几乎所有的卡都以 PCIe 来设计

### 主板

#### **发挥扩充卡效能须考虑的插槽位置**

卡插在哪个插槽上面效能最好，卡安装在哪个插槽上面，对效能而言也是影响很大

#### **设备** **I/O** **地址与** **IRQ** **中断信道**

一般来说，不能有两个装置使用同一个 I/O 地址， 否则系统就会不晓得该如何运作这两个装置了。而除了 I/O 地址之外，还有个IRQ 中断(Interrupt)。

各装置可以透过 IRQ 中断信道来告知 CPU 该装置的工作情况，以方便 CPU 进行工作分配的任务。

#### **CMOS** **与** **BIOS**

##### CMOS

CMOS 主要的功能为记录主板上面的重要参数， 包括系统时间、CPU 电压与频率、各项设备的 I/O 地址与 IRQ 等，由于这些数据的记录要花费电力，因此主板上面才有电池。

##### BIOS

BIOS 为写入到主板上某一块 flash 或EEPROM 的程序，他可以在开机的时候执行，以加载 CMOS 当中的参数， 并尝试呼叫储存装置中的开机程序，进一步进入操作系统当中。

#### **连接接口设备的接口**

*    PS/2 界面：这原本是常见的键盘与鼠标的接口，不过目前渐渐被 USB 接口取代，甚至较新的主板可能就不再提供 PS/2 界面了；
*    USB 界面：通常只剩下 USB 2.0 与 USB 3.0，为了方便区分，USB 3.0 为蓝色的插槽颜色喔！
*    声音输出、输入与麦克风：这个是一些圆形的插孔，而必须你的主板上面有内建音效芯片时，才会有这三个东西；
*    RJ-45 网络头：如果有内建网络芯片的话，那么就会有这种接头出现。 这种接头有点类似电话接头，不过内部有八蕊线。接上网络线后在这个接头上会有灯号亮起。
*    HDMI：如果有内建显示芯片的话，可能就会提供这个与屏幕连接的界面。这种接口可以同时传输声音与影像， 目前也是电视机屏幕的主流连接接口。

### 电源供应器

因为 Power 的用料不同，电源供应的稳定度也会差很多。

#### **能源转换率**

电源供应器出厂前会有一些测试数据，最好挑选高转换率的电源供应器。 所谓的高转换率指的是『输出的功率/输入的功率』。

## 数字系统

所谓的十进制指的是逢十进一位， 因此在个位数归为零而十位数写成 1。所以所谓的二进制，就是逢二就前进一位的意思。

### 文字编码系统

当我们要写入文件的文字数据时，该文字数据会由编码对照表将该文字转成数字后，再存入文件当中。同样的，当我们要将文件内容的数据读出时，也会经过编码对照表将该数字转成对应的文字后，再显示到屏幕上。

常用的英文编码表为 ASCII 系统，这个编码系统中， 每个符号(英文、数字或符号等)都会占用 1bytes 的记录， 因此总共会有 28=256 种变化。

Unicode 编码系统， 我们常常称呼的UTF8 或万国码的编码

### **软件程序运作**

#### 机器程序与编译程序

计算机只认识 0 与 1 而已，而且计算机最重要的运算与逻辑判断是在 CPU 内部， 而CPU 其实是具有微指令集的。因此，我们需要 CPU 帮忙工作时，就得要参考微指令集的内容， 然后撰写让 CPU 读的懂的脚本给 CPU 执行，这样就能够让 CPU 运作了。

*    需要了解机器语言：机器只认识 0 与 1，因此你必须要学习直接写给机器看的语言！ 这个地方相当的难呢！
*    需要了解所有硬件的相关功能函数：因为你的程序必须要写给机器看， 当然你就得要参考机器本身的功能， 然后针对该功能去撰写程序代码。例如，你要让 DVD 影片能够放映， 那就得要参考 DVD 光驱的硬件信息才行。万一你的系统有比较冷门的硬件，光是参考技术手册可能会昏倒～
*    程序不具有可移植性：每个 CPU 都有独特的微指令集，同样的，每个硬件都有其功能函数。 因此，你为 A 计算机写的程序，理论上是没有办法在 B 计算机上面运作的！而且程序代码的修改非常困难！ 因为是机器码，并不是人类看的懂得程序语言啊！
*    程序具有专一性：因为这样的程序必须要针对硬件功能函数来撰写， 如果已经开发了一支浏览器程序，想要再开发文件管理程序时，还是得从头再参考硬件的功能函数来继续撰写。

### 机器程序与编译程序

#### 操作系统

在早期想要让计算机执行程序就得要参考一堆硬件功能函数，并且学习机器语言才能够撰写程序。 同时每次写程序时都必须要重新改写，因为硬件与软件功能不见得都一致之故。那如果我能够将所有的硬件都驱动， 并且提供一个发展软件的参考接口来给工程师开发软件的话，那发展软件不就变的非常的简单了？那就是操作系统啦！

##### **操作系统核心**(Kernel)

操作系统(Operating System, OS)其实也是一组程序， 这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。

核心主要在管控硬件与提供相关的能力(例如存取硬盘、网络功能、CPU 资源取得等)， 这些管理的动作是非常的重要的，如果使用者能够直接使用到核心的话，万一用户不小心将核心程序停止或破坏， 将会导致整个系统的崩溃！

<u>核心程序所放置到内存当中的区块是受保护的</u>！ 并且开机后就一直常驻在内存当中。

##### **系统呼叫(System Call)**

计算机系统主要由硬件构成，然后核心程序主要在管理硬件，提供合理的计算机系统资源分配(包括

CPU 资源、内存使用资源等等)， 因此只要硬件不同(如 x86 架构与RISC 架构的 CPU)，核心就得要进行修改才行。

为了保护核心，并且让程序设计师比较容易开发软件，因此操作系统除了核心程序之外，通常还会提供一整组开发接口，那就是<u>系统呼叫层</u>。

*    操作系统的核心层直接参考硬件规格写成， 所以同一个操作系统程序不能够在不一样的硬件架构下运作。
*    操作系统只是在管理整个硬件资源，包括 CPU、内存、输入输出装置及文件系统文件。 
*    <u>应用程序的开发都是参考操作系统提供的开发接口， 所以该应用程序只能在该操作系统上面运作而已，不可以在其他操作系统上面运作的。</u>

##### **核心功能**

*    系统呼叫接口(System call interface)

*    程序管理(Process control).

*    内存管理(Memory management)

     系统所有的程序代码与数据都必须要先存放在内存当中。

*    文件系统管理(Filesystem management)

*    装置的驱动(Device drivers)

### **操作系统与驱动程序**

那操作系统该如何驱动这块新的显示适配器？为了克服这个问题，操作系统通常会提供一个开发接口给硬件开发商，让他们可以根据这个接口设计可以驱动他们硬件的『驱动程序』， 如此一来，只要使用者安装驱动程序后，自然就可以在他们的操作系统上面驱动这块显示适配器了。

*    操作系统必须要能够驱动硬件，如此应用程序才能够使用该硬件功能；
*    一般来说，操作系统会提供开发接口，让开发商制作他们的驱动程序；
*    要使用新硬件功能，必须要安装厂商提供的驱动程序才行；
*    驱动程序是由厂商提供的，与操作系统开发者无关。

### 应用程序

应用程序是参考操作系统提供的开发接口所开发出来<u>软件</u>，这些软件可以让用户操作，以达到某些计算机的功能利用。

## 总结

*    计算器的定义为：『接受用户输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的信息』；
*    计算机的五大单元包括：输入单元、输出单元、控制单元、算数逻辑单元、记忆单元五大部分。其中CPU占有控制、算术逻辑单元，记忆单元又包含主存储器与辅助内存；
*    数据会流进/流出内存是 CPU 所发布的控制命令，而CPU 实际要处理的数据则完全来自于主存储器；
*    CPU 依设计理念主要分为：精简指令集(RISC)与复杂指令集(CISC)系统；
*    关于CPU 的频率部分：外频指的是CPU 与外部组件进行数据传输时的速度，倍频则是CPU 内部用来加速工作效能的一个倍数， 两者相乘才是 CPU 的频率速度；
*    新的 CPU 设计中，已经将北桥的内存控制芯片整合到 CPU 内，而 CPU 与主存储器、显示适配器沟通的总线通常称为系统总线。 南桥就是所谓的输入输出(I/O)总线，主要在联系硬盘、USB、网络卡等接口设备；
*    CPU 每次能够处理的数据量称为字组大小(word size)，字组大小依据 CPU 的设计而有 32 位与 64 位。 我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的！
*    个人计算机的主存储器主要组件为动态随机存取内存(Dynamic Random Access Memory, DRAM)， 至于 CPU内部的第二层快取则使用静态随机存取内存(Static Random Access Memory, SRAM)；
*    BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器(Read Only Memory, ROM)；
*    目前主流的外接卡界面大多为 PCIe 界面，且最新为 PCIe 3.0，单信道速度高达 1GBytes/s
*    常见的显示适配器连接到屏幕的界面有 HDMI/DVI/D-Sub/Display port 等等。HDMI 可同时传送影像与声音。·    传统硬盘的组成为：圆形磁盘盘、机械手臂、 磁盘读取头与主轴马达所组成的，其中磁盘盘的组成为扇区、磁道与磁柱；
*    磁盘连接到主板的界面大多为 SATA 或 SAS，目前桌机主流为 SATA 3.0，理论极速可达 600Mbytes/s。
*    常见的文字编码为 ASCII，繁体中文编码主要有 Big5 及 UTF8 两种，目前主流为 UTF8
*    操作系统(Operating System, OS)其实也是一组程序， 这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。
*    计算机主要以二进制作为单位，常用的磁盘容量单位为 bytes，其单位换算为 1 Byte = 8bits。
*    操作系统仅在驱动与管理硬件，而要使用硬件时，就得需要透过应用软件或者是壳程序(shell)的功能， 来呼叫操作系统操纵硬件工作。目前称为操作系统的，除了上述功能外，通常已经包含了日常工作所需要的应用软件在内了。

# **主机规划与磁盘分区**

## **Linux 与硬件的搭配**

### 认识计算机的硬件配备

计算机主机的硬件配备与这部主机未来的功能是很有相关性的

因此目前硬件评论界有所谓的『每瓦效能』的单位， 每瓦电力所发挥的效能越高，当然代表越省电

并非所有的产品都会支持特定的操作系统，这牵涉到硬件开发商是否有意愿提供适当的驱动程序之故。因此，当我们想要购买或者是升级某些计算机组件时，应该要特别注意该硬件是否有针对您的操作系统提供适当的驱动程序， 否则，买了无法使用

### 选择与Linux 搭配的主机配备

较早期的硬件配备也可能由于保存的问题或者是电子零件老化的问题， 导致这样的计算机系统反而非常容易在运作过程中出现不明的当机情况

*    CPU

CPU 只要不是老旧到会让你的硬件系统当机的都能够支持

*    RAM

主存储器是越大越好！事实上在 Linux 服务器中，主存储器的重要性比 CPU 还要高的多！因为如果主存储器不够大， 就会使用到硬盘的内存置换空间(swap)。 而由计算器概论的内容我们知道硬盘比内存的速度要慢的多， 所以主存储器太小可能会影响到整体系统的效能的！

*    Hard Disk

由于数据量与数据存取频率的不同，对于硬盘的要求也不相同。

>    磁盘阵列(RAID)是利用硬件技术将数个硬盘整合成为一个大硬盘的方法，操作系统只会看到最后被整合起来的大硬盘。 由于磁盘阵列是由多个硬盘组成，所以可以达成速度效能、备份等任务。

*    VGA

对于不需要X Window 的服务器来说，显示适配器算是最不重要的一个组件了！你只要有显示适配器能够让计算机启动，那就够了。 但如果需要 X window 系统时，你的显示适配器最好能够拥有 32MB 以上的内存容量。

*    Network Interface Card

网络卡是服务器上面最重要的组件之一了！目前的主板大多拥有内建 10/100/1000Mbps 的超高速以太网络卡。但要注意的是，不同的网络卡的功能还是有点差异。

*    光盘、软盘、键盘与鼠标

### 各硬件装置在 Linux 中的文件名

『在 Linux 系统中，每个装置都被当成一个文件来对待』

在 Linux 这个系统当中，几乎所有的硬件装置文件都在/dev 这个目录内

| 装置                 | 装置在 Linux 内的文件名                                      |
| -------------------- | ------------------------------------------------------------ |
| SCSI/SATA/USB 硬盘机 | /dev/sd[a-p]                                                 |
| USB 快闪碟           | /dev/sd[a-p] (与 SATA 相同)                                  |
| VirtI/O 界面         | /dev/vd[a-p] (用于虚拟机内)                                  |
| 软盘驱动器           | /dev/fd[0-7]                                                 |
| 打印机               | /dev/lp[0-2] (25 针打印机)  /dev/usb/lp[0-15] (USB 界面)     |
| 鼠标                 | /dev/input/mouse[0-15] (通用)  /dev/psaux (PS/2 界面) /dev/mouse (当前鼠标) |
| CDROM/DVDROM         | /dev/scd[0-1] (通用)  /dev/sr[0-1] (通用，CentOS 较常见)  /dev/cdrom (当前 CDROM) |
| 磁带机               | /dev/ht0 (IDE 界面)  /dev/st0 (SATA/SCSI 界面)  /dev/tape (当前磁带) |
| IDE 硬盘机           | /dev/hd[a-d] (旧式系统才有)                                  |

## **磁盘分区**

### 磁盘连接的方式与装置文件名的关系

个人计算机常见的磁盘接口有两种，分别是SATA 与SAS 接口， 目前的主流是 SATA 接口。

正常的实体机器大概使用的都是 /dev/sd[a-] 的磁盘文件名，至于虚拟机环境底下，为了加速，可能就会使用 /dev/vd[a-p] 这种装置文件名

再以 SATA 接口来说，由于 SATA/USB/SAS 等磁盘接口都是使用 SCSI 模块来驱动的， 因此这些接口的磁盘装置文件名都是/dev/sd[a-p]的格式。 所以 SATA/USB 接口的磁盘根本就没有一定的顺序

>    例题：
>
>    如果你的 PC 上面有两个 SATA 磁盘以及一个 USB 磁盘，而主板上面有六个 SATA 的插槽。这两个 SATA 磁盘分别安插在主板上的 SATA1, SATA5 插槽上， 请问这三个磁盘在 Linux 中的装置文件名为何？
>
>    答：
>
>    由于是使用侦测到的顺序来决定装置文件名，并非与实际插槽代号有关，因此装置的文件名如下：
>
>    \1.  SATA1 插槽上的檔名：/dev/sda
>
>    \2.  SATA5 插槽上的檔名：/dev/sdb
>
>    \3.   USB 磁盘(开机完成后才被系统捉到)：/dev/sdc

磁盘的组成主要有磁盘盘、机械手臂、磁盘读取头与主轴马达所组成， 而数据的写入其实是在磁盘盘上面。磁盘盘上面又可细分出扇区(Sector)与磁道(Track)两种单位， 其中扇区的物理量设计有两种大小，分别是 512bytes 与 4Kbytes。

### MSDOS(MBR) 与 GPT 磁盘分区表(partition table)

通常磁盘可能有多个磁盘盘，所有磁盘盘的同一个磁道我们称为磁柱 (Cylinder)， 通常那是文件系统的最小单位，也就是分区槽的最小单位

#### **MSDOS (MBR)** **分区表格式与限制**

 早期的 Linux 系统为了兼容于 Windows 的磁盘，因此使用的是支持 Windows 的 <u>MBR</u>(Master Boot Record, 主要开机纪录区) 的方式来处理开机管理程序与分区表

*    主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有 446 bytes
*    分区表(partition table)：记录整颗硬盘分区的状态，有 64 bytes由于分区表所在区块仅有 64 bytes 容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码。 

当你的操作系统为Windows 时，那么第一到第四个分区槽的代号应该就是 C, D, E, F。当你有资料要写入 F 槽时， 你的数据会被写入这颗磁盘的 301~400 号磁柱之间的意思。

*    其实所谓的『分区』只是针对那个 64 bytes 的分区表进行设定而已！
*    硬盘默认的分区表仅能写入四组分区信息
*    这四组分区信息我们称为主要(Primary)或延伸(Extended)分区槽
*    分区槽的最小单位『通常』为磁柱(cylinder)
*    当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区槽进行数据的处理

##### 分区原因

*    数据的安全性

因为每个分区槽的数据是分开的！所以，当你需要将某个分区槽的数据重整时，例如你要将计算机中Windows 的C 槽重新安装一次系统时， 可以将其他重要数据移动到其他分区槽，例如将邮件、桌面数据移动到D 槽去，那么 C 槽重灌系统并不会影响到 D 槽！ 所以善用分区槽，可以让妳的数据更安全。

*    系统的效能考虑

由于分区槽将数据集中在某个磁柱的区段，例如上图当中第一个分区槽位于磁柱号码 1~100 号，如此一来当有数据要读取自该分区槽时， 磁盘只会搜寻前面 1~100 的磁柱范围，由于数据集中了，将有助于数据读取的速度与效能！所以说，分区是很重要的！

延伸分区的目的是使用额外的扇区来记录分区信息，延伸分区本身并不能被拿来格式化。

##### MBR 主要分区、延伸分区与逻辑分区的特性：

*    主要分区与延伸分区最多可以有四笔(硬盘的限制)
*    延伸分区最多只能有一个(操作系统的限制)
*    逻辑分区是由延伸分区持续切割出来的分区槽；
*    能够被格式化后，作为数据存取的分区槽为主要分区与逻辑分区。延伸分区无法格式化；
*    逻辑分区的数量依操作系统而不同，在 Linux 系统中 SATA 硬盘已经可以突破 63 个以上的分区限制；

#### **GUID partition table, GPT 磁盘分区表**

*    LBA0 (MBR 相容区块)

与 MBR 模式相似的，这个兼容区块也分为两个部份，一个就是跟之前 446 bytes 相似的区块，储存了第一阶段的开机管理程序！ 而在原本的分区表的纪录区内，这个兼容模式仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式之意。

*    LBA1 (GPT 表头纪录)

这个部份纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区 (就是前面谈到的在最后 34 个 LBA 区块) 放置的位置， 同时放置了分区表的检验机制码 (CRC32)，操作系统可以根据这个检验码来判断 GPT 是否正确。若有错误，还可以透过这个纪录区来取得备份的 GPT(磁盘最后的那个备份区块) 来恢复 GPT 的正常运作！

*    LBA2-33 (实际纪录分区信息处)

从 LBA2 区块开始，每个 LBA 都可以纪录 4 笔分区纪录，所以在默认的情况下，总共可以有 4*32 = 128 笔分区纪录喔！因为每个 LBA 有 512bytes，因此每笔纪录用到 128 bytes 的空间，除了每笔纪录所需要的标识符与相关的纪录之外，GPT 在每笔纪录中分别提供了 64bits 来记载开始/结束的扇区号码，因此，GPT 分区表对于单一分区槽来说， 他的最大容量限制就会在『 264 * 512bytes = 263 * 1Kbytes = 233*TB = 8 ZB 』，要注意 1ZB = 230TB 啦！ 

### 开机流程中的 BIOS 与 UEFI 开机检测程序

#### **BIOS** **搭配** **MBR/GPT** **的开机流程**

<u>CMOS</u> 是记录各项硬件参数且嵌入在主板上面的储存器，<u>BIOS</u> 则是一个写入到主板上的一个韧体(再次说明， 韧体就是写入到硬件上的一个软件程序)。

<u>这个 BIOS 就是在开机的时候，计算机系统会主动执行的第一个程序了！</u>

BIOS 会去分析计算机里面有哪些储存设备，我们以硬盘为例，BIOS 会依据使用者的设定去取得能够开机的硬盘， 并且到该硬盘里面去读取第一个扇区的 MBR 位置。MBR 这个仅有 446 bytes 的硬盘容量里面会放置最基本的开机管理程序， 此时 BIOS 就功成圆满，而接下来就是 MBR 内的开机管理程序的工作了。

流程

*    BIOS**：开机主动执行的韧体，会认识第一个可开机的装置；**
*    MBR**：第一个可开机装置的第一个扇区内的主要启动记录区块，内含开机管理程序；**
*    开机管理程序(boot loader)**：一支可读取核心文件来执行的软件；**
     *    提供选单**：用户可以选择不同的开机项目，这也是多重引导的重要功能！**
     *    载入核心文件**：直接指向可开机的程序区段来开始操作系统；**
     *    转交其他 **loader**：将开机管理功能转交给其他 loader 负责。
          *    开机管理程序除了可以安装在 MBR 之外， 还可以安装在每个分区槽的启动扇区(boot sector)
          *    每个分区槽都拥有自己的启动扇区(boot sector)
          *    图中的系统槽为第一及第二分区槽，
          *    实际可开机的核心文件是放置到各分区槽内的！
          *    loader 只会认识自己的系统槽内的可开机核心文件，以及其他 loader 而已；loader 可直接指向或者是间接将管理权转交给另一个管理程序
*    核心文件：开始操作系统的功能...

#### **UEFI BIOS** **搭配** **GPT** **开机的流程**

UEFI (Unified Extensible Firmware Interface) 这个统一可延伸韧体界面

UEFI 使用 C 程序语言，比起使用汇编语言的传统 BIOS 要更容易开发



#### 传统 BIOS 与 UEFI 的差异

| 比较项目               | 传统 BIOS                                                  | UEFI               |
| ---------------------- | ---------------------------------------------------------- | ------------------ |
| 使用程序语言           | 汇编语言                                                   | C  语言            |
| 硬件资源控制           | 使用中断 (IRQ) 管理不可变的内存存取  不可变得输入/输出存取 | 使用驱动程序与协议 |
| 处理器运作环境         | 16  位                                                     | CPU  保护模式      |
| 扩充方式               | 透过 IRQ 连结                                              | 直接加载驱动程序   |
| 第三方厂商支持         | 较差                                                       | 较佳且可支持多平台 |
| 图形化能力             | 较差                                                       | 较佳               |
| 内建简化操作系统前环境 | 不支援                                                     | 支援               |

与 BIOS 模式相比，虽然 UEFI 可以直接取得 GPT 的分区表，不过最好依旧拥有 BIOS boot 的分区槽支持， 同时，为了与 windows 兼容，并且提供其他第三方厂商所使用的 UEFI 应用程序储存的空间，你必须要格式化一个 vfat 的文件系统， 大约提供 512MB 到 1G 左右的容量，以让其他 UEFI 执行较为方便。

### Linux 安装模式下，磁盘分区的选择(极重要)

#### **目录树结构** **(directory tree)**

整个 Linux 系统最重要的地方就是在于目录树架构。 所谓的目录树架构(directory tree)就是以根目录为主，然后向下呈现分支状的目录结构的一种文件架构。 

所以，整个目录树架构最重要的就是那个根目录(root directory)，这个根目录的表示方法为一条斜线『**/**』， 所有的文件都与目录树有关。

所有的文件都是由根目录(/)衍生来的，而次目录之下还能够有其他的数据存在。

#### 文件系统与目录树的关系(挂载)

所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下； 也就是说， 进入该目录就可以读取该分区槽的意思。

这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。

#### **distributions** **安装时，挂载点与磁盘分区的规划**

**强烈建议使用『自定义安装, Custom 』这个安装模式**

*    自定义安装『Custom』
*    建议分区的方法：预留一个备用的剩余磁盘容量

**选择 Linux 安装程序提供的默认硬盘分区方式**

## 主机的服务规划与硬件的关系

### **打造** **Windows** **与** **Linux** **共存的环境**

开机流程与多重引导

### NAT(达成IP分享器的功能)

通常小型企业或者是学校单位大多仅会有一条对外的联机，然后全公司/学校内的计算机全部透过这条联机连到因特网上。

### SAMBA加入Windows网络上的芳邻)

我们可以使用 Linux 上面的 SAMBA 这个软件来达成加入 Windows 网芳的功能。

SAMBA 的效能不错， 也没有客户端联机数的限制，相当适合于一般学校环境的文件服务器(file server)的角色。

这种服务器由于分享的数据量较大，对于系统的网络卡与硬盘的大小及速度就比较重要， 如果你还针对不同的用户提供文件服务器功能，那么/home 这个目录可以考虑独立出来，并且加大容量。

### Mail邮件服务器

在 mail server 上面，重要的也是硬盘容量与网络卡速度，在此情境中，也可以将/var 目录独立出来，并加大容量。

### **Web(WWW 服务器)**

WWW 服务器几乎是所有的网络主机都会安装的一个功能，因为他除了可以提供 Internet 的 WWW 联机之外， 很多在网络主机上面的软件功能(例如某些分析软件所提供的最终分析结果的画面)也都使用 WWW 作为显示的接口。

### **DHCP(提供客户端自动取得 IP 的功能)**

客户端计算机只要选择『自动取得 IP』，其他的，就是你系统管理员在 DHCP 服务器上面设定一下即可。

### **FTP**

对于 FTP 的硬件需求来说，硬盘容量与网络卡好坏相关性较高。

## 主机硬盘的主要规划

所谓的『数据安全』并不是指数据被网络cracker 所破坏， 而是指『当主机系统的硬件出现问题时，你的文件数据能否安全的保存』之意。

硬盘的分区技巧需要对于 Linux 文件结构有相当程度的认知之后才能够做比较完善的规划

*    最简单的分区方法

仅分区出根目录与内存置换空间( / & swap )即可。

*    稍微麻烦一点的方式

先分析这部主机的未来用途，然后根据用途去分析需要较大容量的目录， 以及读写较为频繁的目录，将这些重要的目录分别独立出来而不与根目录放在一起， 那当这些读写较频繁的磁盘分区槽有问题时，至少不会影响到根目录的系统数据

在默认的CentOS 环境中，底下的目录是比较符合容量大且(或)读写频繁的目录啰：

*    boot
*    /
*    /home
*    /var
*    Swap

## 总结

*    新添购计算机硬件配备时，需要考虑的角度有『游戏机/工作机』、『效能/价格比』、『效能/消耗瓦数』、『支持度』等；
*    旧的硬件配备可能由于保存的问题或者是电子零件老化的问题，导致计算机系统非常容易在运作过程中出现不明的当机情况
*    Red Hat 的硬件支持
*    在 Linux 系统中，每个装置都被当成一个文件来对待，每个装置都会有装置文件名。
*    磁盘装置文件名通常分为两种，实际 SATA/USB 装置文件名为/dev/sd[a-p]，而虚拟机的装置可能为/dev/vd[a-p]
*    磁盘的第一个扇区主要记录了两个重要的信息，分别是： (1)主要启动记录区(Master Boot Record, MBR)： 可以安装开机管理程序的地方，有 446 bytes (1)分区表(partition table)：记录整颗硬盘分区的状态，有 64 bytes；
*    磁盘的 MBR 分区方式中，主要与延伸分区最多可以有四个，逻辑分区的装置文件名号码，一定由 5 号开始；
*    如果磁盘容量大于 2TB 以上时，系统会自动使用 GPT 分区方式来处理磁盘分区。
*    GPT 分区已经没有延伸与逻辑分区槽的概念，你可以想象成所有的分区都是主分区！
*    某些操作系统要使用 GPT 分区时，必须要搭配 UEFI 的新型 BIOS 格式才可安装使用。
*    开机的流程由：BIOS-->MBR-->-->boot loader-->核心文件；
*    boot loader 的功能主要有：提供选单、加载核心、转交控制权给其他 loader
*    boot loader 可以安装的地点有两个，分别是 MBR 与 boot sector
*    Linux 操作系统的文件使用目录树系统，与磁盘的对应需要有『挂载』的动作才行；
*    新手的简单分区，建议只要有/及 swap 两个分区槽即可

# Linux主要模块

## 进程调度SCHED

* `SCHED_OTHER`是用于针对`普通进程的时间片轮转调度策略`。这种策略中,系统给所有的运行状态的进程分配时间片。在当前进程的时间片用完之后,系统从进程中优先级最高的进程中选择进程运行。
* `SCHED_FIFO`是针对运行的`实时性要求比较高、运行时间短的进程调度策略`。这种策略中,系统按照进入队列的先后进行进程的调度,在没有更高优先级进程到来或者当前进程没有因为等待资源而阻塞的情况下,会一直运行。
* `SCHED_RR`是针对`实时性要求比较高、运行时间比较长的进程调度策略`。这种策略与SCHED_OTHER的策略类似,只不过SCHED_RR进程的优先级要高得多。系统分配给SCHED_RR进程时间片,然后轮循运行这些进程,将时间片用完的进程放入队列的末尾。

## 内存管理MMU

内存管理是多个进程间的内存共享策略。在Linux系统中,内存管理的主要概念是虚拟内存。

虚拟内存可以让进程拥有比实际物理内存更大的内存,可以是实际内存的很多倍。每个进程的虚拟内存有不同的地址空间,多个进程的虚拟内存不会冲突。

虚拟内存的分配策略是每个进程都可以公平地使用虚拟内存。虚拟内存的大小通常设置为物理内存的两倍。

## 虚拟文件系统VFS

在Linux下支持多种文件系统。目前Linux下最常用的文件格式是ext2和ext3.ext2文件系统用于固定文件系统和可活动文件系统,是ext文件系统的扩展。ext3文件系统是在ext2上增加日志功能后的扩展,它兼容ext2。两种文件系统之间可以互相转换, ext2不用格式化就可以转换为ext3文件系统,而ext3文件系统转换为ext2文件系统也不会丢失数据。

## 网络接口

Linux是在Internet飞速发展的时期成长起来的,所以Linux支持多种网络接口和协议。网络接口分为网络协议和驱动程序,网络协议是一种网络传输的通信标准,而网络驱动则是对硬件设备的驱动程序。Linux支持的网络设备多种多样,几乎目前所有网络设备都有驱动程序。

## 进程间通信

Linux操作系统支持多进程,进程之间需要进行数据的交流才能完成控制、协同工作等功能, Linux的进程间通信是从UNIX系统继承过来的。Linux下的进程间的通信方式主要有管道方式、信号方式、消息队列方式、共享内存和套接字等方法。

# Linux文件结构

与Windows下的文件组织结构不同, Linux不使用磁盘分区符号来访问文件系统,而是将整个文件系统表示成`树状的结构`, Linux系统每增加一个文件系统都会将其加入到这个树中

操作系统文件结构的开始,只有一个单独的顶级目录结构,叫做`根目录`。所有一切都从“根”开始,用"/"代表,并且延伸到子目录。DOS/Windows下文件系统按照`磁盘分区`的概念分类,目录都存于分区上。Linux则通过“`挂接`”的方式把所有分区都放置在“根”下各个目录里。一个Linux系统的文件结构如图1.1所示。不同的Linux发行版本的目录结构和具体的实现功能存在一些细微的差别。但是主要的功能都是一致的。一些常用目录的作用如下所述。

| 目录  | 作用                                                         |
| ----- | ------------------------------------------------------------ |
| /etc  | 包括绝大多数Linux系统引导所需要的配置文件,系统引导时读取配置文件,按照配置文件的选项进行不同情况的启动 |
| /lib  | 包含C编译程序需要的函数库,是一组二进制文件,例如glibc等;      |
| /usr  | 包括所有其他内容,如src. local, Linux的内核就在/usr/src中     |
| /var  | 包含系统定义表,以便在系统运行改变时可以只备份该目录          |
| /tmp  | 用于临时性的存储                                             |
| /bin  | 大多数命令存放在这里                                         |
| /home | 主要存放用户账号,并且可以支持ftp的用户管理。系统管理员增加用户时,系统在home 目录下创建与用户同名的目录,此目录下一般默认有Desktop目录; |
| /dev  | 这个目录下存放一种设备文件的特殊文件,如fa0,had等;            |
| /mnt  | 在Linux系统中,它是专门给外挂的文件系统使用的,里面有两个文件cdrom, floopy,登录光驱、软驱时要用到。 |

## Linux下文件的内涵

- 普通文件:例如保存在磁盘上的C文件、可执行文件,以及目录等,这种文件的特性是数据在存储设备上存放,内核提供了对数据的抽象访问,此种文件为一种字节流,访问接口完全独立于在磁盘上的存储数据。
- 字符设备文件:是一种能够像文件一样被访问的设备,例如控制台、串口等。
- 块设备文件:磁盘是此类设备文件的典型代表,与普通文件的区别是操作系统对数据的访问进行的重新的格式设计。
- socket文件:它是Linux中通过网络进行通信的方式,对网络的访问可以通过文件描述符的抽象实现,访问网络和访问普通文件相似。

### 文件系统的创建

#### 系统分区情况

使用fdisk命令查看当前磁盘的情况

```
fdisk -1
```

![image-20210825185657989](Linux%E7%B3%BB%E7%BB%9F.assets/image-20210825185657989.png)

#### 建立分区

可以看到,磁盘/dev/sdb没有使用,现在尝试用fdisk在没有使用的磁盘/dev/sdb上进行分区,先查看分区情况,然后建立一个100M大小的初级分区,将分区表写入磁盘并退出:

```
fdisk /dev/sdb
```

#### 使用mkfs格式化分区sdbl

```
mkfs.ext4 /dev/sdb1
```

#### 挂载分区

建立一个/test目录,将sdb1挂接上去。

```
mount /dev/sdb1 /test
```

#### 查看分区挂载情况

```
df
```

### 挂接文件系统

Linux系统下,要使用一个文件系统需要先将文件系统的分区挂载到系统上。mount命令用于挂载文件,它有很多选项。mount命令的使用格式为:

```c
mount -t type mountpoint device -o options
```

上述命令表示将文件类型为type的设备device挂载到mountpoint上,挂载时要遵循options的设置。

### 索引节点inode

在Linux下存储设备或存储设备的某个分区格式化为文件系统后,有两个主要的概念来描述它,一个是索引节点(inode),另一个是块(Block),块是用来存储数据的,索引节点则是用来存储数据的信息,这些信息包括文件大小、属主、归属的用户组、读写权限等。索引节点为每个文件进行信息索引,所以就有了索引节点的数值。

要查看索引节点的信息,可以使用命令ls,加上参数-i,例如,使用1s查看hello.c的索引节点信息,可知索引节点的值为1050150.

```
ls -li hello.c
```

在Linux的文件系统中,索引节点值是文件的标识,并且这个值是唯一的,两个不同文件的索引节点值是不同的,索引节点值相同的文件它的内容是相同的,仅仅文件名不同。修改两个索引节点值相同的文件中的一个文件,另一个文件的内容也跟着发生改变。

`索引节点值相同的文件,二者的关系是互为硬链接。`当修改其中一个文件的内容时,互为硬链接的文件内容也会跟着变化。如果删除互为硬链接关系的某个文件时,其他的文件并不受影响。例如把hell02.c删除后,还是一样能看到hello.c的内容,并且hello.c仍是存在的。这是由于索引节点对于每一个文件有一个引用计数,当创建硬链接的时候,引用计数会增加1,删除文件的时候引用计数会减1,当引用计数为0的时候,系统会删除此文件。

`目录不能创建硬链接,只有文件才能创建硬链接。`如果目录也可以创建硬链接,很容易在系统内部形成真实的环状文件系统,对文件系统的维护造成很大的困难。目录可以使用软链接的方式创建,可使用命令"In-"

### 普通文件

普通文件是指在硬盘、CD, U盘等存储介质上的数据和文件结构。在本节中所指的文件系统是一个狭义的概念,仅仅按照普通文件在磁盘中组织方式的不同来区分。普通文件的概念与Windows下面文件的概念是相同的。可以对文件进行打开、读出数据、写入数据、关闭、删除等操作。在Linux下, 目录也作为一种普通文件存在。

### 设备文件

Linux下用设备文件来表示所支持的设备,每个设备文件除了设备名,还有3个属性,即类型、主设备号、次设备号。

* 设备类型:设备属性的第一个字符是这个设备文件的类型。第一个字符为c,表明这个设备是一个字符设备文件。第一个字符为b,表明这个设备是一个块设备文件。sdb1的第1个字符为b,可知它是一个块设备文件。
* 主设备号:每一个设备文件都有一个“主设备号” ,使用ls -l命令输出的第5个字段即为主设备号。`主设备号是表示系统存取这个设备的“内核驱动”`。驱动程序是Linux内核中代码的一部分,其作用是用来控制一种特殊设备的输入输出。大多数的Linux操作系统都有多种设备驱动程序;每一个设备文件名中的主设备号就代表这个设备使用的是那个设备驱动程序。Isdev命令可以列出当前内核中配置的驱动程序和这些驱动程序对应的主设备号。
* 次设备号:每一个设备文件都有一个次设备号。“次设备号”是一个24位的十六进制数字,它`定义了这个设备在系统中的物理位置`。
* 设备文件名:设备文件名用于表示设备的名称,它遵循标准的命令方式,使得设备的分辨更容易。

#### 字符设备与块设备

`字符类型的设备可以在一次数据读写过程中传送任意大小的数据,多个字符的访问是通过多次读写来完成的,通常用于访问连续的字符。`

`块设备文件可以在一次读写过程中访问固定大小的数据,通过块设备文件进行数据读写的时候,系统先从内存的缓冲区中读写数据,而不是直接与设备进行数据读写,这种访问方式可以大幅度地提高读写性能。`块类型设备可以随机地访问数据,而数据的访问时间和数据位于设备中的位置无关。常用的块设备有硬盘、软盘和CD-ROM及RAM类型磁盘。

#### 设备文件的创建

设备文件是通过mknod命令来创建的。其命令格式为:

```
mknod [OPTION]... NAME TYPE [MAJOR MINOR]
```

其参数有设备文件名NAME、操作模式TYPE、主设备号MAJOR及次设备号MINOR.主设备号和次设备号两个参数合并成一个16位的无符号短整数,高8位表示主设备号,低8位表示次设备号。可以在include/Linux/major.h文件中找到所支持的主设备号。

### 虚拟文件系统VFS

Linux的文件系统是由虚拟文件系统作为媒介搭建起来的,虚拟文件系统VFS (VirtualFile Systems)是Linux内核层实现的一种架构,为用户空间提供统一的文件操作接口。它在内核内部为不同的真实文件系统提供一致的抽象接口。

![image-20210827205723679](Linux%E7%B3%BB%E7%BB%9F.assets/image-20210827205723679.png)

VFS是文件系统的接口框架。这个组件导出一组接口,然后将它们抽象到各个文件系统,各个文件系统的具体实现方式差异很大。有两个针对文件系统对象的缓存(inode和dentry),它们缓存的对象是最近使用过的文件系统。

#### 文件系统类型

Linux的文件系统用一组通用对象来表示,这些对象是超级块(superblock)、节点索引 (inode)、目录结构(dentry)和文件(file)

超级块是每种文件系统的根,用于描述和维护文件系统的状态。文件系统中管理的每个对象(文件或目录)在Linux中表示为一个索引节点inode.

inode包含管理文件系统中的对象所需的所有元数据(包括可以在对象上执行的操作)。另一组结构称为dentry,它们用来实现名称和inode之间的映射,有一个目录缓存用来保存最近使用的dentry

dentry还维护目录和文件之间的关系,支持目录和文件在文件系统中的移动。VFS文件表示一个打开的文件(保存打开的文件的状态,像文件的读偏移量和写偏移量等)

```c
struct file_system_types{
    const char *name;/*文件类型名称*/
    int fs_flags;/*标志*/
    struct super_block *(*read_super) (struct super_block *,void *,int);/*读超级块函数*/
    struct module *owner;/*所有者*/
    struct file_system_type *next;/*下一个文件类型*/
    struct list_head fs_supers;/*头结构*/
}
```

可以使用一组注册函数在Linux中动态地添加或删除文件系统。Linux的内核中保存系统所支持的文件系统的列表,可以通过/proc文件系统在用户空间中查看这个列表。虚拟文件系统还显示当前系统中与文件系统相关联的具体设备。在Linux中添加新文件系统的方法是调用register filesystem。这个函数的参数定义一个文件系统结构(file system type)的引用,这个结构定义文件系统的名称、一组属性和两个超级块函数,也可以注销文件系统。

可以使用一组注册函数在Linux中动态地添加或删除文件系统。Linux的内核中保存系统所支持的文件系统的列表,可以通过/proc文件系统在用户空间中查看这个列表。虚拟文件系统还显示当前系统中与文件系统相关联的具体设备。在Linux中添加新文件系统的方法是调用register_filesystem。这个函数的参数定义一个文件系统结构(file_system_type)的引用,这个结构定义文件系统的名称、一组属性和两个超级块函数,也可以注销文件系统。

#### 超级块

超级块结构用来表示一个文件系统,结构如下:

```c
struct super_block{
    ...
    unsigned long long s_maxbytes;/*最大文件尺寸*/
    struct file_system_type *s_type;/*文件类型*/
    const struct super_operations *s_op;/*超级块的操作，主要是
    ...
    char s_id[32];
}
```

超级块中的一个重要元素是超级块操作函数的定义。这个结构定义一组用来管理这个文件系统中的节点索引inode的函数。例如,可以使用函数alloc_inode()来分配inode,用函数destroy_inode()删除inode。可以用read_inode()和write_inode()读写inode,用syn_cfs()执行文件系统同步。可以在Linux的源代码树的文件Linux/include/Linux/fs.h中找到super_operations结构。Linux文件系统中所支持的每个文件系统都实现一套自己的inode操作方法,这些方法实现超级块所定义的功能并向VFS层提供通用的抽象。

#### 文件操作

![image-20210827213826076](Linux%E7%B3%BB%E7%BB%9F.assets/image-20210827213826076.png)

## 文件的通用操作方法

### 文件描述符

在Linux下用文件描述符来表示设备文件和普通文件。文件描述符是一个整型的数据,所有对文件的操作都通过文件描述符实现。文件描述符是文件系统中连接用户空间和内核空间的枢纽。当打开一个或者创建一个文件时,内核空间创建相应的结构,并生成一个整型的变量传递给用户空间的对应进程。进程用这个文件描述符来对文件进行操作。用户空间的文件操作,例如读或写一个文件时,将文件描述符作为参数传送给read或write。读写函数的系统调用到达内核时,内核解析作为文件描述符的整型变量,找出对应的设备文件运行相应的函数,并返回用空间结果。文件描述符的范围是0~OPEN_MAX,因此是一个有限的资源,在使用完毕后要及时释放,通常是调用close()函数关闭。文件描述符的值仅在同一个进程中有效,即不同进程的文件描述符,同一个值很可能描述的不是同一个设备或者普通文件。

在Linux系统中有3个已经分配的文件描述符,即标准输入、标准输出和标准错误,它们文件描述符的值分别为0、1和2,读者可以查看/dev/下的stdin (标准输入)、stdout(标准输出)和stderr(标准错误),会发现分别指向了/proc/self/fd/目录下的0、1、2文件。

### 打开创建文件open()、 create()函数

在Linux 下, open()函数用于打开一个已经存在的文件或者创建一个新文件, create)函数用于创建一个新文件。

#### 函数open()、 create()介绍

这两个函数的原型如下,根据用户设置的标志flags和模式mode在路径pathname下建立或者打开一个文件。

```c
int open(const char *pathname,int flags);
int open(const char *pathname,int flags,mode_t mode);
```

open()函数打开pathname指定的文件,当函数成功时,返回一个整型的文件描述符。这个函数正常情况下会返回一个文件描述符的值,在出错的时候会返回-1

打开文件的时候需要指定打开的文件路径,这个参数由pathname指定。函数会根据这个参数的值在路径中查找文件并试图打开或者建立文件。 pathname所指的为一个字符串变量,这个变量的长度在不同的系统下其最大长度有差别,通常情况下为1024个字节。当所给的路径长度大于这个数值的时候,系统会对字符串进行截断,仅选择最前面的字节进行操作。

文件的打开标志flags用于设置文件打开后允许的操作方式,可以为只读、只写或读写。分别用O_RDONLY (只读)、 O_WRONLY (只写)和O_RDWR(读写)表示。在打开文件的时候必须指定上述的三种模式之一。三个参数中O_RDONLY通常定义为0,0_WRONLY定义为1, O_RDWR定义为2.

参数flags除了上述三个选项之外,还有一些可选的参数。

* O_APPEND选项:使每次对文件进行写操作都追加到文件的尾端。
* O_CREAT:如果文件不存在则创建它,当使用此选择项时,第三个参数mode需要同时设定,用来说明新文件的权限。
* O_EXCL:查看文件是否存在。如果同时指定了O_CREAT,而文件已经存在,会返回错误。用这种方法可以安全地打开一个文件。
* O_TRUNC:将文件长度截断为0,如果此文件存在,并且文件成功打开,则会将其长度截短为0

![image-20210827221313433](Linux%E7%B3%BB%E7%BB%9F.assets/image-20210827221313433.png)



# GCC

## 文件扩展名意义

![image-20210825180345561](Linux%E7%B3%BB%E7%BB%9F.assets/image-20210825180345561.png)

![image-20210825180400178](Linux%E7%B3%BB%E7%BB%9F.assets/image-20210825180400178.png)

## 编译程序

### 单个文件编译成执行文件

```
gcc hello.c
```

如果希望生成指定的可执行文件名,选项-o可以使编译程序生成指定文件名,例如将上述程序编译输出一个名称为test的执行程序:

```
gcc -o test hello.c
```

### 编译生成目标文件

GCC的-c选项用于生成目标文件,这一选项将源文件生成目标文件,而不是生成可执行文件。默认情况下生成的目标文件的文件名和源文件的名称一样,只是扩展名为.o。例如,下面的命令会生成一个名字为hello.o的目标文件:

```
gcc -c hello.c
```

可以用一条命令编译多个源文件,生成目标文件,这通常用于编写库文件或者一个项目中包含多个源文件。

```
gcc -c file1.c file2.c file3.c
```

### 多文件编译

```
gcc -o test string.c main.c
```

### 预处理

编译程序时选项-E告诉编译器进行预编译操作。例如如下命令将文件string.c的预处理结果显示在计算机屏幕上:

```
gcc -E string.c
```

### 编译成汇编语言

生成汇编语言的GCC选项是-S,默认情况下生成的文件名和源文件一致,扩展名为.S.例如,下面的命令将C语言源文件string.c编译成汇编语言,文件名为string.s.

```
gcc -S string.c
```

### 生成和使用静态链接库

#### 生成静态链接库

```
ar -rcs libstr.a string.o
```

#### 使用静态链接库

```
gcc -o test main.c libstr.a
```

### 生成动态链接库

#### 生成动态链接库

```
gcc -shared -W1,-soname,libstr.so -o libstr.so.1 string.c
```



# 附录

## 1. 查询函数

```
linux> man <函数名>
```

## 2. csapp.h&csapp.c

<center>csapp.h

```c
/* $begin csapp.h */
#ifndef __CSAPP_H__
#define __CSAPP_H__

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <errno.h>
#include <math.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>


/* Default file permissions are DEF_MODE & ~DEF_UMASK */
/* $begin createmasks */
#define DEF_MODE   S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH
#define DEF_UMASK  S_IWGRP|S_IWOTH
/* $end createmasks */

/* Simplifies calls to bind(), connect(), and accept() */
/* $begin sockaddrdef */
typedef struct sockaddr SA;
/* $end sockaddrdef */

/* Persistent state for the robust I/O (Rio) package */
/* $begin rio_t */
#define RIO_BUFSIZE 8192
typedef struct {
    int rio_fd;                /* Descriptor for this internal buf */
    int rio_cnt;               /* Unread bytes in internal buf */
    char *rio_bufptr;          /* Next unread byte in internal buf */
    char rio_buf[RIO_BUFSIZE]; /* Internal buffer */
} rio_t;
/* $end rio_t */

/* External variables */
extern int h_errno;    /* Defined by BIND for DNS errors */ 
extern char **environ; /* Defined by libc */

/* Misc constants */
#define	MAXLINE	 8192  /* Max text line length */
#define MAXBUF   8192  /* Max I/O buffer size */
#define LISTENQ  1024  /* Second argument to listen() */

/* Our own error-handling functions */
void unix_error(char *msg);
void posix_error(int code, char *msg);
void dns_error(char *msg);
void app_error(char *msg);

/* Process control wrappers */
pid_t Fork(void);
void Execve(const char *filename, char *const argv[], char *const envp[]);
pid_t Wait(int *status);
pid_t Waitpid(pid_t pid, int *iptr, int options);
void Kill(pid_t pid, int signum);
unsigned int Sleep(unsigned int secs);
void Pause(void);
unsigned int Alarm(unsigned int seconds);
void Setpgid(pid_t pid, pid_t pgid);
pid_t Getpgrp();

/* Signal wrappers */
typedef void handler_t(int);
handler_t *Signal(int signum, handler_t *handler);
void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
void Sigemptyset(sigset_t *set);
void Sigfillset(sigset_t *set);
void Sigaddset(sigset_t *set, int signum);
void Sigdelset(sigset_t *set, int signum);
int Sigismember(const sigset_t *set, int signum);

/* Unix I/O wrappers */
int Open(const char *pathname, int flags, mode_t mode);
ssize_t Read(int fd, void *buf, size_t count);
ssize_t Write(int fd, const void *buf, size_t count);
off_t Lseek(int fildes, off_t offset, int whence);
void Close(int fd);
int Select(int  n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, 
	   struct timeval *timeout);
int Dup2(int fd1, int fd2);
void Stat(const char *filename, struct stat *buf);
void Fstat(int fd, struct stat *buf) ;

/* Memory mapping wrappers */
void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
void Munmap(void *start, size_t length);

/* Standard I/O wrappers */
void Fclose(FILE *fp);
FILE *Fdopen(int fd, const char *type);
char *Fgets(char *ptr, int n, FILE *stream);
FILE *Fopen(const char *filename, const char *mode);
void Fputs(const char *ptr, FILE *stream);
size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

/* Dynamic storage allocation wrappers */
void *Malloc(size_t size);
void *Realloc(void *ptr, size_t size);
void *Calloc(size_t nmemb, size_t size);
void Free(void *ptr);

/* Sockets interface wrappers */
int Socket(int domain, int type, int protocol);
void Setsockopt(int s, int level, int optname, const void *optval, int optlen);
void Bind(int sockfd, struct sockaddr *my_addr, int addrlen);
void Listen(int s, int backlog);
int Accept(int s, struct sockaddr *addr, socklen_t *addrlen);
void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen);

/* DNS wrappers */
struct hostent *Gethostbyname(const char *name);
struct hostent *Gethostbyaddr(const char *addr, int len, int type);

/* Pthreads thread control wrappers */
void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp, 
		    void * (*routine)(void *), void *argp);
void Pthread_join(pthread_t tid, void **thread_return);
void Pthread_cancel(pthread_t tid);
void Pthread_detach(pthread_t tid);
void Pthread_exit(void *retval);
pthread_t Pthread_self(void);
void Pthread_once(pthread_once_t *once_control, void (*init_function)());

/* POSIX semaphore wrappers */
void Sem_init(sem_t *sem, int pshared, unsigned int value);
void P(sem_t *sem);
void V(sem_t *sem);

/* Rio (Robust I/O) package */
ssize_t rio_readn(int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
void rio_readinitb(rio_t *rp, int fd); 
ssize_t	rio_readnb(rio_t *rp, void *usrbuf, size_t n);
ssize_t	rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);

/* Wrappers for Rio package */
ssize_t Rio_readn(int fd, void *usrbuf, size_t n);
void Rio_writen(int fd, void *usrbuf, size_t n);
void Rio_readinitb(rio_t *rp, int fd); 
ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n);
ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);

/* Client/server helper functions */
int open_clientfd(char *hostname, int portno);
int open_listenfd(int portno);

/* Wrappers for client/server helper functions */
int Open_clientfd(char *hostname, int port);
int Open_listenfd(int port); 

#endif /* __CSAPP_H__ */
/* $end csapp.h */

```

<center>csapp.c
</center>

```c
/* 
 * csapp.c - Functions for the CS:APP3e book
 *
 * Updated 10/2016 reb:
 *   - Fixed bug in sio_ltoa that didn't cover negative numbers
 *
 * Updated 2/2016 droh:
 *   - Updated open_clientfd and open_listenfd to fail more gracefully
 *
 * Updated 8/2014 droh: 
 *   - New versions of open_clientfd and open_listenfd are reentrant and
 *     protocol independent.
 *
 *   - Added protocol-independent inet_ntop and inet_pton functions. The
 *     inet_ntoa and inet_aton functions are obsolete.
 *
 * Updated 7/2014 droh:
 *   - Aded reentrant sio (signal-safe I/O) routines
 * 
 * Updated 4/2013 droh: 
 *   - rio_readlineb: fixed edge case bug
 *   - rio_readnb: removed redundant EINTR check
 */
/* $begin csapp.c */
#include "csapp.h"

/************************** 
 * Error-handling functions
 **************************/
/* $begin errorfuns */
/* $begin unixerror */
void unix_error(char *msg) /* Unix-style error */
{
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}
/* $end unixerror */

void posix_error(int code, char *msg) /* Posix-style error */
{
    fprintf(stderr, "%s: %s\n", msg, strerror(code));
    exit(0);
}

void gai_error(int code, char *msg) /* Getaddrinfo-style error */
{
    fprintf(stderr, "%s: %s\n", msg, gai_strerror(code));
    exit(0);
}

void app_error(char *msg) /* Application error */
{
    fprintf(stderr, "%s\n", msg);
    exit(0);
}
/* $end errorfuns */

void dns_error(char *msg) /* Obsolete gethostbyname error */
{
    fprintf(stderr, "%s\n", msg);
    exit(0);
}


/*********************************************
 * Wrappers for Unix process control functions
 ********************************************/

/* $begin forkwrapper */
pid_t Fork(void) 
{
    pid_t pid;

    if ((pid = fork()) < 0)
	unix_error("Fork error");
    return pid;
}
/* $end forkwrapper */

void Execve(const char *filename, char *const argv[], char *const envp[]) 
{
    if (execve(filename, argv, envp) < 0)
	unix_error("Execve error");
}

/* $begin wait */
pid_t Wait(int *status) 
{
    pid_t pid;

    if ((pid  = wait(status)) < 0)
	unix_error("Wait error");
    return pid;
}
/* $end wait */

pid_t Waitpid(pid_t pid, int *iptr, int options) 
{
    pid_t retpid;

    if ((retpid  = waitpid(pid, iptr, options)) < 0) 
	unix_error("Waitpid error");
    return(retpid);
}

/* $begin kill */
void Kill(pid_t pid, int signum) 
{
    int rc;

    if ((rc = kill(pid, signum)) < 0)
	unix_error("Kill error");
}
/* $end kill */

void Pause() 
{
    (void)pause();
    return;
}

unsigned int Sleep(unsigned int secs) 
{
    unsigned int rc;

    if ((rc = sleep(secs)) < 0)
	unix_error("Sleep error");
    return rc;
}

unsigned int Alarm(unsigned int seconds) {
    return alarm(seconds);
}
 
void Setpgid(pid_t pid, pid_t pgid) {
    int rc;

    if ((rc = setpgid(pid, pgid)) < 0)
	unix_error("Setpgid error");
    return;
}

pid_t Getpgrp(void) {
    return getpgrp();
}

/************************************
 * Wrappers for Unix signal functions 
 ***********************************/

/* $begin sigaction */
handler_t *Signal(int signum, handler_t *handler) 
{
    struct sigaction action, old_action;

    action.sa_handler = handler;  
    sigemptyset(&action.sa_mask); /* Block sigs of type being handled */
    action.sa_flags = SA_RESTART; /* Restart syscalls if possible */

    if (sigaction(signum, &action, &old_action) < 0)
	unix_error("Signal error");
    return (old_action.sa_handler);
}
/* $end sigaction */

void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
{
    if (sigprocmask(how, set, oldset) < 0)
	unix_error("Sigprocmask error");
    return;
}

void Sigemptyset(sigset_t *set)
{
    if (sigemptyset(set) < 0)
	unix_error("Sigemptyset error");
    return;
}

void Sigfillset(sigset_t *set)
{ 
    if (sigfillset(set) < 0)
	unix_error("Sigfillset error");
    return;
}

void Sigaddset(sigset_t *set, int signum)
{
    if (sigaddset(set, signum) < 0)
	unix_error("Sigaddset error");
    return;
}

void Sigdelset(sigset_t *set, int signum)
{
    if (sigdelset(set, signum) < 0)
	unix_error("Sigdelset error");
    return;
}

int Sigismember(const sigset_t *set, int signum)
{
    int rc;
    if ((rc = sigismember(set, signum)) < 0)
	unix_error("Sigismember error");
    return rc;
}

int Sigsuspend(const sigset_t *set)
{
    int rc = sigsuspend(set); /* always returns -1 */
    if (errno != EINTR)
        unix_error("Sigsuspend error");
    return rc;
}

/*************************************************************
 * The Sio (Signal-safe I/O) package - simple reentrant output
 * functions that are safe for signal handlers.
 *************************************************************/

/* Private sio functions */

/* $begin sioprivate */
/* sio_reverse - Reverse a string (from K&R) */
static void sio_reverse(char s[])
{
    int c, i, j;

    for (i = 0, j = strlen(s)-1; i < j; i++, j--) {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}

/* sio_ltoa - Convert long to base b string (from K&R) */
static void sio_ltoa(long v, char s[], int b) 
{
    int c, i = 0;
    int neg = v < 0;

    if (neg)
	v = -v;

    do {  
        s[i++] = ((c = (v % b)) < 10)  ?  c + '0' : c - 10 + 'a';
    } while ((v /= b) > 0);

    if (neg)
	s[i++] = '-';

    s[i] = '\0';
    sio_reverse(s);
}

/* sio_strlen - Return length of string (from K&R) */
static size_t sio_strlen(char s[])
{
    int i = 0;

    while (s[i] != '\0')
        ++i;
    return i;
}
/* $end sioprivate */

/* Public Sio functions */
/* $begin siopublic */

ssize_t sio_puts(char s[]) /* Put string */
{
    return write(STDOUT_FILENO, s, sio_strlen(s)); //line:csapp:siostrlen
}

ssize_t sio_putl(long v) /* Put long */
{
    char s[128];
    
    sio_ltoa(v, s, 10); /* Based on K&R itoa() */  //line:csapp:sioltoa
    return sio_puts(s);
}

void sio_error(char s[]) /* Put error message and exit */
{
    sio_puts(s);
    _exit(1);                                      //line:csapp:sioexit
}
/* $end siopublic */

/*******************************
 * Wrappers for the SIO routines
 ******************************/
ssize_t Sio_putl(long v)
{
    ssize_t n;
  
    if ((n = sio_putl(v)) < 0)
	sio_error("Sio_putl error");
    return n;
}

ssize_t Sio_puts(char s[])
{
    ssize_t n;
  
    if ((n = sio_puts(s)) < 0)
	sio_error("Sio_puts error");
    return n;
}

void Sio_error(char s[])
{
    sio_error(s);
}

/********************************
 * Wrappers for Unix I/O routines
 ********************************/

int Open(const char *pathname, int flags, mode_t mode) 
{
    int rc;

    if ((rc = open(pathname, flags, mode))  < 0)
	unix_error("Open error");
    return rc;
}

ssize_t Read(int fd, void *buf, size_t count) 
{
    ssize_t rc;

    if ((rc = read(fd, buf, count)) < 0) 
	unix_error("Read error");
    return rc;
}

ssize_t Write(int fd, const void *buf, size_t count) 
{
    ssize_t rc;

    if ((rc = write(fd, buf, count)) < 0)
	unix_error("Write error");
    return rc;
}

off_t Lseek(int fildes, off_t offset, int whence) 
{
    off_t rc;

    if ((rc = lseek(fildes, offset, whence)) < 0)
	unix_error("Lseek error");
    return rc;
}

void Close(int fd) 
{
    int rc;

    if ((rc = close(fd)) < 0)
	unix_error("Close error");
}

int Select(int  n, fd_set *readfds, fd_set *writefds,
	   fd_set *exceptfds, struct timeval *timeout) 
{
    int rc;

    if ((rc = select(n, readfds, writefds, exceptfds, timeout)) < 0)
	unix_error("Select error");
    return rc;
}

int Dup2(int fd1, int fd2) 
{
    int rc;

    if ((rc = dup2(fd1, fd2)) < 0)
	unix_error("Dup2 error");
    return rc;
}

void Stat(const char *filename, struct stat *buf) 
{
    if (stat(filename, buf) < 0)
	unix_error("Stat error");
}

void Fstat(int fd, struct stat *buf) 
{
    if (fstat(fd, buf) < 0)
	unix_error("Fstat error");
}

/*********************************
 * Wrappers for directory function
 *********************************/

DIR *Opendir(const char *name) 
{
    DIR *dirp = opendir(name); 

    if (!dirp)
        unix_error("opendir error");
    return dirp;
}

struct dirent *Readdir(DIR *dirp)
{
    struct dirent *dep;
    
    errno = 0;
    dep = readdir(dirp);
    if ((dep == NULL) && (errno != 0))
        unix_error("readdir error");
    return dep;
}

int Closedir(DIR *dirp) 
{
    int rc;

    if ((rc = closedir(dirp)) < 0)
        unix_error("closedir error");
    return rc;
}

/***************************************
 * Wrappers for memory mapping functions
 ***************************************/
void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset) 
{
    void *ptr;

    if ((ptr = mmap(addr, len, prot, flags, fd, offset)) == ((void *) -1))
	unix_error("mmap error");
    return(ptr);
}

void Munmap(void *start, size_t length) 
{
    if (munmap(start, length) < 0)
	unix_error("munmap error");
}

/***************************************************
 * Wrappers for dynamic storage allocation functions
 ***************************************************/

void *Malloc(size_t size) 
{
    void *p;

    if ((p  = malloc(size)) == NULL)
	unix_error("Malloc error");
    return p;
}

void *Realloc(void *ptr, size_t size) 
{
    void *p;

    if ((p  = realloc(ptr, size)) == NULL)
	unix_error("Realloc error");
    return p;
}

void *Calloc(size_t nmemb, size_t size) 
{
    void *p;

    if ((p = calloc(nmemb, size)) == NULL)
	unix_error("Calloc error");
    return p;
}

void Free(void *ptr) 
{
    free(ptr);
}

/******************************************
 * Wrappers for the Standard I/O functions.
 ******************************************/
void Fclose(FILE *fp) 
{
    if (fclose(fp) != 0)
	unix_error("Fclose error");
}

FILE *Fdopen(int fd, const char *type) 
{
    FILE *fp;

    if ((fp = fdopen(fd, type)) == NULL)
	unix_error("Fdopen error");

    return fp;
}

char *Fgets(char *ptr, int n, FILE *stream) 
{
    char *rptr;

    if (((rptr = fgets(ptr, n, stream)) == NULL) && ferror(stream))
	app_error("Fgets error");

    return rptr;
}

FILE *Fopen(const char *filename, const char *mode) 
{
    FILE *fp;

    if ((fp = fopen(filename, mode)) == NULL)
	unix_error("Fopen error");

    return fp;
}

void Fputs(const char *ptr, FILE *stream) 
{
    if (fputs(ptr, stream) == EOF)
	unix_error("Fputs error");
}

size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 
{
    size_t n;

    if (((n = fread(ptr, size, nmemb, stream)) < nmemb) && ferror(stream)) 
	unix_error("Fread error");
    return n;
}

void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 
{
    if (fwrite(ptr, size, nmemb, stream) < nmemb)
	unix_error("Fwrite error");
}


/**************************** 
 * Sockets interface wrappers
 ****************************/

int Socket(int domain, int type, int protocol) 
{
    int rc;

    if ((rc = socket(domain, type, protocol)) < 0)
	unix_error("Socket error");
    return rc;
}

void Setsockopt(int s, int level, int optname, const void *optval, int optlen) 
{
    int rc;

    if ((rc = setsockopt(s, level, optname, optval, optlen)) < 0)
	unix_error("Setsockopt error");
}

void Bind(int sockfd, struct sockaddr *my_addr, int addrlen) 
{
    int rc;

    if ((rc = bind(sockfd, my_addr, addrlen)) < 0)
	unix_error("Bind error");
}

void Listen(int s, int backlog) 
{
    int rc;

    if ((rc = listen(s,  backlog)) < 0)
	unix_error("Listen error");
}

int Accept(int s, struct sockaddr *addr, socklen_t *addrlen) 
{
    int rc;

    if ((rc = accept(s, addr, addrlen)) < 0)
	unix_error("Accept error");
    return rc;
}

void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen) 
{
    int rc;

    if ((rc = connect(sockfd, serv_addr, addrlen)) < 0)
	unix_error("Connect error");
}

/*******************************
 * Protocol-independent wrappers
 *******************************/
/* $begin getaddrinfo */
void Getaddrinfo(const char *node, const char *service, 
                 const struct addrinfo *hints, struct addrinfo **res)
{
    int rc;

    if ((rc = getaddrinfo(node, service, hints, res)) != 0) 
        gai_error(rc, "Getaddrinfo error");
}
/* $end getaddrinfo */

void Getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, 
                 size_t hostlen, char *serv, size_t servlen, int flags)
{
    int rc;

    if ((rc = getnameinfo(sa, salen, host, hostlen, serv, 
                          servlen, flags)) != 0) 
        gai_error(rc, "Getnameinfo error");
}

void Freeaddrinfo(struct addrinfo *res)
{
    freeaddrinfo(res);
}

void Inet_ntop(int af, const void *src, char *dst, socklen_t size)
{
    if (!inet_ntop(af, src, dst, size))
        unix_error("Inet_ntop error");
}

void Inet_pton(int af, const char *src, void *dst) 
{
    int rc;

    rc = inet_pton(af, src, dst);
    if (rc == 0)
	app_error("inet_pton error: invalid dotted-decimal address");
    else if (rc < 0)
        unix_error("Inet_pton error");
}

/*******************************************
 * DNS interface wrappers. 
 *
 * NOTE: These are obsolete because they are not thread safe. Use
 * getaddrinfo and getnameinfo instead
 ***********************************/

/* $begin gethostbyname */
struct hostent *Gethostbyname(const char *name) 
{
    struct hostent *p;

    if ((p = gethostbyname(name)) == NULL)
	dns_error("Gethostbyname error");
    return p;
}
/* $end gethostbyname */

struct hostent *Gethostbyaddr(const char *addr, int len, int type) 
{
    struct hostent *p;

    if ((p = gethostbyaddr(addr, len, type)) == NULL)
	dns_error("Gethostbyaddr error");
    return p;
}

/************************************************
 * Wrappers for Pthreads thread control functions
 ************************************************/

void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp, 
		    void * (*routine)(void *), void *argp) 
{
    int rc;

    if ((rc = pthread_create(tidp, attrp, routine, argp)) != 0)
	posix_error(rc, "Pthread_create error");
}

void Pthread_cancel(pthread_t tid) {
    int rc;

    if ((rc = pthread_cancel(tid)) != 0)
	posix_error(rc, "Pthread_cancel error");
}

void Pthread_join(pthread_t tid, void **thread_return) {
    int rc;

    if ((rc = pthread_join(tid, thread_return)) != 0)
	posix_error(rc, "Pthread_join error");
}

/* $begin detach */
void Pthread_detach(pthread_t tid) {
    int rc;

    if ((rc = pthread_detach(tid)) != 0)
	posix_error(rc, "Pthread_detach error");
}
/* $end detach */

void Pthread_exit(void *retval) {
    pthread_exit(retval);
}

pthread_t Pthread_self(void) {
    return pthread_self();
}
 
void Pthread_once(pthread_once_t *once_control, void (*init_function)()) {
    pthread_once(once_control, init_function);
}

/*******************************
 * Wrappers for Posix semaphores
 *******************************/

void Sem_init(sem_t *sem, int pshared, unsigned int value) 
{
    if (sem_init(sem, pshared, value) < 0)
	unix_error("Sem_init error");
}

void P(sem_t *sem) 
{
    if (sem_wait(sem) < 0)
	unix_error("P error");
}

void V(sem_t *sem) 
{
    if (sem_post(sem) < 0)
	unix_error("V error");
}

/****************************************
 * The Rio package - Robust I/O functions
 ****************************************/

/*
 * rio_readn - Robustly read n bytes (unbuffered)
 */
/* $begin rio_readn */
ssize_t rio_readn(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;

    while (nleft > 0) {
	if ((nread = read(fd, bufp, nleft)) < 0) {
	    if (errno == EINTR) /* Interrupted by sig handler return */
		nread = 0;      /* and call read() again */
	    else
		return -1;      /* errno set by read() */ 
	} 
	else if (nread == 0)
	    break;              /* EOF */
	nleft -= nread;
	bufp += nread;
    }
    return (n - nleft);         /* Return >= 0 */
}
/* $end rio_readn */

/*
 * rio_writen - Robustly write n bytes (unbuffered)
 */
/* $begin rio_writen */
ssize_t rio_writen(int fd, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nwritten;
    char *bufp = usrbuf;

    while (nleft > 0) {
	if ((nwritten = write(fd, bufp, nleft)) <= 0) {
	    if (errno == EINTR)  /* Interrupted by sig handler return */
		nwritten = 0;    /* and call write() again */
	    else
		return -1;       /* errno set by write() */
	}
	nleft -= nwritten;
	bufp += nwritten;
    }
    return n;
}
/* $end rio_writen */


/* 
 * rio_read - This is a wrapper for the Unix read() function that
 *    transfers min(n, rio_cnt) bytes from an internal buffer to a user
 *    buffer, where n is the number of bytes requested by the user and
 *    rio_cnt is the number of unread bytes in the internal buffer. On
 *    entry, rio_read() refills the internal buffer via a call to
 *    read() if the internal buffer is empty.
 */
/* $begin rio_read */
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)
{
    int cnt;

    while (rp->rio_cnt <= 0) {  /* Refill if buf is empty */
	rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
			   sizeof(rp->rio_buf));
	if (rp->rio_cnt < 0) {
	    if (errno != EINTR) /* Interrupted by sig handler return */
		return -1;
	}
	else if (rp->rio_cnt == 0)  /* EOF */
	    return 0;
	else 
	    rp->rio_bufptr = rp->rio_buf; /* Reset buffer ptr */
    }

    /* Copy min(n, rp->rio_cnt) bytes from internal buf to user buf */
    cnt = n;          
    if (rp->rio_cnt < n)   
	cnt = rp->rio_cnt;
    memcpy(usrbuf, rp->rio_bufptr, cnt);
    rp->rio_bufptr += cnt;
    rp->rio_cnt -= cnt;
    return cnt;
}
/* $end rio_read */

/*
 * rio_readinitb - Associate a descriptor with a read buffer and reset buffer
 */
/* $begin rio_readinitb */
void rio_readinitb(rio_t *rp, int fd) 
{
    rp->rio_fd = fd;  
    rp->rio_cnt = 0;  
    rp->rio_bufptr = rp->rio_buf;
}
/* $end rio_readinitb */

/*
 * rio_readnb - Robustly read n bytes (buffered)
 */
/* $begin rio_readnb */
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
{
    size_t nleft = n;
    ssize_t nread;
    char *bufp = usrbuf;
    
    while (nleft > 0) {
	if ((nread = rio_read(rp, bufp, nleft)) < 0) 
            return -1;          /* errno set by read() */ 
	else if (nread == 0)
	    break;              /* EOF */
	nleft -= nread;
	bufp += nread;
    }
    return (n - nleft);         /* return >= 0 */
}
/* $end rio_readnb */

/* 
 * rio_readlineb - Robustly read a text line (buffered)
 */
/* $begin rio_readlineb */
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
{
    int n, rc;
    char c, *bufp = usrbuf;

    for (n = 1; n < maxlen; n++) { 
        if ((rc = rio_read(rp, &c, 1)) == 1) {
	    *bufp++ = c;
	    if (c == '\n') {
                n++;
     		break;
            }
	} else if (rc == 0) {
	    if (n == 1)
		return 0; /* EOF, no data read */
	    else
		break;    /* EOF, some data was read */
	} else
	    return -1;	  /* Error */
    }
    *bufp = 0;
    return n-1;
}
/* $end rio_readlineb */

/**********************************
 * Wrappers for robust I/O routines
 **********************************/
ssize_t Rio_readn(int fd, void *ptr, size_t nbytes) 
{
    ssize_t n;
  
    if ((n = rio_readn(fd, ptr, nbytes)) < 0)
	unix_error("Rio_readn error");
    return n;
}

void Rio_writen(int fd, void *usrbuf, size_t n) 
{
    if (rio_writen(fd, usrbuf, n) != n)
	unix_error("Rio_writen error");
}

void Rio_readinitb(rio_t *rp, int fd)
{
    rio_readinitb(rp, fd);
} 

ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n) 
{
    ssize_t rc;

    if ((rc = rio_readnb(rp, usrbuf, n)) < 0)
	unix_error("Rio_readnb error");
    return rc;
}

ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen) 
{
    ssize_t rc;

    if ((rc = rio_readlineb(rp, usrbuf, maxlen)) < 0)
	unix_error("Rio_readlineb error");
    return rc;
} 

/******************************** 
 * Client/server helper functions
 ********************************/
/*
 * open_clientfd - Open connection to server at <hostname, port> and
 *     return a socket descriptor ready for reading and writing. This
 *     function is reentrant and protocol-independent.
 *
 *     On error, returns: 
 *       -2 for getaddrinfo error
 *       -1 with errno set for other errors.
 */
/* $begin open_clientfd */
int open_clientfd(char *hostname, char *port) {
    int clientfd, rc;
    struct addrinfo hints, *listp, *p;

    /* Get a list of potential server addresses */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;  /* Open a connection */
    hints.ai_flags = AI_NUMERICSERV;  /* ... using a numeric port arg. */
    hints.ai_flags |= AI_ADDRCONFIG;  /* Recommended for connections */
    if ((rc = getaddrinfo(hostname, port, &hints, &listp)) != 0) {
        fprintf(stderr, "getaddrinfo failed (%s:%s): %s\n", hostname, port, gai_strerror(rc));
        return -2;
    }
  
    /* Walk the list for one that we can successfully connect to */
    for (p = listp; p; p = p->ai_next) {
        /* Create a socket descriptor */
        if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) 
            continue; /* Socket failed, try the next */

        /* Connect to the server */
        if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1) 
            break; /* Success */
        if (close(clientfd) < 0) { /* Connect failed, try another */  //line:netp:openclientfd:closefd
            fprintf(stderr, "open_clientfd: close failed: %s\n", strerror(errno));
            return -1;
        } 
    } 

    /* Clean up */
    freeaddrinfo(listp);
    if (!p) /* All connects failed */
        return -1;
    else    /* The last connect succeeded */
        return clientfd;
}
/* $end open_clientfd */

/*  
 * open_listenfd - Open and return a listening socket on port. This
 *     function is reentrant and protocol-independent.
 *
 *     On error, returns: 
 *       -2 for getaddrinfo error
 *       -1 with errno set for other errors.
 */
/* $begin open_listenfd */
int open_listenfd(char *port) 
{
    struct addrinfo hints, *listp, *p;
    int listenfd, rc, optval=1;

    /* Get a list of potential server addresses */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;             /* Accept connections */
    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */
    hints.ai_flags |= AI_NUMERICSERV;            /* ... using port number */
    if ((rc = getaddrinfo(NULL, port, &hints, &listp)) != 0) {
        fprintf(stderr, "getaddrinfo failed (port %s): %s\n", port, gai_strerror(rc));
        return -2;
    }

    /* Walk the list for one that we can bind to */
    for (p = listp; p; p = p->ai_next) {
        /* Create a socket descriptor */
        if ((listenfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) 
            continue;  /* Socket failed, try the next */

        /* Eliminates "Address already in use" error from bind */
        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    //line:netp:csapp:setsockopt
                   (const void *)&optval , sizeof(int));

        /* Bind the descriptor to the address */
        if (bind(listenfd, p->ai_addr, p->ai_addrlen) == 0)
            break; /* Success */
        if (close(listenfd) < 0) { /* Bind failed, try the next */
            fprintf(stderr, "open_listenfd close failed: %s\n", strerror(errno));
            return -1;
        }
    }


    /* Clean up */
    freeaddrinfo(listp);
    if (!p) /* No address worked */
        return -1;

    /* Make it a listening socket ready to accept connection requests */
    if (listen(listenfd, LISTENQ) < 0) {
        close(listenfd);
	return -1;
    }
    return listenfd;
}
/* $end open_listenfd */

/****************************************************
 * Wrappers for reentrant protocol-independent helpers
 ****************************************************/
int Open_clientfd(char *hostname, char *port) 
{
    int rc;

    if ((rc = open_clientfd(hostname, port)) < 0) 
	unix_error("Open_clientfd error");
    return rc;
}

int Open_listenfd(char *port) 
{
    int rc;

    if ((rc = open_listenfd(port)) < 0)
	unix_error("Open_listenfd error");
    return rc;
}

/* $end csapp.c */


```

## 3. 挂载磁盘

```
mount /dev/sdb1 /home/cai/sdb1
```

