[toc]

# 向量



## ADT接口

![image-20210711142209164](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711142209164.png)

## Vector模板类

![image-20210711142248652](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711142248652.png)

![image-20210711142304166](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711142304166.png)

## 构造与析构

向量中秩为r的元素,对应于内部数组中的$\_elem[r]$,其物理地址为$\_elem+r$

### 默认构造方法

其中默认的构造方法是,首先根据创建者指是的初始容量,向系统申请空间,以创建内部私有数组$\_elem[]$;若容量未明确指定,则使用默认值$DEFAULT\_CAPACITY$,接下来,鉴于初生的向量尚不包含任何元素,故将指示规模的变量$\_size$初始化为$0$

整个过程顺序进行,没有任何迭代,故若忽略用于分配数组空间的时间,共需常数时间

### 基于复制的构造方法

![image-20210711143256891](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711143256891.png)

![image-20210711165051324](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711165051324.png)

#### 析构方法

与所有对象一样,不再需要的向量,应借助析构函数(destructor)及时清理(cleanup),以释放其占用的系统资源.与构造函数不同,同一对象只能有一个析构函数,不得重载.向量对象的析构过程,$\sim Vector()$:只需释放用于存放元素的内部数组$elem[]$,将其占用的空间交还操作系统.$\_capacity$和$\_size$之类的内部变量无需做任何处理,它们将作为向量对象自身的一部分被系统回收,此后既无需也无法被引用.若不计系统用于空间回收的时间,整个析构过程只需0(1)时间.同样地,向量中的元素可能不是程序语言直接支持的基本类型,在向量析构之前应该提前释放对应的空间

出于简化的考虑,这里约定并遵照"谁申请谁释放"的原则.究竟应释放掉向量各元素所指的对象,还是需要保留这些对象以便通过其它指针继续引用它们,应由上层调用者负责确定

## 动态空间管理

### 静态空间管理

内部数组所占物理空间的容量,若在向量的生命期内不允许调整,则称作==静态空间管理策略==.很遗憾,该策略的空间效率难以保证.一方面,既然容量固定,总有可能在此后的某一时刻,无法加入更多的新元素-即导致所谓的上溢(overflow) 

注意,造成此类溢出的原因,并非系统不能提供更多的空间.另一方面反过来,即便愿意为降低这种风险而预留出部分空间,也很难在程序执行之前,明确界定一个合理的预留量

向量实际规模与其内部数组容量的比值(即$\frac{\_size}{\_capacity}$) ,亦称作==装填因子==(load factor) ,它是衡量空间利用率的重要指标

### 可扩充向量

经过一段时间的生长,每当身体无法继续为其外壳所容纳,蝉就会蜕去外壳,同时换上一身更大的外壳.扩充向量(extendable vector)的原理,与之相仿.若内部数组仍有空余,则操作可照常执行.每经一次插入(删除) ,可用空间都会减少(增加)一个单元.一旦可用空间耗尽(图(b)) ,就动态地扩大内部数组的容量

![image-20210711192052153](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711192052153.png)

### 扩容

![image-20210711192534293](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711192534293.png)

实际上,在调用insert()接口插入新元素之前,都要先调用该算法,检查内部数组的可用容量.一旦当前数据区已满($\_size ==\_capacity$) ,则将原数组替换为一个更大的数组

新数组的地址由操作系统分配,与原数据区没有直接的关系.这种情况下,若直接引用数组,往往会导致共同指向原数组的其它指针失效,成为野指针(wild pointer) ;而经封装为向量之后,即可继续准确地引用各元素,从而有效地避免野指针的风险

### 分摊分析

#### 时间代价

与常规数组实现相比,可扩充向量更加灵活:只要系统尚有可用空间,其规模将不再受限于初始容量.不过,这并非没有代价—每次扩容,元素的搬迁都需要花费额外的时间.准确地,每一次由n到2n的扩容,都需要花费$\sigma(2n) =\sigma(n)$时间—这也是最坏情况下,单次插入操作所需的时间.表面看来,这一扩容策略似乎效率很低,但这不过是一种错觉.请注意,按照此处的约定,每花费$\sigma(n)$时间实施一次扩容,数组的容量都会加倍.这就意味着,至少要再经过n次插入操作,才会因为可能溢出而再次扩容.也就是说,随着向量规模的不断扩大,在执行插入操作之前需要进行扩容的概率,也将迅速降低.故就某种平均意义而言,用于扩容的时间成本不至很高

#### 分摊复杂度

这里,不妨考查对可扩充向量的足够多次连续操作,并将其间所消耗的时间,分摊至所有的操作.如此分摊平均至单次操作的时间成本,称作==分摊运行时间(amortized running time)==.请注意,这一指标与==平均运行时间(average running time)==有着本质的区别.后者是按照某种假定的概率分布,对各种情况下所需执行时间的加权平均,故亦称作期望运行时间(expected running time) .而前者则要求,参与分摊的操作必须构成和来自一个真实可行的操作序列,而且该序列还必须足够地长.相对而言,分摊复杂度可以针对计算成本和效率,做出更为客观而准确的估计

#### 其它扩容策略

以上分析确凿地说明,基于加倍策略的动态扩充数组不仅可行,而且就分摊复杂度而言效率也足以令人满意.当然,并非任何扩容策略都能保证如此高的效率.比如,早期可扩充向量多采用另一策略:一旦有必要,则追加固定数目的单元.实际上,无论采用的固定常数多大,在最坏情况下,此类数组单次操作的分摊时间复杂度都将高达$\Omega(n)$

### 缩容

导致低效率的另一情况是,向量的实际规模可能远远小于内部数组的容量.比如在连续的一系列操作过程中,若删除操作远多于插入操作,则装填因子极有可能远远小于100%,甚至非常接近于0.当装填因子低于某一阈值时,我们称数组发生了下溢(underflow) .尽管下溢不属于必须解决的问题,但在格外关注空间利用率的场合,发生下溢时也有必要适当缩减内部数组容量

![image-20210711201444098](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711201444098.png)

可见,每次删除操作之后,一旦空间利用率已降至某一阈值以下,该算法随即申请一个容量减半的新数组,将原数组中的元素逐一搬迁至其中,最后将原数组所占空间交还操作系统.这里以25%作为装填因子的下限,但在实际应用中,为避免出现频繁交替扩容和缩容的情况,可以选用更低的阈值,甚至取作0(相当于禁止缩容)

与expand()操作类似,尽管单次shrink()操作需要线性量级的时间,但其分摊复杂度亦为$\sigma(1)$.实际上shrink()过程等效于expand()的逆过程,这两个算法相互配合,在不致实质地增加接口操作复杂度的前提下,保证了向量内部空间的高效利用.当然,就单次扩容或缩容操作而言,所需时间的确会高达$\Omega(n)$,因此在对单次操作的执行速度极其敏感的应用场合以上策略并不适用,其中缩容操作甚至可以完全不予考虑

## 常规向量

### 直接引用元素

与数组直接通过下标访问元素的方式(形如"A[i]" )相比,向量ADT所设置的get()和put()接口都显得不甚自然.毕竟,前一访问方式不仅更为我们所熟悉,同时也更加直观和便捷.那么,在经过封装之后,对向量元素的访问可否沿用数组的方式呢?答案是肯定的

![image-20210711203326264](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711203326264.png)

### 置乱器

#### 置乱算法

可见,经重载后操作符"[]"返回的是对数组元素的引用,这就意味着它既可以取代get()操作(通常作为赋值表达式的右值),也可以取代set()操作(通常作为左值)

![image-20210711204411492](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711204411492.png)

该算法从待置乱区间的末元素开始,逆序地向前逐一处理各元素.对每一个当前元素V[i-1],先通过调用rand()函数在[0, i)之间等概率地随机选取一个元素,再令二者互换位置.注意,这里的交换操作swap(),隐含了三次基于重载操作符"[]"的赋值

![image-20210711204725680](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711204725680.png)

在软件测试、仿真模拟等应用中,随机向量的生成都是一项至关重要的基本操作,直接影响到测试的覆盖面或仿真的真实性.从理论上说,使用这里的算法permute(),不仅可以枚举出同一向量所有可能的排列,而且能够保证生成各种排列的概率均等

#### 区间置乱接口

![image-20210711205611431](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711205611431.png)

通过该接口,可以均匀地置乱任一向量区间[lo, hi)内的元素,故通用性有所提高.可见只要将该区间等效地视作另一向量V,即可从形式上完整地套用以上permute()算法的流程

### 判等器与比较器

从算法的角度来看, "判断两个对象是否相等"与"判断两个对象的相对大小"都是至关重要的操作,它们直接控制着算法执行的分支方向,因此也是算法的"灵魂"所在.当然,这两种操作之间既有联系也有区别,不能相互替代.比如,有些对象只能比对但不能比较;反之,支持比较的对象未必支持比对.

算法实现的简洁性与通用性,在很大程度上体现于:针对整数等特定数据类型的某种实现,可否推广至可比较或可比对的任何数据类型,而不必关心如何定义以及判定其大小或相等关系.若能如此,我们就可以将比对和比较操作的具体实现剥离出来,直接讨论算法流程本身

为此,通常可以采用两种方法.其一,将比对操作和比较操作分别封装成通用的判等器和比较器.其二,在定义对应的数据类型时,通过重载"<"和"=="之类的操作符,给出大小和相等关系的具体定义及其判别方法

![image-20210711210245435](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711210245435.png)

### 无序查找

#### 判等器

Vector: : find(e)接口,功能语义为"查找与数据对象e相等的元素".这同时也暗示着,向量元素可通过相互比对判等—比如,元素类型T或为基本类型,或已重载操作符"=="或"!=".这类仅支持比对,但未必支持比较的向量,称作无序向量(unsorted vector)

#### 顺序查找

![image-20210711211311938](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711211311938.png)

在无序向量中查找任意指定元素e时,因为没有更多的信息可以借助,故在最坏情况下比如向量中并不包含e时—只有在访遍所有元素之后,才能得出查找结论

#### 实现

针对向量的整体或区间,分别定义了一个顺序查找操作的入口,其中前者作为特例,可直接通过调用后者而实现

![image-20210711211546974](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711211546974.png)

#### 复杂度

最坏情况下,查找终止于首元素$\_elem[10]$,运行时间为$\sigma(hi-lo)=\sigma(n)$.最好情况下,查找命中于末元素$\_elem[hi-1]$,仅需$\sigma(1)$时间.对于规模相同、内部组成不同的输入,渐进运行时间却有本质区别,故此类算法也称作==输入敏感的(input sensitive)算法==

### 插入

![image-20210711225551165](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711225551165.png)

插入之前必须首先调用expand()算法,核对是否即将溢出;若有必要,则加倍扩容

![image-20210711225615926](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711225615926.png)

为保证数组元素物理地址连续的特性,随后需要将后缀$\_elem[r, _size)$ (如果非空)整体后移一个单元.这些后继元素自后向前的搬迁次序不能颠倒,否则会因元素被覆盖而造成数据丢失

在单元_elem[r]腾出之后,方可将待插入对象e置入其中

#### 复杂度

时间主要消耗于后继元素的后移,线性正比于后缀的长度,故总体为$\sigma(\_size-r+ 1)$

可见,新插入元素越靠后(前)所需时间越短(长) .特别地, r取最大值_size时为最好情况,只需$\sigma(1)$时间;r取最小值0时为最坏情况,需要$\sigma(\_size)$时间.一般地,若插入位置等概率分布,则平均运行时间为$\sigma(\_size)=\sigma(n)$,线性正比于向量的实际规模

### 删除

删除操作重载有两个接口, remove(lo, hi)用以删除区间[lo, hi)内的元素,而remove(r)用以删除秩为r的单个元素

应将单元素删除视作区间删除的特例,并基于后者来实现前者

#### 区间删除

![image-20210711231801673](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210711231801673.png)

![image-20210712091528459](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712091528459.png)

#### 单元素删除remove(r)

![image-20210712091626127](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712091626127.png)

##### 复杂度

remove(lo, hi)的计算成本,主要消耗于后续元素的前移,线性正比于后缀的长度,总体不过$\sigma(m+1) =\sigma(_size-hi+1)$

这与此前的预期完全吻合:区间删除操作所需的时间,应该仅取决于后继元素的数目,而与被删除区间本身的宽度无关

### 唯一化

很多应用中,在进一步处理之前都要求数据元素互异.以网络搜索引擎为例,多个计算节点各自获得的局部搜索结果,需首先剔除其中重复的项目,方可合并为一份完整的报告.类似地,所谓向量的唯一化处理,就是剔除其中的重复元素

![image-20210712094446572](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712094446572.png)

#### 正确性

算法的正确性由以下不变性保证

<center>在while循环中,在当前元素的前缀_elem[0, i)内,所有元素彼此互异</center>

![image-20210712094557593](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712094557593.png)

#### 复杂度

该算法过程所具有的单调性

<center>随着循环的不断进行,当前元素的后继持续地严格减少</center>

### 遍历

#### 功能

在很多算法中,往往需要将向量作为一个整体,对其中所有元素实施某种统一的操作,比如,输出向量中的所有元素,或者按照某种运算流程统一修改所有元素的数值.针对此类操作,可为向量专门设置一个遍历接口traverse()

![image-20210712095351872](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712095351872.png)

可见, traverse ()遍历的过程,实质上就是自前向后地逐一对各元素实施同一基本操作.而具体采用何种操作,可通过两种方式指定.前一种方式借助函数指针*visit()指定某一函数,该函数只有一个参数,其类型为对向量元素的引用,故通过该函数即可直接访问或修改向量元素另外,也可以函数对象的形式,指定具体的遍历操作.这类对象的操作符"()"经重载之后,在形式上等效于一个函数接口,故此得名

## 有序向量

若向量S[0, n)中的所有元素不仅按线性次序存放,而且其数值大小也按此次序单调分布,则称作有序向量(sorted vector)

与通常的向量一样,有序向量依然不要求元素互异,故通常约定其中的元素自前(左)向后(右)构成一个非降序列,即对任意$0\leq si < j<n$都有$S[i] \leq S[j]$

### 有序性甄别

作为无序向量的特例,有序向量自然可以沿用无序向量的查找算法.然而,得益于元素之间的有序性,有序向量的查找、唯一化等操作都可更快地完成.因此在实施此类操作之前,都有必要先判断当前向量是否已经有序,以便确定是否可采用更为高效的接口

![image-20210712100443592](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712100443592.png)

### 唯一化

#### 低效版

![image-20210712102512361](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712102512361.png)

其正确性基于如下事实:

<center>有序向量中的重复元素必然前后紧邻</center>

于是,可以自前向后地逐一检查各对相邻元素:若二者雷同则调用remove( )接口删除靠后者,否则转向下一对相邻元素.如此,扫描结束后向量中将不再含有重复元素

#### 高效版

![image-20210712102816671](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712102816671.png)

### 查找

有序向量S中的元素不再随机分布,秩r是S[r]在S中按大小的相对位次,位于S[r]前(后)方的元素均不致于更大(小).当所有元素互异时, r即是S中小于S[r]的元素数目.一般地,若小于、等于S[r]的元素各有i、k个,则该元素及其雷同元素应集中分布于$S[i, i + k)$利用上述性质,有序向量的查找操作可以更加高效地完成

尽管在最坏情况下,无序向量的查找操作需要线性时间,但我们很快就会看到,有序向量的这一效率可以提升至$\sigma(\log n)$.为区别于无序向量的查找接口find(),有序向量的查找接口将统一命名为search()

![image-20210712132017879](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712132017879.png)

### 二分查找(版本A)

![image-20210712132049762](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712132049762.png)

![image-20210712132101550](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712132101550.png)

#### 复杂度

以上算法采取的策略可概括为,以"当前区间内居中的元素"作为目标元素的试探对象.从应对最坏情况的保守角度来看,这一策略是最优的.每一步迭代之后无论沿着哪个方向深入,新问题的规模都将缩小一半.因此,这一策略亦称作==二分查找==(binary search)也就是说,随着迭代的不断深入,有效的查找区间宽度将按1/2的比例以几何级数的速度递减.于是,经过至多1og2 (hi- 1o)步迭代后,算法必然终止.鉴于每步迭代仅需常数时间,故总体时间复杂度不超过:
$$
\sigma(\log_2(hi-l))=\sigma(\log n)
$$

#### 查找长度

以上迭代过程所涉及的计算,主要分为两类:元素的大小比较、秩的算术运算及其赋值.虽然二者均属于$\sigma(1)$复杂度的基本操作,但元素的秩无非是(无符号)整数,而向量元素的类型则通常更为复杂,甚至复杂到未必能够保证在常数时间内完成.因此就时间复杂度的常系数而言,前一类计算的权重远远高于后者,而查找算法的整体效率也更主要地取决于其中所执行的元素大小比较操作的次数,即所谓查找长度(search length) .通常,可针对查找成功或失败等情况,从最好、最坏和平均情况等角度,分别测算查找长度,并凭此对查找算法的总体性能做一评估

#### 成功查找长度

![image-20210712132828337](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712132828337.png)
$$
\sigma(1.5k)=\sigma(1.5\cdot\log_2n)
$$

#### 失败查找长度

仿照以上对平均成功查找长度的递推分析方法,不难证明,一般情况下的平均失败查找长度亦为$\sigma(1.5\cdot\log_2n)$

### Fibonacci查找

#### 递推方程

递推方程法既是复杂度分析的重要方法,也是我们优化算法时确定突破口的有力武器

实际上,最终求解所得到的平均复杂度,在很大程度上取决于这一等式.更准确地讲,主要取决于$(2^{k-1}-1)$和$2 \times (2^{k-1}-1)$两项,其中的$(2^{k-1}-1)$为子向量的宽度,而系数1和2则是算法为深入前、后子向量,所需做的比较操作次数.以此前的二分查找算法版本A为例,之所以存在均衡性方面的缺陷,根源正在于这两项的大小不相匹配

基于这一理解,不难找到解决问题的思路,具体地不外乎两种

* 其一,调整前、后区域的宽度,适当地加长(缩短)前(后)子向量其二
* 统一沿两个方向深入所需要执行的比较次数,比如都统一为一次

#### 黄金分割

实际上,减治策略本身并不要求子向量切分点mi必须居中,故按上述改进思路,不妨按黄金分割比来确定mi.为简化起见,不妨设向量长度$n=fib(k) -1$

![image-20210712135622570](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712135622570.png)

#### 实现

![image-20210712135753368](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712135753368.png)

![image-20210712135801159](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712135801159.png)

### 二分查找(版本B)

#### 从三分支到两分支

二分查找算法版本A的不均衡性体现为复杂度递推式中$(2^{k-1}-1)$和$2\times(2^{k-1}-1)$两项的不均衡.为此, Fibonacci查找算法已通过采用黄金分割点,在一定程度上"降低了时间复杂度的常系数.实际上还有另一更为直接的方法,即令以上两项的常系数同时等于1,也就是说,无论朝哪个方向深入,都只需做1次元素的大小比较.相应地,算法在每步迭代中(或递归层次上)都只有两个分支方向,而不再是三个

![image-20210712140011312](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712140011312.png)

#### 实现

![image-20210712140040890](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712140040890.png)

#### 性能

尽管版本B中的后端子向量需要加入A[mi],但得益于mi总是位于中央位置,整个算法$\sigma(\log n)$的渐进复杂度不受任何影响

在这一版本中,只有在向量有效区间宽度缩短至1个单元时算法才会终止,而不能如版本A那样,一旦命中就能及时返回.因此,最好情况下的效率有所倒退.当然,作为补偿,最坏情况下的效率相应地有所提高.实际上无论是成功查找或失败查找,版本B各分支的查找长度更加接近,故整体性能更趋稳定

### 二分查找(版本C)

#### 实现

![image-20210712155110992](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712155110992.png)

#### 正确性

版本C与版本B的差异,主要有三点.首先,只有当有效区间的宽度缩短至0(而不是1)时,查找方告终止.另外,在每次转入后端分支时,子向量的左边界取作mi +1而不是mi

表面上看,后一调整存在风险—此时只能确定切分点$A[mi] \leq e$"贸然"地将A[mi]排除在进一步的查找范围之外,似乎可能因遗漏这些元素,而导致本应成功的查找以失败告终

然而这种担心大可不必.通过数学归纳可以证明,版本C中的循环体,具有如下不变性:

<center>A[0, lo)中的元素皆不大于e;A[hi, n)中的元素皆大于e</center>

首次迭代时, lo=0且hi=n, A[0,lo)和A[hi, n)均空,不变性自然成立

![image-20210712155723419](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712155723419.png)

## 排序与下界

### 有序性

从数据处理的角度看,有序性在很多场合都能够极大地提高计算的效率

### 排序及其分类

有序向量的诸如查找等操作,效率远高于一般向量.因此在解决许多应用问题时我们普遍采用的一种策略就是,首先将向量转换为有序向量,再调用有序向量支持的各种高效算法.这一过程的本质就是向量的排序

排序算法是个庞大的家族,可从多个角度对其中的成员进行分类.比如,根据其处理数据的规模与存储的特点不同,可分为内部排序算法和外部排序算法:前者处理的数据规模相对不大,内存足以容纳;后者处理的数据规模很大,必须将借助外部甚至分布式存储器,在排序计算过程的任一时刻,内存中只能容纳其中一小部分数据.又如,根据输入形式的不同,排序算法也可分为离线算法(offline algorithm)和在线算法(online algorithm) .前一情况下,待排序的数据以批处理的形式整体给出;而在网络计算之类的环境中,待排序的数据通常需要实时生成,在排序算法启动后数据才陆续到达.再如,针对所依赖的体系结构不同,又可分为串行和并行两大类排序算法.另外,根据排序算法是否采用随机策略,还有确定式和随机式之分

### 复杂度下界

尽管很多算法都可以优化,但有一个简单的事实却往往为人所忽略:=对任一特定的应用问题,随着算法的不断改进,其效率的提高必然存在某一极限.毕竟,我们不能奢望不劳而获.这一极限不仅必然存在,而且其具体的数值,应取决于应用问题本身以及所采用的计算模型.一般地,任一问题在最坏情况下的最低计算成本,即为该问题的复杂度下界(lower bound).一旦某一算法的性能达到这一下界,即意味着它已是最坏情况下最优的(worst-case optimal)可见,尽早确定一个问题的复杂度下界,对相关算法的优化无疑会有巨大的裨益.比如上例所提出的问题,就是从最坏情况的角度,质疑"2次比对操作"是否为解决这一问题的最低复杂度.以下结合比较树模型,介绍界定问题复杂度下界的一种重要方法

### 比较树

#### 基于比较的分支

![image-20210712163749752](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712163749752.png)

这一转化方法也可以推广并应用于其它算法.一般地,树根节点对应于算法入口处的起始状态(如此处三个苹果已做好标记) ;内部节点(即非末端节点,图中以白色大圈示意)对应于过程中的某步计算,通常属于基本操作;叶节点(即末端节点,图中以黑色小圈示意)则对应于经一系列计算后某次运行的终止状态.如此借助这一树形结构,可以涵盖对应算法所有可能的执行流程

#### 比较树

算法所有可能的执行过程,都可涵盖于这一树形结构中.具体地,该树具有以下性质:

* 每一内部节点各对应于一次比对(称量)操作
* 内部节点的左、右分支,分别对应于在两种比对结果(是否等重)下的执行方向
* 叶节点(或等效地,根到叶节点的路径)对应于算法某次执行的完整过程及输出
* 反过来,算法的每一运行过程都对应于从根到某一叶节点的路径.

按上述规则与算法相对应的树,称作==比较树==(comparison tree)

### 估计下界

#### 最小树高

考查任一CBA式算法A,设CT(A)为与之对应的一棵比较树

==根据比较树的性质,算法A每一次运行所需的时间,将取决于其对应叶节点到根节点的距离(称作叶节点的深度);而算法A在最坏情况下的运行时间,将取决于比较树中所有叶节点的最大深度(称作该树的高度,记作h(CT(A)))==.因此就渐进的意义而言,算法A的时间复杂度应不低于$\Omega(h(CT(A)))$

对于存在CBA式算法的计算问题,既然其任一CBA式算法均对应于某棵比较树,该问题的复杂度下界就应等于这些比较树的最小高度.

估计这些比较树的最小高度,只需考查树中所含叶节点(可能的输出结果)的数目.具体地,在一棵高度为h的二叉树中,叶节点的数目不可能多于$2^h$.因此反过来,若某一问题的输出结果不少于$N$种,则比较树中叶节点也不可能少于N个,树高h不可能低于$\log_2N$

#### 苹果签别

就该问题而言,可能的输出结果共计N =3种(不同的苹果分别为A, B或C) ,故解决该问题的任一CBA式算法所对应比较树的高度为
$$
h \geq \lceil \log_23\rceil=2
$$
因此,只要是采用CBA式算法来求解该问题,则无论如何优化,在最坏情况下都至少需要2次称量—尽管最好情况下的确仍可能仅需1次.这也意味着,算法虽平淡无奇,却已是解决苹果鉴别问题的最佳CBA式算法

## 排序器

### 统一入口

![image-20210712170451894](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712170451894.png)

### 起泡排序

依次比较各对相邻元素,每当发现逆序即令二者彼此交换;一旦经过某趟扫描之后未发现任何逆序的相邻元素,即意味着排序任务已经完成,则通过返回标志"sorted" ,以便主算法及时终止

#### 起泡排序

![image-20210712173726561](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712173726561.png)

#### 扫描交换

![image-20210712173744151](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210712173744151.png)

# 列表

## 从向量到列表

不同数据结构内部的存储与组织方式各异,其操作接口的使用方式及时空性能也不尽相同.在设计或选用数据结构时,应从实际应用的需求出发,先确定功能规范及性能指标

## 从静态到动态

数据结构支持的操作,通常无非静态和动态两类:前者仅从中获取信息,后者则会修改数据结构的局部甚至整体.基于数组实现的向量结构,其size()和get()等静态操作均可在常数时间内完成,而insert()和remove()等动态操作却都可能需要线性时间.究其原因,在于"各元素物理地址连续"的约定-此即所谓的"静态存储"策略.得益于这种策略,可在$\sigma(1)$时间内由秩确定向量元素的物理地址;但反过来,在添加(删除)元素之前(之后) ,又不得不移动$\sigma(n)$个后继元素.可见,尽管如此可使静态操作的效率达到极致,但就动态操作而言,局部的修改可能引起大范围甚至整个数据结构的调整

==列表(list)结构尽管也要求各元素在逻辑上具有线性次序,但对其物理地址却未作任何限制-此即所谓"动态存储"策略.==具体地,在其生命期内,此类数据结构将随着内部数据的需要,相应地分配或回收局部的数据空间.如此,元素之间的逻辑关系得以延续,却不必与其物理次序相关.作为补偿,此类结构将通过指针或引用等机制,来确定各元素的实际物理地址.例如,链表(linked list)就是一种典型的动态存储结构.其中的数据,分散为一系列称作节点(node)的单位,节点之间通过指针相互索引和访问.为了引入新节点或删除原有节点,只需在局部,调整少量相关节点之间的指针.这就意味着,采用动态存储策略,至少可以大大降低动态操作的成本

### 由秩到位置

改用以上动态存储策略之后,在提高动态操作效率的同时,却又不得不舍弃原静态存储策略中循秩访问的方式,从而造成静态操作性能的下降.以采用动态存储策略的线性结构(比如链表)为例.尽管按照逻辑次序,每个数据元素依然具有秩这一指标,但为了访问秩为r的元素,我们只能顺着相邻元素之间的指针,从某一端出发逐个扫描各元素,经过r步迭代后才能确定该元素的物理存储位置.这意味着,原先只需$\sigma(1)$时间的静态操作,此时的复杂度也将线性正比于被访问元素的秩,在最坏情况下等于元素总数n;即便在各元素被访问概率相等的情况下,平均而言也需要$\sigma(n)$时间

对数据结构的访问方式,应与其存储策略相一致.此时,既然继续延用循秩访问的方式已非上策,就应更多地习惯于通过位置,来指代并访问动态存储结构中的数据元素.与向量中秩的地位与功能类似,列表中的位置也是指代各数据元素的一个标识性指标,借助它可以便捷地(比如在常数时间内)得到元素的物理存储地址.各元素的位置,通常可表示和实现为联接于元素之间的指针或引用.因此,基于此类结构设计算法时,应更多地借助逻辑上相邻元素之间的位置索引,以实现对目标元素的快速定位和访问,并进而提高算法的整体效率

### 列表

与向量一样,列表也是由具有线性逻辑次序的一组元素构成的集合:
$$
L = \{a_0, a_1,\dots, a_{n-1}\}
$$
列表是链表结构的一般化推广,其中的元素称作节点(node) ,分别由特定的位置或链接指代.与向量一样,在元素之间,也可定义前驱、直接前驱,以及后继、直接后继等关系;相对于任意元素,也有定义对应的前缀、后缀等子集

## 接口

### 列表节点

![image-20210713110203076](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210713110203076.png)

### ListNode模板类

![image-20210713110231881](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210713110231881.png)

### ADT按口

![image-20210713110258556](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210713110258556.png)

![image-20210713110307249](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210713110307249.png)

### List模板类

![image-20210713110747905](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210713110747905.png)

![image-20210713110835627](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210713110835627.png)

## 列表

### 头、尾节点

![image-20210713125337021](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210713125337021.png)

### 默认构造方法

![image-20210715123942546](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715123942546.png)

![image-20210715123955330](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715123955330.png)

### 由秩到位置的转换

![image-20210715124126005](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715124126005-1626324087523.png)

### 查找

![image-20210715124224653](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715124224653.png)

复杂度$\sigma(n)$

### 插入

#### 接口

![image-20210715124336632](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715124336632.png)

![image-20210715124345316](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715124345316.png)

#### 前插入

![image-20210715124450915](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715124450915.png)

![image-20210715124548377](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715124548377.png)

#### 后插入

![image-20210715124754613](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715124754613.png)

### 基于复制的构造

#### copyNodes()

![image-20210715151753335](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715151753335.png)

#### 基于复制的构造

![image-20210715152130266](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715152130266.png)

### 删除

![image-20210715152150551](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715152150551.png)

![image-20210715152400434](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715152400434.png)

### 析构

#### 释放资源及清除节点

![image-20210715152538711](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715152538711.png)

![image-20210715152547763](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715152547763.png)

### 唯一化

![image-20210715152747364](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715152747364.png)

### 遍历

![image-20210715152820520](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715152820520.png)

### 唯一化

![image-20210715153135769](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153135769.png)

### 查找

![image-20210715153217138](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153217138.png)

## 排序器

### 统一入口

![image-20210715153252238](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153252238.png)

### 插入排序

<center>在任何时刻,相对于当前节点e = S[r],前缀S[0, r)总是业已有序</center>

![image-20210715153447815](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153447815.png)

![image-20210715153536707](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153536707.png)

### 选择排序

<center>在任何时刻,后缀S[r, n)已经有序,且不小于前缀S[0, r)</center>

![image-20210715153725283](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153725283.png)

![image-20210715153806834](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153806834.png)

![image-20210715153919501](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153919501.png)

### 归并排序

![image-20210715153937567](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153937567.png)

![image-20210715153947460](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210715153947460.png)

# 栈与队列

## 栈

### 入栈与出栈

![image-20210718181447224](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210718181447224.png)

特质：后进先出

### stack模板类

![image-20210718182800278](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210718182800278.png)

## 栈与递归

### 函数调用栈

![image-20210718182927317](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210718182927317.png)

在windows等大部分操作系统中,每个运行中的二进制程序都配有一个调用栈(call stack)或执行栈(execution stack) .借助调用栈可以跟踪属于同一程序的所有函数,记录它们之间的相互调用关系,并保证在每一调用实例执行完毕之后,可以准确地返回

### 函数调用

调用栈的基本单位是帧(frame).每次函数调用时,都会相应地创建一帧,记录该函数实例在二进制程序中的返回地址(return address) ,以及局部变量、传入参数等,并将该帧压入调用栈.若在该函数返回之前又发生新的调用,则同样地要将与新函数对应的一帧压入栈中,成为新的栈顶.函数一旦运行完毕,对应的帧随即弹出,运行控制权将被交还给该函数的上层调用函数,并按照该帧中记录的返回地址确定在二进制程序中继续执行的位置

在任一时刻,调用栈中的各帧,依次对应于那些尚未返回的调用实例,亦即当时的活跃函数实例(active function instance).特别地,位于栈底的那帧必然对应于入口主函数main(),若它从调用栈中弹出,则意味着整个程序的运行结束,此后控制权将交还给操作系统

仿照递归跟踪法,程序执行过程出现过的函数实例及其调用关系,也可构成一棵树,称作该程序的运行树.任一时刻的所有活跃函数实例,在调用栈中自底到顶,对应于运行树中从根节点到最新活跃函数实例的一条调用路径.此外,调用栈中各帧还需存放其它内容.比如,因各帧规模不一,它们还需记录前一帧的起始地址,以保证其出栈之后前一帧能正确地恢复

### 避免递归

包括C++在内的各种高级程序设计语言几乎都允许函数直接或间接地自我调用,通过递归来提高代码的简洁度和可读性.而Cobol和Fortran等早期的程序语言虽然一开始并未采用栈来实现过程调用,但在其最新的版本中也陆续引入了栈结构来支持过程调用.尽管如此,==系统在后台隐式地维护调用栈的过程中,难以区分哪些参数和变量是对计算过程有实质作用的,更无法以通用的方式对它们进行优化,因此不得不将描述调用现场的所有参数和变量悉数入栈==.再加上每一帧都必须保存的执行返回地址以及前一帧起始位置,往往导致程序的空间效率不高甚至极低;同时,隐式的入栈和出栈操作也会令实际的运行时间增加不少.==因此在追求更高效率的场合,应尽可能地避免递归,尤其是过度的递归.==实际上,我们此前已经介绍过相应的方法和技巧

既然递归本身就是操作系统隐式地维护一个调用栈而实现的,我们自然也可以通过显式地模拟调用栈的运转过程,实现等效的算法功能.采用这一方式,程序员可以精细地裁剪栈中各帧的内容,从而尽可能降低空间复杂度的常系数.尽管算法原递归版本的高度概括性和简洁性将大打折扣,但毕竟在空间效率方面可以获得足够的补偿

## 匹配括号算法

#### 递归实现

![image-20210718220547022](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210718220547022.png)

### 迭代实现

![image-20210718205039561](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210718205039561.png)

## 队列

### 概述

先进先出

由以上的约定和限制不难看出,与栈结构恰好相反,队列中各对象的操作次序遵循所谓先进先出(first-in-first-out, FIFO)的规律:更早(晚)出队的元素应为更早(晚)入队者,反之,更早(晚)入队者应更早(晚)出队

### ADT接口

![image-20210722180644092](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210722180644092.png)

### Queue模板类

![image-20210722180853655](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210722180853655.png)

#  二叉树

根据其实现方式,这些数据结构大致可以分为两种类型:==基于数组的实现与基于链表的实现==.正如我们已经看到的,就其效率而言,二者各有长短

具体来说,前一实现方式允许我们通过下标或秩,在常数的时间内找到目标对象;然而,一旦需要对这类结构进行修改,那么无论是插入还是删除,都需要耗费线性的时间.反过来,后一实现方式允许我们借助引用或位置对象,在常数的时间内插入或删除元素;但是为了找出居于特定次序的元素,我们却不得不花费线性的时间,对整个结构进行遍历查找

能否将这两类结构的优点结合起来,并回避其不足呢?本章所讨论的树结构,将正面回答这一问题.在此前介绍的这些结构中,元素之间都存在一个自然的线性次序,故它们都属于所谓的线性结构( linear structure) .树则不然,其中的元素之间并不存在天然的直接后继或直接前驱关系.不过,正如我们马上就要看到的,只要附加某种约束(比如遍历) ,也可以在树中的元素之间确定某种线性次序,因此==树属于半线性结构==(semi-linear structure)无论如何,随着从线性结构转入树结构,我们的思维方式也将有个飞跃;相应地,算法设计的策略与模式也会因此有所变化,许多基本的算法也将得以更加高效地实现

树是一种分层结构,而层次化这一特征几乎蕴含于所有事物及其联系当中,成为其本质属性之一.从文件系统、互联网域名系统和数据库系统,一直到地球生态系统乃至人类社会系统,层次化特征以及层次结构均无所不在.有趣的是,作为树的特例,二叉树实际上并不失其一般性

## 二叉树及其表示

### 有根树

==从图论的角度看,树等价于连通无环图==.因此与一般的图相同,树也由一组顶点(vertex)以及联接与其间的若干条边(edge)组成.在计算机科学中,往往还会在此基础上,再指定某一特定顶点,并称之为根(root) .在指定根节点之后,我们也称之为有根树(rooted tree) .此时,从程序实现的角度,我们也更多地将顶点称作节点(node)

### 深度与层次

由树的连通性,每一节点与根之间都有一条路径相联;而根据树的无环性,由根通往每个节点的路径必然唯一.沿每个节点v到根r的唯一通路所经过边的数目,称作v的深度(depth) ,记作$depth(v)$​.依据深度排序,可对所有节点做分层归类.特别地,约定根节点的深度depth(r) =0,故属于第0层

### 祖先、后代与子树

任一节点v在通往树根沿途所经过的每个节点都是其祖先(ancestor) , v是它们的后代(descendant) .特别地, ==v的祖先/后代包括其本身==,而v本身以外的祖先/后代称作真祖先(proper ancestor) /真后代(properdescendant)

节点v历代祖先的层次, 自下而上以1为单位逐层递减;在每一层次上, v的祖先至多一个.特别地,若节点u是v的祖先且恰好比v高出一层,则称u是v的父亲(parent),v是u的孩子(child)

v的孩子总数,称作其度数或度(degree) ,记作deg(v).无孩子的节点称作叶节点(leaf) ,包括根在内的其余节点皆为内部节点(internal node) 

v所有的后代及其之间的联边称作子树(subtree) ,记作subtree(v).在不致歧义时,我们往往不再严格区分节点(v)及以之为根的子树(subtree(v) )

### 高度

树T中所有节点深度的最大值称作该树的高度(height) ,记作height(T)不难理解,树的高度总是由其中某一叶节点的深度确定的.特别地,本书约定,仅含单个节点的树高度为0,空树高度为-1.推而广之,任一节点v所对应子树subtree (v)的高度,亦称作该节点的高度,记作height(v).特别地,全树的高度亦即其根节点r的高度, $height(T) = height(r)$

### 二叉树

![image-20210723183616856](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210723183616856.png)

因此在二叉树中,同一父节点的孩子都可以左、右相互区分—此时,亦称作有序二叉树(ordered binary tree) .本书所提到的二叉树,默认地都是有序的

### 多叉树

一般地,树中各节点的孩子数目并不确定.每个节点的孩子均不超过k个的有根树,称作k叉树(k-ary tree) 

#### 父节点

在多叉树中,根节点以外的任一节点有且仅有一个父节点

将各节点组织为向量或列表,其中每个元素除保存节点本身的信息(node)外,还需要保存父节点(parent)的秩或位置.可为树根指定一个虚构的父节点-1或NULL,以便统一判断

如此,所有向量或列表所占的空间总量为$\sigma (n)$​,线性正比于节点总数n.时间方面,仅需常数时间,即可确定任一节点的父节点;但反过来,孩子节点的查找却不得不花费$\sigma (n)$​时间访遍所有节点

#### 孩子节点

![image-20210723184918865](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210723184918865.png)

若注重孩子节点的快速定位,令各节点将其所有的孩子组织为一个向量或列表.如此,对于拥有r个孩子的节点,可在$\sigma(r + 1)$​时间内列举出其所有的孩子

#### 父节点+孩子节点

![image-20210723185139261](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210723185139261-16270375006321.png)

以上父节点表示法和孩子节点表示法各有所长,但也各有所短.为综合二者的优势,消除缺点,令各节点既记录父节点,同时也维护一个序列以保存所有孩子

尽管如此可以高效地兼顾对父节点和孩子的定位,但在节点插入与删除操作频繁的场合,为动态地维护和更新树的拓扑结构,不得不反复地遍历和调整一些节点所对应的孩子序列.然而,向量和列表等线性结构的此类操作都需耗费大量时间,势必影响到整体的效率

#### 有序多叉树=二叉树

解决上述难题的方法之一,就是采用支持高效动态调整的二叉树结构.为此,==必须首先建立起从多叉树到二叉树的某种转换关系,并使得在此转换的意义下,任一多叉树都等价于某棵二叉树==.当然,为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树,我们只需给多叉树增加一项约束条件—同一节点的所有孩子之间必须具有某一线性次序

仿照有序二叉树的定义,凡符合这一条件的多叉树也称作==有序树==(ordered tree).幸运的是,这一附加条件在实际应用问题中往往自然满足.以互联网域名系统所对应的多叉树为例,其中同一域名下的分支通常即按照字典序排列

#### 长子 + 兄弟

![image-20210723185937873](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210723185937873.png)

有序多叉树中任一非叶节点都有唯一的"长子",而且从该"长子"出发,可按照预先约定或指定的次序遍历所有孩子节点.为每个节点设置两个指针,分别指向其"长子"和下一"兄弟"

尽管二叉树只是多叉树的一个子集,但其对应用问题的描述与刻画能力绝不低于后者.实际上以下我们还将进一步发现,即便是就计算效率而言,二叉树也并不逊色于一般意义上的树.反过来,得益于其定义的简洁性以及结构的规范性,二叉树所支撑的算法往往可以更好地得到描述,更加简捷地得到实现.二叉树的身影几乎出现在所有的应用领域当中,这也是一个重要的原因

## 编码树

通讯理论中的一个基本问题是,如何在尽可能低的成本下,以尽可能高的速度,尽可能忠实地实现信息在空间和时间上的复制与转移.在现代通讯技术中,无论采用电、磁、光或其它任何形式,在信道上传递的信息大多以二进制比特的形式表示和存在,而每一个具体的编码方案都对应于一棵二叉编码树

### 二进制编码

在加载到信道上之前,信息被转换为二进制形式的过程称作编码(encoding);反之,经信道抵达目标后再由二进制编码恢复原始信息的过程称作解码(decoding)

![image-20210723191551917](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210723191551917.png)

编码和解码的任务分别由发送方和接收方分别独立完成,故在开始通讯之前,双方应已经以某种形式,就编码规则达成过共同的约定或协议

### 生成编码表

原始信息的基本组成单位称作字符,它们都来自于某一特定的有限集合$\Sigma$​,也称作字符集 （alphabet）。而以二进制形式承载的信息,都可表示为来自编码表$Γ =\{0, 1\}$*的某一特定二进制串。从这个角度理解,每一编码表都是从字符集$\Sigma$​到编码表Γ的一个单射,编码就是对信息文本中各字符逐个实施这一映射的过程,而解码则是逆向映射的过程

编码表一旦制定,信息的发送方与接收方之间也就建立起了一个约定与默契,从而使得独立的编码与解码成为可能

### 二进制编码

所谓编码就是对于任意给定的文本，通过查阅编码表逐一将其中的字符转译为二进制编码，这些编码依次串接起来即得到了全文的编码

### 二进制解码

由编码器生成的二进制流经信道送达之后，接收方可以按照事先约定的编码表，依次扫描各比特位，并经匹配逐一转译出各字符，从而最终恢复出原始的文本

### 解码歧义

请注意，编码方案确定之后，尽管编码结果必然确定，但解码过程和结果却不见得唯一

### 前缀无歧义编码

解码过程之所以会出现上述歧义甚至错误，根源在于编码表制订不当。这里的解码算法采用的是，按顺序对信息比特流做子串匹配的策略，因此为消除匹配的歧义性，任何两个原始字符所对应的二进制编码串，相互都不得是前缀

只要各字符的编码串互不为前缀，则即便出现无法解码的错误，也绝对不致歧义。这类编码方案即所谓的“前缀无歧义编码”（prefix-free code），简称PFC编码。此类编码算法，可以明确地将二进制编码串，分割为一系列与各原始字符对应的片段，从而实现无歧义的解码。得益于这一特点，此类算法在整个解码过程中，对信息比特流的扫描不必回溯。

## 二叉编码树

### 根通路与节点编码

任一编码方案都可描述为一棵二叉树：从根节点出发，每次向左（右）都对应于一个0（1）比特位

由从根节点到每个节点的唯一通路，可以为各节点v赋予一个互异的二进制串，称作根通路串（root path string），记作rps(v)。当然，|rps(v)| = depth(v)就是v的深度

### PFC编码树

![image-20210724171826045](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210724171826045.png)

### 基于PFC编码树的解码

依据PFC编码树可便捷地完成编码串的解码

解码过程甚至可以在二进制编码串的接收过程中实时进行，而不必等到所有比特位都到达之后才开始，因此这类算法属于在线算法

### PFC编码树的构造

PFC编码方案可由PFC编码树来描述，由编码树不仅可以快速生成编码表，而且直接支持高效的解码

## 二叉树的实现

### 二叉树节点

![image-20210728161319868](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728161319868.png)

![image-20210728161836104](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728161836104.png)

![image-20210728161846052](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728161846052.png)

### 二叉树

### BinTree模板类



![image-20210728162016004](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728162016004.png)

![image-20210728162027473](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728162027473.png)

### 高度更新

![image-20210728162149685](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728162149685.png)

### 节点插入

![image-20210728162255109](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728162255109.png)

![image-20210728162801598](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728162801598.png)

### 子树接入

![image-20210728163255163](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728163255163.png)

![image-20210728163454419](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728163454419.png)

### 子树删除

![image-20210728163842973](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728163842973.png)

### 子树分离

![image-20210728164503704](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728164503704.png)

## 遍历

### 递归式遍历

![image-20210728165112899](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728165112899.png)

#### 先序遍历

![image-20210728165526927](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728165526927.png)

![image-20210728165556490](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728165556490.png)

#### 后序遍历

![image-20210728165637993](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728165637993.png)

![image-20210728165650620](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728165650620.png)

#### 中序遍历

![image-20210728165713210](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728165713210.png)

![image-20210728165722269](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728165722269.png)

### 迭代版先序遍历

![image-20210728185424198](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728185424198.png)

![image-20210728183945353](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728183945353.png)

![image-20210728183952915](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728183952915.png)

### 迭代版中序遍历

![image-20210728192520476](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728192520476.png)

![image-20210728184126374](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728184126374.png)

#### 直接后继及其定位

![image-20210728184908579](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728184908579.png)

![image-20210728185209467](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728185209467.png)

![image-20210728185226625](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728185226625.png)

![image-20210728192941910](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728192941910.png)

### 迭代版后序遍历

![image-20210728193216880](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728193216880.png)

![image-20210728185306170](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728185306170.png)

![image-20210728185316766](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728185316766.png)

### **层次遍历**

![image-20210728193653956](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728193653956.png)

![image-20210728193724752](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728193724752.png)

#### 完全二叉树

![image-20210728194314622](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728194314622.png)

完全二叉树的实例，及其一般性的宏观拓扑结构特征：叶节点只能出现在最底部的两层，且最底层叶节点均处于次底层叶节点的左侧

#### 满二叉树

所有叶节点同处于最底层（非底层节点均为内部节点）

![image-20210728194559711](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210728194559711.png)

# 图

图结构是描述和解决实际应用问题的一种基本而有力的工具。所谓的图（graph），可定义为G = (V, E)。其中，集合V中的元素称作顶点（vertex）；集合E中的元素分别对应于V中的 某一对顶点(u, v)，表示它们之间存在某种关系，故亦称作边（edge）。

一种直观显示图结构的方法是，用小圆圈或小方块代表顶点，用联接于其间的直线段或曲线弧表示对应的边。从计算的需求出发，我们约定V和E均为有限集，通常将其规模分别记n = |V|和e = |E|。

## 无向图、有向图及混合图

若边(u, v)所对应顶点u和v的次序无所谓，则称作无向边（undirected edge），例如表示同学关系的边。反之若u和v不对等，则称(u, v)为有向边（directed edge），例如描述企业与银行之间的借贷关系，或者程序之间的相互调用关系的边

如此，无向边(u, v)也可记作(v, u)，而有向的(u, v)和(v, u)则不可混淆。这里约定，有向边(u, v)从u指向v，其中u称作该边的起点（origin）或尾顶点（tail），而v称作该边的终点（destination）或头顶点（head）。

![image-20210801124914199](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801124914199.png)

## 度

对于任何边e = (u, v)，称顶点u和v彼此邻接（adjacent），互为邻居；而它们都与边e彼此关联（incident）。在无向图中，与顶点v关联的边数，称作v的度数（degree），记作deg(v)。

## 简单图 

联接于同一顶点之间的边，称作自环（self-loop）。在某些特定的应用中，这类边可能的确具有意义—比如在城市交通图中，沿着某条街道，有可能不需经过任何交叉路口即可直接返回原处。不含任何自环的图称作简单图（simple graph）

## 通路与环路

所谓路径或通路（path），就是由m + 1个顶点与m条边交替而成的一个序列： 
$$
\pi = \{ v_0, e_1, v_1, e_2, v_2, ..., e_m, v_m \}
$$
且对任何$0 < i \leq m$​​都有$e_i = (v_{i-1}, v_i)$​。也就是说，这些边依次地首尾相联。其中沿途边的总数m，亦称作通路的长度，记作$|\pi| = m$。

为简化描述，也可依次给出通路沿途的各个顶点，而省略联接于其间的边，即表示为：

$\pi = \{ v_0, v_1, v_2, ..., v_m \}$​

图6.2(a)中的{ C, A, B, A, D }，即是从顶点C到D的一条通路，其长度为4。可见，尽管通路上的边必须互异，但顶点却可能重复。沿途顶点互异的通路，称作简单通路（simple path）。在图6.2(b)中，{ C, A, D, B }即是从顶点C到B的一条简单通路，其长度为3。

特别地，对于长度$m \ge 1$的通路，若起止顶点相同（即v0 = vm），则称作环路（cycle），其长度也取作沿途边的总数。图6.3(a)中，{ C, A, B, A, D, B, C }即是一条环路，其长度为6。反之，不含任何环路的有向图，称作有向无环图（directed acyclic graph, DAG）。

同样，尽管环路上的各边必须互异，但顶点却也可能重复。反之若沿途除$v_e = v_m$外所有顶点均互异，则称作简单环路（simple cycle）。例如，图6.3(b)中的{ C, A, B, C }即是一条简单环路，其长度为3。特别地，经过图中各边一次且恰好一次的环路，称作欧拉环路（Eulerian tour）当然，其长度也恰好等于图中边的总数e。

图6.4(a)中的{ C, A, B, A, D, C, D, B, C }即是一条欧拉环路，其长度为8。对偶地，经过图中各顶点一次且恰好一次的环路，称作哈密尔顿环路（Hamiltonian tour），其长度亦等于构成环路的边数。图6.4(b)中，{ C, A, D, B, C }即是一条长度为4的哈密尔顿环路。

![image-20210801132620865](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801132620865.png)

## 带权网络

图不仅需要表示顶点之间是否存在某种关系，有时还需要表示这一关系的具体细节。以铁路运输为例，可以用顶点表示城市，用顶点之间的联边，表示对应的城市之间是否有客运铁路联接；同时，往往还需要记录各段铁路的长度、承运能力，以及运输成本等信息。为适应这类应用要求，需通过一个权值函数，为每一边e指定一个权重（weight），比如wt(e)

即为边e的权重。各边均带有权重的图，称作带权图（weighted graph）或带权网络（weighted network），有时也简称网络（network），记作G(V, E, wt())。 

## 复杂度

对于无向图，每一对顶点至多贡献一条边，故总共不超过$n(n - 1)/2$​​条边，且这个上界由完全图达到。对于有向图，每一对顶点都可能贡献（互逆的）两条边，因此至多可有n(n - 1)条边。总而言之，必有$e = \sigma(n^2)$。

## 抽象数据类型

### 操作接口

![image-20210801133645580](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801133645580-16277962069451.png)

### Graph模板类

![image-20210801151259682](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801151259682.png)

![image-20210801151310304](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801151310304.png)

## 邻接矩阵

![image-20210801151702226](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801151702226.png)

### 实现

![image-20210801152116516](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801152116516.png)

![image-20210801152229384](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801152229384.png)

![image-20210801152353275](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801152353275.png)

### 时间性能

按照代码6.2的实现方式，各顶点的编号可直接转换为其在邻接矩阵中对应的秩，从而使得图ADT中所有的静态操作接口，均只需$\sigma(1)$时间—这主要是得益于向量“循秩访问”的特长与优势。另外，边的静态和动态操作也仅需$\sigma(1)$​时间—其代价是邻接矩阵的空间冗余。

然而，这种方法并非完美无缺。其不足主要体现在，顶点的动态操作接口均十分耗时。为了插入新的顶点，顶点集向量V[]需要添加一个元素；边集向量E[][]也需要增加一行，且每行都需要添加一个元素。顶点删除操作，亦与此类似。不难看出，这些恰恰也是向量结构固有的不足。好在通常的算法中，顶点的动态操作远少于其它操作。而且，即便计入向量扩容的代价，就分摊意义而言，单次操作的耗时亦不过$\sigma(n)$。

### 空间性能

上述实现方式所用空间，主要消耗于邻接矩阵，亦即其中的二维边集向量E[][]。每个Edge对象虽需记录多项信息，但总体不过常数。根据2.4.4节的分析结论，Vector结构的装填因子始终不低于50%，故空间总量渐进地不超过$\sigma(n \times n) = \sigma(n^2)$​。

当然，对于无向图而言，仍有改进的余地。如图6.5(a)所示，无向图的邻接矩阵必为对称阵，其中除自环以外的每条边，都被重复地存放了两次。也就是说，近一半的单元都是冗余的。为消除这一缺点，可采用压缩存储等技巧，进一步提高空间利用率（习题[6-4]）。

## 邻接表

### 原理

邻接矩阵的空间效率之所以低，是因为其中大量单元所对应的边，通常并未在图中出现。

![image-20210801154130750](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801154130750.png)

### 复杂度

可见，邻接表所含列表数等于顶点总数n，每条边在其中仅存放一次（有向图）或两次（无向图），故空间总量为$\sigma(n + e)$，与图自身的规模相当，较之邻接矩阵有很大改进。

当然，空间性能的这一改进，需以某些方面时间性能的降低为代价。比如，为判断顶点v到 u的联边是否存在，exists(v, u)需在v对应的邻接表中顺序查找，共需$\sigma(n)$时间。

与顶点相关操作接口，时间性能依然保持，甚至有所提高。比如，顶点的插入操作，可在$\sigma(1)$​​而不是$\sigma(n)$​时间内完成。当然，顶点的删除操作，仍需遍历所有邻接表，共需$\sigma(e)$时间。

尽管邻接表访问单条边的效率并不算高，却十分擅长于以批量方式，处理同一顶点的所有关联边。在以下图遍历等算法中，这是典型的处理流程和模式。比如，为枚举从顶点v发出的所有边，现在仅需$\

$\Theta(1 + outDegree(v))$​而非$\Theta(n)$​​时间。故总体而言，邻接表的效率较之邻接矩阵更高。

## 图遍历算法

实际上，无论采用何种策略和算法，图的遍历都可理解为，将非线性结构转化为半线性结构的过程。经遍历而确定的边类型中，最重要的一类即所谓的树边，它们与所有顶点共同构成了原图的一棵支撑树（森林），称作遍历树（traversal tree）。以遍历树为背景，其余各种类型的边，也能提供关于原图的重要信息，比如其中所含的环路等。

## 广度优先搜索

### 策略

各种图搜索之间的区别，体现为边分类结果的不同，以及所得遍历树（森林）的结构差异。其决定因素在于，搜索过程中的每一步迭代，将依照何种策略来选取下一接受访问的顶点。

通常，都是选取某个已访问到的顶点的邻居。同一顶点所有邻居之间的优先级，在多数遍历中不必讲究。因此，实质的差异应体现在，当有多个顶点已被访问到，应该优先从谁的邻居中选取下一顶点。比如，广度优先搜索（breadth-first search, BFS）采用的策略，可概括为：

<center>越早被访问到的顶点，其邻居越优先被选用</center>

于是，始自图中顶点s的BFS搜索，将首先访问顶点s；再依次访问s所有尚未访问到的邻居； 再按后者被访问的先后次序，逐个访问它们的邻居；...；如此不断。在所有已访问到的顶点中，仍有邻居尚未访问者，构成所谓的波峰集（frontier）。于是，BFS搜索过程也可等效地理解为：

<center>反复从波峰集中找到最早被访问到顶点v，若其邻居均已访问到，则将其逐出波集；否则，随意选出一个尚未访问到的邻居，并将其加入到波峰集中</center>
不难发现，若将上述BFS策略应用于树结构，则效果等同于层次遍历—波峰集内顶点的深度始终相差不超过一，且波峰集总是优先在更浅的层次沿广度方向拓展。实际上，树层次遍历的这些特性，在一定程度上也适用于图的BFS搜索。由于每一步迭代都有一个顶点被访问，故至多迭代$\sigma(n)$​步。另一方面，因为不会遗漏每个刚被访问顶点的任何邻居，故对于无向图必能覆盖s所属的连通分量（connected component），对于有向图必能覆盖以s为起点的可达分量（reachable component）。倘若还有来自其它连通分量或可达分量的顶点，则不妨从该顶点出发，重复上述过程。

### 实现

![image-20210801162202685](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801162202685.png)

算法的实质功能，由子算法BFS()完成。对该函数的反复调用，即可遍历所有连通或可达域。仿照树的层次遍历，这里也借助队列Q，来保存已被发现，但尚未访问完毕的顶点。因此，任何顶点在进入该队列的同时，都被随即标记为DISCOVERED（已发现）状态。

BFS()的每一步迭代，都先从Q中取出当前的首顶点v；再逐一核对其各邻居u的状态并做相应处理；最后将顶点v置为VISITED（访问完毕）状态，即可进入下一步迭代。

若顶点u尚处于UNDISCOVERED（未发现）状态，则令其转为DISCOVERED状态，并随即加入队列Q。实际上，每次发现一个这样的顶点u，都意味着遍历树可从v到u拓展一条边。于是，将 边(v, u)标记为树边（tree edge），并按照遍历树中的承袭关系，将v记作u的父节点。

若顶点u已处于DISCOVERED状态（无向图），或者甚至处于VISITED状态（有向图），则意味着边(v, u)不属于遍历树，于是将该边归类为跨边（cross edge）

BFS()遍历结束后，所有访问过的顶点通过parent[]指针依次联接，从整体上给出了原图某一连通或可达域的一棵遍历树，称作广度优先搜索树，或简称BFS树（BFS tree）。

![image-20210801182517188](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801182517188.png)

### 复杂度

除作为输入的图本身外，BFS搜索所使用的空间，主要消耗在用于维护顶点访问次序的辅助队列、用于记录顶点和边状态的标识位向量，累计$\sigma(n) + \sigma(n) + \sigma(e) = \sigma(n + e)$​。

时间方面，首先需花费$\sigma(n + e)$​​​​​时间复位所有顶点和边的状态。不计对子函数BFS()的调用，bfs()本身对所有顶点的枚举共需$\sigma(n)$​​​时间。而在对BFS()的所有调用中，每个顶点、每条边均只耗费$\sigma(1)$​​时间，累计$\sigma(n + e)$​。综合起来，BFS搜索总体仅需$\sigma(n + e)$时间。

## 深度优先搜索

深度优先搜索（Depth-First Search, DFS）选取下一顶点的策略，可概括为：

<center>优先选取最后一个被访问到的顶点的邻居</center>

于是，以顶点s为基点的DFS搜索，将首先访问顶点s；再从s所有尚未访问到的邻居中任取其一，并以之为基点，递归地执行DFS搜索。故各顶点被访问到的次序，类似于树的先序遍历。

### 实现

![image-20210801185818847](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801185818847.png)

算法的实质功能，由子算法DFS()递归地完成。每一递归实例中，都先将当前节点v标记为DISCOVERED（已发现）状态，再逐一核对其各邻居u的状态并做相应处理。待其所有邻居均已处理完毕之后，将顶点v置为VISITED（访问完毕）状态，便可回溯。

若顶点u尚处于UNDISCOVERED（未发现）状态，则将边(v, u)归类为树边（tree edge），并将v记作u的父节点。此后，便可将u作为当前顶点，继续递归遍历。

若顶点u处于DISCOVERED状态，则意味着在此处发现一个有向环路。此时，在DFS遍历树中u必为v的祖先，故应将边(v, u)归类为后向边（back edge）

这里为每个顶点v都记录了被发现的和访问完成的时刻，对应的时间区间[dTime(v),  fTime(v)]均称作v的活跃期（active duration）。实际上，任意顶点v和u之间是否存在祖先/后代的“血缘”关系，完全取决于二者的活跃期是否相互包含。

对于有向图，顶点u还可能处于VISITED状态。此时，只要比对v与u的活跃期，即可判定在DFS树中v是否为u的祖先。若是，则边(v, u)应归类为前向边（forward edge）；否则，二者必然来自相互独立的两个分支，边(v, u)应归类为跨边（cross edge）。

DFS(s)返回后，所有访问过的顶点通过parent[]指针依次联接，从整体上给出了顶点s所属连通或可达分量的一棵遍历树，称作深度优先搜索树或DFS树（DFS tree）。与BFS搜索一样，此时若还有其它的连通或可达分量，则可以其中任何顶点为基点，再次启动DFS搜索。最终，经各次DFS搜索生成的一系列DFS树，构成了DFS森林（DFS forest）

![image-20210801192250062](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801192250062.png)

![image-20210801192420460](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210801192420460.png)

## 拓扑排序

### 有向无环图

有向无环图的拓扑排序必然存在；反之亦然。这是因为，有向无环图对应于偏序关系，而拓扑排序则对应于全序关系。在顶点数目有限时，与任一偏序相容的全序必然存在。

任一有限偏序集，必有极值元素（尽管未必唯一）；类似地，任一有向无环图，也必包含入度为零的顶点。否则，每个顶点都至少有一条入边，意味着要么顶点有无穷个，要么包含环路。

### 算法

不妨将关注点，转至与极大顶点相对称的极小顶点。

同理，有限偏序集中也必然存在极小元素（同样，未必唯一）。该元素作为顶点，出度必然为零。而在对有向无环图的DFS搜索中，首先因访问完成而转换至VISITED状态的顶点m，也必然具有这一性质；反之亦然。

进一步地，根据DFS搜索的特性，顶点m（及其关联边）对此后的搜索过程将不起任何作用。于是，下一转换至VISITED状态的顶点可等效地理解为是，从图中剔除顶点m（及其关联边）之后的出度为零者—在拓扑排序中，该顶点应为顶点m的前驱。由此可见，DFS搜索过程中各顶点被标记为VISITED的次序，恰好（按逆序）给出了原图的一个拓扑排序。此外，DFS搜索善于检测环路的特性，恰好可以用来判别输入是否为有向无环图。具体地，搜索过程中一旦发现后向边，即可终止算法并报告“因非DAG而无法拓扑排序”。

### 实现

![image-20210803181401971](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803181401971.png)

相对于标准的DFS搜索算法，这里增设了一个栈结构。一旦某个顶点被标记为VISITED状态，便随即令其入栈。如此，当搜索终止时，所有顶点即按照被访问完毕的次序—亦即拓扑排序的次序—在栈中自顶而下排列。

## 双连通域分解

### 关节点与双连通域

考查无向图G。若删除顶点v后G所包含的连通域增多，则v称作切割节点（cut vertex）或关节点（articulation point）。如图6.13中的C即是一个关节点—它的删除将导致连通域增加两块。反之，不含任何关节点的图称作双连通图。任一无向图都可视作由若干个极大的双连通子图组合而成，这样的每一子图都称作原图的一个双连通域（bi-connected component）。例如图6.14(a)中的无向图，可分解为如图(b)所示的三个双连通域。

![image-20210803184529702](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803184529702.png)

### 蛮力算法

由其定义，可直接导出蛮力算法大致如下：首先，通过BFS或DFS搜索统计出图G所含连通域的数目；然后逐一枚举每个顶点v，暂时将其从图G中删去，并再次通过搜索统计出图G\{v}所含连通域的数目。于是，顶点v是关节点，当且仅当图G\{v}包含的连通域多于图G。这一算法需执行n趟搜索，耗时*O*(n(n + e))，如此低的效率无法令人满意。

### 可行算法

![image-20210803185007974](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803185007974.png)



![image-20210803185542752](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803185542752.png)

### 实现

![image-20210803185603754](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803185603754.png)

## 优先级搜索

### 优先级与优先级数

以上图搜索应用虽各具特点，但其基本框架却颇为相似。总体而言，都需通过迭代逐一发现各顶点，将其纳入遍历树中并做相应处理，同时根据应用问题的需求，适时给出解答。各算法在功能上的差异，主要体现为每一步迭代中对新顶点的选取策略不同。比如，==BFS搜索会优先考查更早被发现的顶点，而DFS搜索则恰好相反，会优先考查最后被发现的顶点。==

每一种选取策略都等效于，给所有顶点赋予不同的优先级，而且随着算法的推进不断调整； 而每一步迭代所选取的顶点，都是当时的优先级最高者。按照这种理解，包括BFS和DFS在内的几乎所有图搜索，都可纳入统一的框架。鉴于优先级在其中所扮演的关键角色，故亦称作优先级搜索（priority-first search, PFS），或最佳优先搜索（best-first search, BFS）。

### 基本框架

![image-20210803190238368](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803190238368.png)

这里借助函数对象prioUpdater，使算法设计者得以根据不同的问题需求，简明地描述和实现对应的更新策略。具体地，只需重新定义prioUpdater对象即可，而不必重复实现公共部分。比如，此前的BFS搜索和DFS搜索都可按照此模式统一实现。

### 复杂度

PFS搜索由两重循环构成，其中内层循环又含并列的两个循环。若采用邻接表实现方式，同时假定prioUpdater()只需常数时间，则前一内循环的累计时间应取决于所有顶点的出度总和，即*O*(e)；后一内循环固定迭代n次，累计*O*(n2）时间。两项合计总体复杂度为*O*(n2)。实际上，借助稍后第10章将要介绍的优先级队列等结构，PFS搜索的效率还有进一步提高的余地。

## 最小支撑树

### 支撑树

连通图G的某一无环连通子图T若覆盖G中所有的顶点，则称作G的一棵支撑树或生成树（spanning tree）。

![image-20210803190639878](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803190639878.png)

若图G为一带权网络，则每一棵支撑树的成本（cost）即为其所采用各边权重的总和。在G的所有支撑树中，成本最低者称作最小支撑树（minimum spanning tree, MST）。聚类分析、网络架构设计、VLSI布线设计等诸多实际应用问题，都可转化并描述为最小撑树的构造问题。在这些应用中，边的权重大多对应于某种可量化的成本，因此作为对应优化问题的基本模型，最小支撑树的价值不言而喻。另外，最小支撑树构造算法也可为一些NP问题提供足够快速、足够接近的近似解法（习题[6-22]）。正因为受到来自众多应用和理论领域的需求推动，最小支撑树的构造算法也发展得较为成熟。

### 歧义性

尽管同一带权网络通常都有多棵支撑树，但总数毕竟有限，故必有最低的总体成本。然而，总体成本最低的支撑树却未必唯一。以包含三个顶点的完全图为例，若三条边的权重相等，则其中任意两条边都构成总体成本最低的一棵支撑树。 

![image-20210803192113567](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803192113567.png)

### 蛮力算法

由最小支撑树的定义，可直接导出蛮力算法大致如下：逐一考查G的所有支撑树并统计其成本，从而挑选出其中的最低者。然而根据Cayley公式，由n个互异顶点组成的完全图共有nn-2棵支撑树，即便忽略掉构造所有支撑树所需的成本，仅为更新最低成本的记录就需要*O*(nn-2)时间。

事实上基于PFS搜索框架，并采用适当的顶点优先级更新策略，即可得出如下高效的最小支撑树构造算法。

### Prim算法

#### 割与极短跨越边

图G = (V; E)中，顶点集V的任一非平凡子集U及其补集V\U都构成G的一个割（cut），记作(U : V\U)。若边uv满足$u\in U$​且$v\notin U$，则称作该割的一条跨越边（crossing edge）。因此类边联接于V及其补集之间，故亦形象地称作该割的一座桥（bridge）。

Prim算法的正确性基于以下事实：最小支撑树总是会采用联接每一割的最短跨越边。否则，如图6.20(a)所示假设uv是割(U : V\U)的最短跨越边，而最小支撑树T并未采用该边。于是由树的连通性，如图(b)所示在T中必有至少另一跨边st联接该割（有可能s = u或t = v，尽管二者不能同时成立）。同样由树的连通性，T中必有分别联接于u和s、v和t之间的两条通路。由于树是极大的无环图，故倘若将边uv加至T中，则如图(c)所示，必然出现穿过u、v、t 和s的唯一环路。接下来，只要再删除边st，则该环路必然随之消失。

![image-20210803194254791](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803194254791.png)

![image-20210803194503502](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803194503502.png)

## 最短路径

### 最短路径树

#### 单调性

![image-20210803195303978](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803195303978.png)

#### 歧义性

较之最小支撑树，最短路径的歧义性更难处理。首先，即便各边权重互异，从s到v的最短路径也未必唯一（习题[6-31]）。另外，当存在非正权重的边，并导致某个环路的总权值非正时，最短路径甚至无从定义。因此以下不妨假定，带权网络G内各边权重均大于零。

### Dijkstra算法

![image-20210803200202372](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210803200202372.png)

# 搜索树

![image-20210805220627070](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210805220627070.png)

## 查找

### 循关键码访问

所谓的查找或搜索（search），指从一组数据对象中找出符合特定条件者，这是构建算法的一种基本而重要的操作。其中的数据对象，统一地表示和实现为词条（entry）的形式；不同词条之间，依照各自的关键码（key）彼此区分。根据身份证号查找特定公民，根据车牌号查找特定车辆，根据国际统一书号查找特定图书，均属于根据关键码查找特定词条的实例。

### 词条

![image-20210805221500158](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210805221500158.png)

词条对象拥有成员变量key和value。前者作为特征，是词条之间比对和比较的依据；后者为实际的数据。若词条对应于商品的销售记录，则key为其条形扫描码，value可以是其单价或库存量等信息。设置词条类只为保证查找算法接口的统一，故不必过度封装。

###  序与比较器

通过重载对应的操作符，可将词条的判等与比较等操作转化为关键码的判等与比较（故在不致歧义时，往往无需严格区分词条及其关键码）。当然，这里隐含地做了一个假定所有词条构成一个全序关系，可以相互比对和比较。需指出的是，这一假定条件不见得总是满足。

实际上，任意词条之间可相互比较大小，也是此前有序向量得以定义，以及二分查找算法赖以成立的基本前提。

## 二叉搜索树

### 顺序性

若二叉树中各节点所对应的词条之间支持大小比较，则在不致歧义的情况下，我们可以不必严格区分树中的节点、节点对应的词条以及词条内部所存的关键码。

<center><b>一节点r的左（右）子树中，所有节点（若存在）均不大于（不小于）r </b></center>

![image-20210805223617641](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210805223617641.png)

<center><b>任一节点r的左（右）子树中，所有节点（若存在）均小于（大于）r </b></center>

### 中序遍历序列

![image-20210805223717636](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210805223717636.png)

<center><b>任何一棵二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降</b></center>

### BST模板类

![image-20210805224024403](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210805224024403.png)

### 查找算法及其实现

<center><b>从树根出发,逐步地缩小查找范围,直到发现目标(成功)或缩小至空树(失败)

![image-20210806180655006](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806180655006.png)

一般地，在上述查找过程中，一旦发现当前节点为NULL，即说明查找范围已经缩小至空，查找失败；否则，视关键码比较结果，向左（更小）或向右（更大）深入，或者报告成功（相等）。

#### searchIn()算法与search()接口

![image-20210806181326930](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806181326930.png)

![image-20210806182518913](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806182518913.png)

#### 语义约定

![image-20210806182954458](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806182954458.png)

在调用searchIn()算法之前，search()接口首先将内部变量_hot初始化为NULL，然后作 为引用型参数hot传递给searchIn()。在整个查找的过程中，hot变量始终指向当前节点的父亲。因此在算法返回时，按照如上定义，_hot亦将统一指向“命中节点”的父亲。

请注意，_hot节点是否拥有另一个孩子，与查找成功与否无关。查找成功时，节点e可能是叶子，也可能是内部节点；查找失败时，假想的哨兵e等效于叶节点，但可能有兄弟。

#### 效率

在二叉搜索树的每一层，查找算法至多访问一个节点，且只需常数时间，故总体所需时间线性正比于查找路径的长度，或最终返回节点的深度。在最好情况下，目标关键码恰好出现在根处（或其附近），此时只需*O*(1)时间。然而不幸的是，对于规模为n的二叉搜索树，深度在坏情况下可达$\sigma(n)$。比如，当该树退化为（接近于）一条单链时，发生此类情况的概率将很高此时的单次查找可能需要线性时间并不奇怪，因为实际上这样的一棵“二分”搜索树，已经退成了一个不折不扣的一维有序列表，而此时的查找则等效于顺序查找。

### 插入算法及其实现

#### 算法

为了在二叉搜索树中插入一个节点，首先需要利用查找算法search()确定插入的位置及向，然后才能将新节点作为叶子插入。

![image-20210806184143280](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806184143280.png)

#### insert()接口的实现

![image-20210806184505753](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806184505753.png)

#### 效率

由上可见，节点插入操作所需的时间，主要消耗于对算法search()及updateHeightAbove()的调用。后者与前者一样，在每一层次至多涉及一个节点，仅消耗*O*(1)时间，故其时间复杂度也同样取决于新节点的深度，在最坏情况下不超过全树的高度

### 删除算法及其实现

为从二叉搜索树中删除节点，首先也需要调用算法BST::search()，判断目标节点是否的确存在于树中。若存在，则需返回其位置，然后方能相应地具体实施删除操作。

![image-20210806185347418](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806185347418.png)

#### remove()

![image-20210806191059344](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806191059344.png)

#### removeAt()

![image-20210806191122848](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806191122848.png)

#### 效率

删除操作所需的时间，主要消耗于对search()、succ()和updateHeightAbove()的调用。 在树中的任一高度，它们至多消耗*O*(1)时间。故总体的渐进时间复杂度，亦不超过全树的高度。

## 平衡二叉搜索树

### 树高与性能

对二叉搜索树的实现与分析，search()、insert()和remove()等主要接口的运行时间，均线性正比于二叉搜索树的高度。而在最坏情况下，二叉搜索树可能彻底地退化为列表，此时的查找效率甚至会降至*O*(n)，线性正比于数据集的规模。因此，若不能有效地控制树高，则就实际的性能而言，较之此前的向量和列表，二叉搜索树将无法体现出明显优势。

#### 随机生成

![image-20210806194734843](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806194734843.png)

显然，任意的n个互异关键码，都可以构成n!种全排列。若各排列作为输入序列的概率均等，则只要将它们各自所生成二叉搜索树的平均查找长度进行平均，即可在一定程度上反映二叉搜索树的平均查找性能。可以证明，在这一随机意义下，二叉搜索树的平均高度为$\Theta(\log n)$​​​。 

#### 随机组成

另一随机策略是，假定n个互异节点同时给定，然后在遵守顺序性的前提下，随机确定它们之间的拓扑联接。如此，称二叉搜索树由这组节点“随机组成”（randomly composed）。

实际上，由n个互异节点组成的二叉搜索树，总共可能有(2n)!/n!/(n + 1)!棵

#### 比较

同一组关键码的不同排列所生成的二叉搜索树，未必不同。实际上一般而言，越是平衡的树，被统计的次数亦越多。从这个角度讲，前一种平均的方式，在无形中高估了二叉搜索树的平均性能。因此相对而言，按照后一口径所得的估计值更加可信。

#### 树高与平均树高

实际上，即便按照以上口径统计出平均树高，仍不足以反映树高的随机分布情况。实际上，树高较大情况的概率依然可能很大。另外，理想的随机并不常见，实际应用中的情况恰恰相反，一组关键码往往会按照（接近）单调次序出现，因此频繁出现极高的搜索树也不足为怪。

### 理想平衡与适度平衡

#### 理想平衡

既然二叉搜索树的性能主要取决于高度，故在节点数目固定的前提下，应尽可能地降低高度。相应地，应尽可能地使兄弟子树的高度彼此接近，即全树尽可能地平衡。当然，包含n个节点的二叉树，高度不可能小于$\lfloor \log 2n\rfloor$​。若树高恰好为$\lfloor \log 2n\rfloor$，则称作理想平衡树。

#### 适度平衡

在渐进意义下适当放松标准之后的平衡性，称作适度平衡。

幸运的是，适度平衡的标准的确存在。比如，若将树高限制为“渐进地不超过*O*(**log**n)”，则下节将要介绍的AVL树，以及下一章将要介绍的伸展树、红黑树、kd-树等，都属于适度平衡。这些变种，因此也都可归入平衡二叉搜索树（balanced binary search tree, BBST）之列。

### 等价变换

#### 等价二叉搜索树

![image-20210806202918492](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806202918492.png)

#### 局部性

平衡二叉搜索树的适度平衡性，都是通过对树中每一局部增加某种限制条件来保证的。比如，在红黑树中，从树根到叶节点的通路，总是包含一样多的黑节点；在AVL树中，兄弟节点的高度相差不过1。事实上，这些限制条件设定得非常精妙，除了适度平衡性，还具有如下局部性：

<center><b>1)经过单次动态修改操作后,至多只有0(1)处局部不再满足限制条件

<center><b>2)总可在O(Logn)时间内,使这O(1)处局部(以至全树)重新满足限制条件

这就意味着：刚刚失去平衡的二叉搜索树，必然可以迅速转换为一棵等价的平衡二叉搜索树。等价二叉搜索树之间的上述转换过程，也称作等价变换。

这里的局部性至关重要。比如，尽管任何二叉搜索树都可等价变换至理想平衡的完全二叉树，然而鉴于二者的拓扑结构可能相去甚远，在最坏情况下我们为此将不得不花费*O*(n)时间。

### 旋转调整

最基本的修复手段，就是通过围绕特定节点的旋转，实现等价前提下的局部拓扑调整。 

#### zig和zag

![image-20210806205129456](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806205129456.png)

#### 效率与效果

zig和zag旋转均属局部操作，仅涉及常数个节点及其之间的联接关系，故均可在常数时间内完成。正因如此，在后面实现各种二叉搜索树平衡化算法时，它们都是支撑性的基本操作。就与树相关的指标而言，经一次zig或zag旋转之后，节点v的深度加一，节点c的深度减一；这一局部子树（乃至全树）的高度可能发生变化，但上、下幅度均不超过一层。

## AVL树

通过合理设定适度平衡的标准，并借助以上等价变换，AVL树（AVL tree）可以实现近乎理想的平衡。在渐进意义下，AVL树可始终将其高度控制在*O*(**log**n)以内，从而保证每次查找、插入或删除操作，均可在*O*(**log**n)的时间内完成。

### 定义及性质

#### 平衡因子

任一节点v的平衡因子（balance factor）定义为“其左、右子树的高度差”，即
$$
balFac(v) = height(lc(v)) - height(rc(v))
$$

#### 接口定义

![image-20210806210832876](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806210832876.png)

为简化对节点平衡性的判断，算法实现时可借用以下宏定义：

![image-20210806211125459](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210806211125459.png)

#### 平衡性

在完全二叉树中各节点的平衡因子非0即1，故完全二叉树必是AVL树；

#### 失衡与重平衡

AVL树与常规的二叉搜索树一样，也应支持插入、删除等动态修改操作。但经过这类操作之后，节点的高度可能发生变化，以致于不再满足AVL树的条件

### 节点插入

#### 失衡节点集

不难看出，新引入节点x后，UT(x)中的节点都是x的祖先，且高度不低于x的祖父。以下，将其中的最深者记作g(x)。在x与g(x)之间的通路上，设p为g(x)的孩子，v为p的孩子。注意，既然g(x)不低于x的祖父，则p必是x的真祖先。 

#### 重平衡

![image-20210807154721365](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210807154721365.png)

#### 单旋

![image-20210807155040742](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210807155040742.png)

#### 双旋

![image-20210807155142359](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210807155142359.png)

#### 高度复原

无论单旋或双旋，经局部调整之后，不仅g(x)能够重获平衡，而且局部子树的高度也必将复原。这就意味着，g(x)以上所有祖先的平衡因子亦将统一地复原换而言之，在AVL树中插入新节点后，仅需不超过两次旋转，即可使整树恢复平衡

#### 实现

![image-20210807160051174](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210807160051174.png)

#### 效率

该算法首先按照二叉搜索树的常规算法，在*O*(**log**n)时间内插入新节点x。既然原树是平衡的，故至多检查*O*(**log**n)个节点即可确定g(x)；如有必要，至多旋转两次，即可使局部乃至全树恢复平衡。由此可见，AVL树的节点插入操作可以在*O*(**log**n)时间内完成。

### 节点删除

#### 失衡节点集

与插入操作十分不同，在摘除节点x后，以及随后的调整过程中，失衡节点集UT(x)始终至多只含一个节点。而且若该节点g(x)存在，其高度必与失衡前相同。

另外还有一点重要的差异是，g(x)有可能就是x的父亲。

### 重平衡

与插入操作同理，从_hot节点出发沿parent指针上行，经过*O*(**log**n)时间即 可确定g(x)位置。作为失衡节点的g(x)，在不包含x的一侧，必有一个非空孩子p，且p的高度至少为1。于是，可按以下规则从p的两个孩子（其一可能为空）中选出节点v：若两个孩子不等高，则v取作其中的更高者；否则，优先取v与p同向者（亦即，v与p同为左孩子，或者同为右孩子）。

#### 单旋

![image-20210807162117551](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210807162117551.png)

#### 双旋

![image-20210807162426335](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210807162426335.png)

#### 失衡传播

与插入操作不同，在删除节点之后，尽管也可通过单旋或双旋调整使局部子树恢复平衡，但就全局而言，依然可能再次失衡。

设g(x)复衡之后，局部子树的高度的确降低。此时，若g(x)原本属于某一更高祖先的更短分支，则因为该分支现在又进一步缩短，从而会致使该祖先失衡。在摘除节点之后的调整过程中，这种由于低层失衡节点的重平衡而致使其更高层祖先失衡的现象，称作“失衡传播”。

请注意，失衡传播的方向必然自底而上，而不致于影响到后代节点。在此过程中的任一时刻，至多只有一个失衡的节点；高层的某一节点由平衡转为失衡，只可能发生在下层失衡节点恢复平衡之后。因此，可沿parent指针逐层遍历所有祖先，每找到一个失衡的祖先节点，即可套用以上方法使之恢复平衡

#### 实现

![image-20210807163956411](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1C++.assets/image-20210807163956411.png)

#### 效率

由上可见，较之插入操作，删除操作可能需在重平衡方面多花费一些时间。不过，既然需做重平衡的节点都是x的祖先，故重平衡过程累计只需不过*O*(**log**n)时间。综合各方面的消耗，AVL树的节点删除操作总体的时间复杂度依然是*O*(**log**n)。

# 排序

## 冒泡算法	bubbleSort

```cpp
template<typename T>
vector<T>bubbleSort(vector<T>vec) {
	vector<T>res(vec);
	for (int i = 0; i < res.size(); i++) {
		for (int j = 0; j < res.size() - i - 1; j++) {
			if (res[j] < res[j + 1]) {
				swap(res[j], res[j + 1]);
			}
		}
	}
	return res;
}
```

### 提前冒泡算法

```cpp
void bubblesort1A(int A[], int n) {
    bool sorted = false;
    while (!sorted) {
        sorted = true;
        for (int i = 1; i < n; ++i) {
            if (A[i - 1] > A[i]) {
                swap(A[i - 1], A[i]);
                sorted = false;
            }
        }
        n--;
    }
}
```



## 选择排序	selectionSort

```cpp
vector<T>selectionSort(vector<T>vec) {
	vector<T>res(vec);
	for (int i = 0; i < res.size(); i++) {
		size_t maxindex = i;
		for (int j = i + 1; j < res.size(); j++) {
			if (res[maxindex] < res[j]) {
				maxindex = j;
			}
		}
		swap(res[maxindex], res[i]);
	}
	return res;
}
```

## 插入排序	insertionSort

```cpp
template<typename T>
vector<T> insertionSort(vector<T> vec) {
	vector<T>res(vec);
	for (int i = 1; i < res.size(); i++) {
		T temp = res[i];
		int j;
		for (j = i - 1; j >= 0 and res[j] < temp; j--) {
			res[j + 1] = res[j];
		}
		res[j + 1] = temp;
	}
	return res;
}
```

## 快速排序	quickSort

```cpp
/// 快速排序
/// \param vec 待排序数组
/// \param left 左坐标
/// \param right 右坐标
void quickSort(vector<int> &vec, int left, int right) {
    int middle = vec[(left + right) / 2];
    int tleft = left, tright = right;
    while (tleft <= tright) {
        while (vec[tleft] < middle) {
            tleft++;
        }
        while (middle < vec[tright]) {
            tright--;
        }
        if (tleft <= tright) {
            swap(vec[tleft], vec[tright]);
            tleft++;
            tright--;
        }
    }
    if (tleft == tright) {
        tleft++;
    }
    if (left < tright) {
        quickSort(vec, left, tleft - 1);
    }
    if (tleft < right) {
        quickSort(vec, tright + 1, right);
    }
    return;
}
```

## 归并排序 mergeSort

### 有序向量的二路归并

与起泡排序通过反复调用单趟扫描交换类似,归并排序也可以理解为是通过反复调用所谓二路归并(2-way merge)算法而实现的.所谓二路归并,就是将两个有序序列合并成为一个有序序列.归并排序所需的时间,也主要决定于各趟二路归并所需时间的总和

二路归并属于迭代式算法.每步迭代中,只需比较两个待归并向量的首元素,将小者取出并追加到输出向量的末尾,该元素在原向量中的后继则成为新的首元素.如此往复,直到某一向量为空.最后,将另一非空的向量整体接至输出向量的末尾
```cpp
/// 二路已序数组归并算法
/// \param vec1,vec2:已序数组
/// \return 已序数组
vector<int> mergeTwoVector(vector<int> &vec1, vector<int> &vec2) {
    vector<int> res;
    int len1 = vec1.size(), len2 = vec2.size();/*长度*/
    int i = 0, j = 0;/*当前坐标*/
    while (i < len1 && j < len2) {
        if (vec1[i] < vec2[j]) {
            res.push_back(vec1[i++]);
        } else {
            res.push_back(vec2[j++]);
        }
    }
    while(i<len1){
        res.push_back(vec1[i++]);
    }
    while(j<len2){
        res.push_back(vec2[j++]);
    }
    return res;
}
```

### 分治策略
### 归并排序的实现
```cpp
/// 数组排序
void Merge(vector<int> &vec, int left, int middle, int right) {
    vector<int> temp;
    int i = left, j = middle + 1;
    while (i <= middle and j <= right) {
        if (vec[i] < vec[j]) {
            temp.push_back(vec[i]);
            i++;
        } else {
            temp.push_back(vec[j]);
            j++;
        }
    }
    while (j <= right) {
        temp.push_back(vec[j++]);
    }
    while (i <= middle) {
        temp.push_back(vec[i++]);
    }
    for (int i = 0; i < temp.size(); i++) {
        vec[left + i] = temp[i];
    }
}

/// 归并排序接口
void MergeSort(vector<int> &vec, int left, int right) {
    if (left == right) {
        return;
    }
    int middle = (left + right);
    MergeSort(vec, left, middle);//分割数组
    MergeSort(vec, middle + 1, right);
    Merge(vec, left, middle, right);//二路数组归并
}
```

## 堆排序

堆排序是利用**堆**这种数据结构而设计的一种排序算法，堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。

### 堆

　　**堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：**

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182750011-675658660.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182857323-2092264199.png)

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

**大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  

**小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  

再简单总结下堆排序的基本思路：

　　**a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;**

　　**b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

　　**c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**

# sort函数

```cpp
/// <summary>
/// greater to lower
/// </summary>
/// <typeparam name="T">typename</typeparam>
/// <param name="a"></param>
/// <param name="b"></param>
/// <returns>
/// true: don't swap
/// false: swap
/// </returns>
template<typename T>
bool cmp(T a, T b) {
	if (a > b) {
		return true;
	}
	else {
		return false;
	}
}
```

```cpp
/// <summary>
/// lower to greater
/// </summary>
/// <typeparam name="T">typename</typeparam>
/// <param name="a"></param>
/// <param name="b"></param>
/// <returns>
/// true: don't swap
/// false: swap
/// </returns>
template<typename T>
bool cmp(T a, T b) {
	if (a < b) {
		return true;
	}
	else {
		return false;
	}
}
```



# 查找

## 二分法

```cpp
/// <summary>
/// binary search
/// </summary>
/// <typeparam name="T">typename</typeparam>
/// <param name="vec">vector</param>
/// <param name="target">search value</param>
/// <returns>find or not</returns>
template<typename T>
bool binarySearch(vector<T>vec, int target) {
	int left = 0, right = vec.size() - 1;
	while (left <= right) {
		int middleindex = (left + right) / 2;
		T middleValue = vec[middleindex];
		if (middleValue < target) {
			left = middleindex + 1;
		}
		else if (middleValue > target) {
			right = middleindex - 1;
		}
		else {
			return true;
		}
	}
	return false;
}
```

## 查找是否有相同的值

```cpp
/// <summary>
/// find if vector has equal value item
/// </summary>
/// <typeparam name="T">typename</typeparam>
/// <param name="vec"></param>
/// <returns></returns>
bool findEqual(vector<T> vec) {
	map<T, bool>hash;
	for (int i = 0; i < vec.size(); i++) {
		if (hash.find(vec[i]) == hash.end()) {
			hash[vec[i]] = true;
		}
		else {
			return true;
		}
	}
	return false;
}

```

# 拆分字符串

## 生成单词

```cpp
/// <summary>
/// detached string
/// </summary>
/// <param name="str">object string</param>
/// <returns>vector of the string</returns>
vector<string> detachedString(string& str) {
	istringstream ss(str);
	vector<string>res;
	string temp;
	while (ss >> temp) {
		res.push_back(temp);
	}
	return res;
}
// another edition
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

int main () {
	std::vector<std::string> coll;

	// read all words from the standard input
	std::copy ( std::istream_iterator<std::string> ( std::cin ) , std::istream_iterator<std::string> () , std::back_inserter ( coll ) );

	// sort elements
	sort ( coll.begin () , coll.end () );

	// print all elements without duplicates
	std::unique_copy ( coll.begin () , coll.end () , std::ostream_iterator<std::string> ( std::cout , "\n" ) );

	//exit
	std::exit ( EXIT_SUCCESS );
}
```

# 计数

## map

```cpp
/// <summary>
/// count for the value
/// </summary>
/// <typeparam name="T">typename</typeparam>
/// <param name="vec">vector</param>
/// <returns>return map</returns>
template<typename T>
map<T, int> count(vector<T>& vec) {
	map<T, int>res;
	for (int i = 0; i < vec.size(); i++) {
		if (res.find(vec[i]) == res.end()) {
			res[vec[i]] = 1;
		}
		else {
			res[vec[i]]++;
		}
	}
	return res;
}
```

## vector+pair

```cpp
/// <summary>
/// count number of the vector item value
/// </summary>
/// <typeparam name="T">typename</typeparam>
/// <param name="vec">vector</param>
/// <returns>return pair of the vector</returns>
template<typename T>
vector<pair<T, int>> count(vector<T>& vec) {
	vector<pair<T, int>>res;
	if (vec.size() == 0) {
		return res;
	}
	else {
		pair<T, int>temp;
		temp.first = vec[0];
		temp.second = 1;
		res.push_back(temp);
		for (int i = 1; i < vec.size(); i++) {
			bool find = false;
			for (int j = 0; j < res.size(); j++) {
				if (res[j].first == vec[i]) {
					res[j].second++;
					find = true;
					break;
				}
			}
			if (!find) {
				temp.first = vec[i];
				temp.second = 1;
				res.push_back(temp);
			}
		}
		return res;
	}
}
```

## vector(26,0)——只出现英文单词

```cpp
string str = "frtrhehgvaewhrqhfbvzvjkaheglaefsdarg";
vector<int>count(26, 0);
for (char x : str) {
	count[x - 'a']++;
}
for (int i = 0; i < count.size(); i++) {
	if (count[i] != 0) {
		cout << setw(4) << left << char(i + 'a') << count[i] << endl;
	}
}
```

# 原码、反码、补码

## 原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

<center>[+1]原 = 0000 0001

<center>[-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

<center>[1111 1111 , 0111 1111]==>[-127 , 127]

### 十进制数转原码

```cpp
/// 十进制数转原码
/// \param number 十进制数
/// \return 原码
string getOriginalCode(int number) {
    if (number > 127 || number < -127) {/*若溢出*/
        return "";/*返回空串*/
    }
    string str(8, '0');
    if (number < 0) {
        str[0] = '1';
        number = -number;
    }
    for (int i = 0; number != 0; i++) {
        str[7 - i] = number % 2 + '0';
        number /= 2;
    }
    return str;
}
```



## 反码

反码的表示方法是:

- 正数的反码是其本身
- 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

<center>[+1] = [00000001]原 = [00000001]反

<center>[-1] = [10000001]原 = [11111110]反

### 原码转反码

```cpp
/// 获得反码
/// \param str 原码
/// \return 反码
string getRadixMinusOneComplement(string str) {
    if (str[0] == '0') {
        return str;
    } else {
        for (int i = 1; i < str.size(); i++) {
            str[i] = (str[i] == '1') ? '0' : '1';
        }
    }
    return str;
}
```



## 补码

补码的表示方法是:

- 正数的补码就是其本身
- 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

<center>[+1] = [00000001]原 = [00000001]反 = [00000001]补

<center>[-1] = [10000001]原 = [11111110]反 = [11111111]补

### 反码转补码

```cpp
/// 反码转补码
/// \param str 反码
/// \return 补码
string getComplement(string str) {
    if (str[0] == '0') {
        return str;
    } else {
        for (int i = str.size() - 1; i >= 0; i--) {
            if (str[i] == '1') {
                str[i] = '0';
            } else {
                str[i] = '1';
                return str;
            }
        }
    }
}
```



# 质数

```cpp
/// <summary>
/// get primes
/// </summary>
/// <param name="n">range of the primes</param>
/// <returns>vector of the primes</returns>
vector<int> primes(int n) {
	vector<int>res;
	if (n <= 0) {
		return res;
	}
	bool* notPrime = new bool[n];
	for (int i = 0; i < n; i++) {
		notPrime[i] = false;
	}
	for (int i = 2; i < n; i++) {
		if (notPrime[i] == false) {
			res.push_back(i);
		}
		for (int j = 2; i * j < n; j++) {
			notPrime[i * j] = true;
		}
	}
	return res;
}
```

# 最大公约数GCD

公式：
$$
gcd(a,b)=gcd(b,a\%b)
$$


```cpp
//辗转相除法求最大公约数函数
int divisor(int a, int b) {
	int temp;

	//比较两个数的大小,值大的数为a,值小的数为b
	if (a < b) {
		temp = a;
		a = b;
		b = temp;
	}

	//求余
	while (b != 0) {
		temp = a % b;
		a = b;
		b = temp;
	}
	return a;
}

//求最小公倍数
int multiple(int a, int b) {
	int divisor(int a, int b);
	int temp;
	temp = divisor(a, b);
	return(a * b / temp);
}

//函数递归调用求最大公约数
int gcd(int a, int b) {
	if (a % b == 0) {
		return b;
	}
	else {
		return gcd(b, a % b);
	}
}

//穷举法求最大公约数
int divisor1(int a, int b) {
	int temp;
	temp = (a > b) ? b : a;   //求较小值
	while (temp > 0) {
		if (a % temp == 0 && b % temp == 0) {
			break;
		}
		else {
			temp--;
		}
	}
	return (temp);
}

//穷举法求最小公倍数
int multiple1(int a, int b) {
	int p, q, temp;
	p = (a > b) ? a : b;  //求两数中的最大值
	q = (a > b) ? b : a;  //求两数中的最小值
	temp = p;
	while (1) {
		if (p % q == 0) {
			break;
		}
		else {
			p += temp;
		}
	}
	return (p);
}

//更相减损法求最大公约数
int gcd1(int a, int b) {
	int i = 0, temp, x = 0;
	while (a % 2 == 0 && b % 2 == 0) {    //m,n有公约数2时
		a /= 2;
		b /= 2;
		i += 1;
	}
	//a,b的值互换
	if (a < b) {
		temp = a;
		a = b;
		b = temp;
	}
	while (x) {
		x = a - b;
		a = (b > x) ? b : x;   
		b = (b < x) ? b : x;
		if (b == (a - b)) {    //差和减数相等
			break;
		}
	}
	if (i == 0) {
		return b;
	}
	else {
		return (int)pow(2, i)*b;
	}
}
```

# 最小公倍数LCM

```cpp
int lcm(int m, int n)
{
	int max;
	if (m < n)
	{
		max = n;
	}
	else
	{
		max = m;
	}
	
	while (true)
	{
		if (max % m == 0 && max % n == 0 )
		{
			return max;
		}
		
		max++;
	}
}
```

# 进制转换

## 二进制转十进制

```cpp
/// 二进制转十进制
/// \param number 二进制数
/// \return 十进制数
int binaryToDecimal(int number){
    int res=0;
    string str= to_string(number);
    for(int i=0;i<str.size();i++){
        res=res*2+str[i]-'0';
    }
    return res;
}
```

## 十进制转二进制

```cpp
/// 十进制转二进制
/// \param number 十进制数
/// \return 二进制数
int decimalToBinary(int number) {
    int res = 0;
    string str = to_string(number);
    for (int i = 0; i < str.size(); i++) {
        res += (str[i] - '0') * pow(2, str.size() - i - 1);
    }
    return res;
}
```

## 十进制转十六进制

```cpp
/// 十进制转十六进制
/// \param number 十进制数
/// \return 十六进制数
string decimalToHexadecimal(int number) {
    string temp[] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e"};
    string str;
    while (number != 0) {
        str.insert(0, temp[number % 16]);
        number /= 16;
    }
    return str;
}
```

## 十六进制转十进制

```cpp
/// 十六进制转十进制
/// \param number 十六进制
/// \return 十进制
int decimalToHexadecimal(string number) {
    long long res = 0;
    for(int i=0;i<number.size();i++){
        if(number[i]<'a'){
            res=res*16+number[i]-'0';
        }else{
            res=res*16+number[i]-'a';
        }
    }
    return res;
}
```

## 八进制转十进制

```cpp
/// 八进制转十进制
/// \param number 八进制数
/// \return 十进制数
int octalToDecimal(int number) {
    int res = 0;
    string str = to_string(number);
    for (int i = 0; i < str.size(); i++) {
        res = res * 8 + str[i] - '0';
    }
    return res;
}
```

## 十进制转八进制

```cpp
/// 十进制转八进制
/// \param number 十进制数
/// \return 八进制数
int decimalToOctal(int number) {
    string res;
    while (number != 0) {
        string temp= to_string(number%8);
        res.insert(0,temp);
        number /= 8;
    }
    return atoi(res.c_str());
}
```

## 二进制转八进制

```cpp
/// 二进制转八进制
/// \param number 二进制
/// \return 八进制数
int binaryToOctal(int number) {
    int res = 0;
    string str = to_string(number);
    while (str.size() % 3 != 0) {
        str.insert(0, "0");
    }
    for (int i = 0; i < str.size(); i = i + 3) {
        int temp = 0;
        temp = (str[i] - '0') * 4 + (str[i + 1] - '0') * 2 + (str[i + 2] - '0');
        res = res * 10 + temp;
    }
    return res;
}
```

## 八进制转二进制

```cpp
/// 八进制转二进制
/// \param number 八进制
/// \return 二进制
string octalToBinary(int number) {
    string res;
    string temp = to_string(number);
    for (int i = temp.size() - 1; i >= 0; i--) {
        int value = temp[i] - '0';
        while (value != 0) {
            res.insert(0, to_string(value % 2));
            value /= 2;
        }
    }
    return res;
}
```

## 二进制转十六进制

```cpp
/// 二进制转十六进制
/// \param number 二进制
/// \return 十六进制
string binaryToHexadecimal(long long number) {
    string res;
    string str = to_string(number);
    while (str.size() % 4 != 0) {
        str.insert(0, "0");
    }
    for (int i = 0; i < str.size(); i += 4) {
        int temp = (str[i] - '0') * 8 + (str[i + 1] - '0') * 4 + (str[i + 2] - '0') * 2 + str[i + 3] - '0';
        if (temp < 10) {
            res.push_back(temp + '0');
        } else {
            res.push_back(temp + 'a' - 10);
        }
    }
    return res;
}
```

## 十六进制转二进制

```cpp
/// 十六进制转二进制
/// \param number 十六进制
/// \return 二进制
string hexadecimalToBinary(string number) {
    string res;
    for (int i = number.size() - 1; i >= 0; i--) {
        int temp = number[i] - '0';
        if (temp > 10) {
            temp = number[i] - 'a' + 10;
        }
        while (temp != 0) {
            res.insert(0, to_string(temp % 2));
            temp /= 2;
        }
        if(i!=0){
            while(res.size()%4!=0){
                res.insert(0,"0");
            }
        }
    }
    return res;
}
```



# 补数

```cpp
int findComplement(int num) {
    vector<int>res;
    while(num!=0){
        res.push_back(num%2);
        num/=2;
    }
    for(int &x:res){
        if(x==1){
            x=0;
        }
        else{
            x=1;
        }
    }
    int count=0;
    for(int i=0;i<res.size();i++){
        count+=pow(2,i)*res[i];
    }
    return count;
}
```

# 八皇后

![image-20210720181359786](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210720181359786.png)

![image-20210720181409874](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210720181409874.png)

![image-20210720181418302](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210720181418302.png)

## 实例

![image-20210720181438966](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210720181438966.png)

# 寻径

![image-20210720183144716](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210720183144716.png)

![image-20210720183210579](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210720183210579.png)

![image-20210720183228983](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210720183228983.png)

![image-20210720183238490](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210720183238490.png)

![image-20210720183311822](E:\programe\GitHub project warehouse manager\Markdown-TakeNotes\数据结构与算法设计C++.assets\image-20210720183311822.png)

# 判断是非为n的幂



```cpp
bool isPowerOfN(int num,int n) {
	if (num <= 0) {
		return false;
	}
	while (num != 0) {
		if (num % n != 0 and num != 1) {
			return false;
		}
		else {
			num /= n;
		}
	}
	return true;
}
```

# 获得不同的vector序列	unique

```cpp
/// <summary>
/// greater to lower
/// </summary>
/// <typeparam name="T">typename</typeparam>
/// <param name="a"></param>
/// <param name="b"></param>
/// <returns>
/// true: don't swap
/// false: swap
/// </returns>
template<typename T>
bool cmp(T a, T b) {
	if (a > b) {
		return true;
	}
	else {
		return false;
	}
}
/// <summary>
/// get difference vector
/// </summary>
/// <typeparam name="T">typename</typeparam>
/// <param name="vec">vector</param>
/// <returns>difference vector</returns>
template<typename T>
vector<T> getDifference(vector<T> vec) {
	vector<T>res = vec;
	sort(res.begin(), res.end(), cmp<T>);
	auto iter = unique(res.begin(), res.end());
	res.erase(iter, res.end());
	return res;
}
```

# DP动态规划

```cpp
int longestIncreasingSubsequence(vector<int>& nums) {
    if (nums.size() == 0) {
        return 0;
    }
    int res = 1;
    vector<int> LIS(nums.size(), 1);
    for (int i = 1; i < nums.size(); ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                LIS[i] = max(LIS[i], LIS[j] + 1);
            }
        }
        res = max(res, LIS[i]);
    }
    return res;
}
int jump(vector<int> &A) {
    int n=A.size();
    vector<int>dp(n);
    dp[0]=0;
    for(int i=1;i<n;i++){
        dp[i]=INT_MAX;
        for(int j=0;j<i;j++){
            if(A[j]+j>=i){
                dp[i]=min(dp[i],dp[j]+1);
            }
        }
    }
    return dp[n-1];
}
```

>    ### *重要三要素：*
>
>    ####      (1) 每个问题的阶段.
>
>    ####     (2) 每个阶段的状态.
>
>    ####     (3) 上一阶段状态转换到下一阶段状态之间的递推关系.
>
>    ####     递推关系必须是从次小的问题开始到较大的问题之间的转化, 从这个角度来说 , DP算法往往可以用递归程序来实现 ,  不过因为递推可以充分利用前面保存的子问题的解来减少重复计算 ,  所以对于大规模问题来说 ,  有递归不可比拟的优势 ,  这也是DP算法的核心之处.确定了动态规划的这三要素之后呢 ,  整个求解过程就可以用一个最优决策表来描述 ,  最优决策表是一个二维表 ,  其中行表示决策的阶段 ,  列表示问题状态,表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值(如最短路径问题,  最长公共子序列问题 ,  最大价值问题等) ,  填表的过程就是根据递推关系 ,  从 1 行 1 列开始 ,  以行或者列优先的顺序 ,  依次填写表格,最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解：f(i, j) = max {f(i - 1, j), f(i - 1, j - dp[n]) + base(i, j)}.

---

# DFS

深度优先遍历图算法步骤：

1.   访问顶点v;
2.   依次从v的未被访问的邻接点出发,对图进行深度优先遍历;直至图中和v有路径相通的顶点都被访问;
3.   若此时图中尚有顶点未被访问,则从一个未被访问的顶点出发,重新进行深度优先遍历,直到图中所有顶点均被访问过为止.

# LeetCode

# 1. A + B 问题

给出两个整数 a*a* 和 b*b* , 求他们的和.

### 样例

**样例 1:**

```
输入:  a = 1, b = 2
输出: 3	
样例解释: 返回a+b的结果.
```

**样例 2:**

```
输入:  a = -1, b = 1
输出: 0	
样例解释: 返回a+b的结果.
```

### 挑战

显然你可以直接 return a + b,但是你是否可以挑战一下不这样做？(不使用++等算数运算符)

### 说明

a和b都是 `32位` 整数么？

-    是的

我可以使用位运算符么？

-    当然可以

### 注意事项

你不需要从输入流读入数据,只需要根据`aplusb`的两个参数a和b,计算他们的和并返回就行.

```cpp
class Solution {
public:
    /**
     * @param a: An integer
     * @param b: An integer
     * @return: The sum of a and b 
     */
    int aplusb(int a, int b) {
        return a+b;
    }
};
```

# 2. 尾部的零

设计一个算法,计算出n阶乘中尾部零的个数

### 样例

```
样例  1:
	输入: 11
	输出: 2
	
	样例解释: 
	11! = 39916800, 结尾的0有2个.

样例 2:
	输入:  5
	输出: 1
	
	样例解释: 
	5! = 120, 结尾的0有1个.
```

### 挑战

O(logN)的时间复杂度

```cpp
class Solution {
public:
    /*
     * @param n: A long integer
     * @return: An integer, denote the number of trailing zeros in n!
     */
    long long trailingZeros(long long n) {
        long long sum = 0;
		while (n != 0) {
			sum += n / 5;
			n /= 5;
		}
		return sum;
    }
};
```

# 3. 统计数字

计算数字 k 在 0 到 n 中的出现的次数,k 可能是 0~9 的一个值.

### 样例

**样例 1：**

```
输入：
k = 1, n = 1
输出：
1
解释：
在 [0, 1] 中,我们发现 1 出现了 1 次 (1).
```

**样例 2：**

```
输入：
k = 1, n = 12
输出：
5
解释：
在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 中,我们发现 1 出现了 5 次 (1, 10, 11, 12)(注意11中有两个1).
```

```cpp
class Solution {
public:
    /**
     * @param k: An integer
     * @param n: An integer
     * @return: An integer denote the count of digit k in 1..n
     */
    int digitCounts(int k, int n) {
        int count = 0;
		if (k == 0) {
			count = 1;
		}
		for (int i = 1; i <= n; i++) {
			int number = i;
			while (number > 0) {
				if (number % 10 == k) {
					count++;
				}
				number /= 10;
			}
		}
		return count;
    }
};
```

# 4. 丑数 II

设计一个算法,找出只含素因子`2`,`3`,`5` 的第 *n* 小的数.

符合条件的数如：`1, 2, 3, 4, 5, 6, 8, 9, 10, 12...`

### 样例

**样例 1：**

```
输入：9
输出：10
```

**样例 2：**

```
输入：1
输出：1
```

### 挑战

要求时间复杂度为 O(*n*log*n*) 或者 O(*n*).

### 注意事项

我们可以认为 `1` 也是一个丑数.

```cpp
class Solution {
public:
    /**
     * @param n: An integer
     * @return: return a  integer as description.
     */
    int nthUglyNumber(int n) {
		int* uglys = new int[n];
		uglys[0] = 1;
		int next = 1;
		int* p2 = uglys;
		int* p3 = uglys;
		int* p5 = uglys;
		while (next < n) {
			int m = min(min(*p2 * 2, *p3 * 3), *p5 * 5);
			uglys[next] = m;
			while (*p2 * 2 <= uglys[next]) {
				*p2++;
			}
			while (*p3 * 3 <= uglys[next]) {
				*p3++;
			}
			while (*p5 * 5 <= uglys[next]) {
				*p5++;
			}
			next++;
		}
		int uglyNum = uglys[n - 1];
		delete[]uglys;
		return uglyNum;
    }
};
```

# 5. 第k大元素

在数组中找到第 k 大的元素.

### 样例

**样例 1：**

```
输入：
n = 1, nums = [1,3,4,2]
输出：
4
```

**样例 2：**

```
输入：
n = 3, nums = [9,3,2,4,8]
输出：
4
```

### 挑战

要求时间复杂度为O(n),空间复杂度为O(1).

### 注意事项

你可以交换数组中的元素的位置

```cpp
class Solution {
public:
    /**
     * @param n: An integer
     * @param nums: An array
     * @return: the Kth largest element
     */
	int kthLargestElement(int k, vector<int>& nums) {
		int n = nums.size();
		k = n - k;
		return partition(nums, 0, n - 1, k);
	}
	int partition(vector<int>& nums, int start, int end, int k) {
		int left = start, right = end;
		int pivot = nums[left];
		while (left <= right) {
			while (left <= right and nums[left] < pivot) {
				left++;
			}
			while (left <= right and nums[right] > pivot) {
				right--;
			}
			if (left <= right) {
				swap(nums[left], nums[right]);
				left++;
				right--;
			}
		}
		if (k <= right) {
			return partition(nums, start, right, k);
		}
		if (k >= left) {
			return partition(nums, left, end, k);
		}
		return nums[k];
	}
};
```

# 6. 合并排序数组

合并两个有序升序的整数数组A和B变成一个新的数组.新数组也要有序.

### 样例

**样例 1:**

```
输入: A=[1], B=[1]
输出:[1,1]	
样例解释: 返回合并后的数组.
```

**样例 2:**

```
输入: A=[1,2,3,4], B=[2,4,5,6]
输出: [1,2,2,3,4,4,5,6]	
样例解释: 返回合并后的数组.
```

### 挑战

你能否优化你的算法,如果其中一个数组很大而另一个数组很小？

```cpp
class Solution {
public:
    /**
     * @param A: sorted integer array A
     * @param B: sorted integer array B
     * @return: A new sorted integer array
     */
    vector<int> mergeSortedArray(vector<int> &A, vector<int> &B) {
		if (A.size() > B.size()) {
			return insertSort(A, B);
		}
		else {
			return insertSort(B, A);
		}
	}

	vector<int> insertSort(vector<int>& C, vector<int>& D) {
		int length = C.size() + D.size(), size = C.size();
		int j = 0;
		C.insert(C.end(), D.begin(), D.end());
		for (int i = size; i < length; i++) {
			int temp = C[i];
			for (j = i - 1; j >= 0 && temp < C[j]; j--) {
				C[j + 1] = C[j];
			}
			C[j + 1] = temp;
		}
		for (int x : C) {
			cout << x << " ";
		}
		return C;
	}
};
```

# 8. 旋转字符串

给定一个字符串(以字符数组的形式给出)和一个偏移量,根据偏移量`原地`旋转字符串(从左向右旋转).

### 样例

**样例 1:**

```
输入:  str="abcdefg", offset = 3
输出:  str = "efgabcd"	
样例解释:  注意是原地旋转,即str旋转后为"efgabcd"
```

**样例 2:**

```
输入: str="abcdefg", offset = 0
输出: str = "abcdefg"	
样例解释: 注意是原地旋转,即str旋转后为"abcdefg"
```

**样例 3:**

```
输入: str="abcdefg", offset = 1
输出: str = "gabcdef"	
样例解释: 注意是原地旋转,即str旋转后为"gabcdef"
```

**样例 4:**

```
输入: str="abcdefg", offset =2
输出: str = "fgabcde"	
样例解释: 注意是原地旋转,即str旋转后为"fgabcde"
```

**样例 5:**

```
输入: str="abcdefg", offset = 10
输出: str = "efgabcd"	
样例解释: 注意是原地旋转,即str旋转后为"efgabcd"
```

### 挑战

在数组上原地旋转,使用O(1)的额外空间

### 说明

`原地旋转`意味着你要在s本身进行修改.你不需要返回任何东西.

### 注意事项

offset >= 0
str的长度 >= 0

```cpp
class Solution {
public:
    /**
     * @param str: An array of char
     * @param offset: An integer
     * @return: nothing
     */
    void rotateString(string &str, int offset) {
		if (str.size() == 0) {
			return;
		}
		offset %= str.size();
		string tempA = str.substr(0, str.size() - offset);
		string tempB = str.substr(str.size() - offset, str.size());
		str = tempB + tempA;
	}
};
```

# 9. Fizz Buzz 问题

给你一个整数*n*. 从 *1* 到 *n* 按照下面的规则打印每个数：

-    如果这个数被3整除,打印`fizz`.
-    如果这个数被5整除,打印`buzz`.
-    如果这个数能同时被`3`和`5`整除,打印`fizz buzz`.
-    如果这个数既不能被 `3` 整除也不能被 `5` 整除,打印数字`本身.`

### 样例

比如 *n* = `15`, 返回一个字符串数组：

```
[
  "1", "2", "fizz",
  "4", "buzz", "fizz",
  "7", "8", "fizz",
  "buzz", "11", "fizz",
  "13", "14", "fizz buzz"
]
```

### 挑战

你是否可以只用一个 `if` 来实现

```cpp
class Solution {
public:
    /**
     * @param n: An integer
     * @return: A list of strings.
     */
    vector<string> fizzBuzz(int n) {
		vector<string> result(n);
		for (int i = 1; i <= n; i++) {
			if (i % 15 == 0) {
				result[i - 1] = "fizz buzz";
			}
			else if (i % 3 == 0) {
				result[i - 1] = "fizz";
			}
			else if (i % 5 == 0) {
				result[i - 1] = "buzz";
			}
			else {
				result[i - 1] = to_string(i);
			}
		}
		return result;
	}
};
```

# 12. 带最小值操作的栈

实现一个栈, 支持以下操作:

-    `push(val)` 将 val 压入栈
-    `pop()` 将栈顶元素弹出, 并返回这个弹出的元素
-    `min()` 返回栈中元素的最小值

要求 O(1) 开销.

### 样例

**样例 2:**

```
输入: 
  push(1)
  min()
  push(2)
  min()
  push(3)
  min()
输出: 
  1
  1
  1
```

### 注意事项

保证栈中没有数字时不会调用 `min()`

```cpp
class MinStack {
public:
    stack<int> s1;
    stack<int> s2;
    MinStack() {
        // do intialization if necessary
    }

    /*
     * @param number: An integer
     * @return: nothing
     */
    void push(int number) {
        // write your code here
        s1.push(number);
        if(!s2.empty()){
            int temp=s2.top();
            if(number<temp){
                s2.push(number);
            }else{
                s2.push(temp);
            }
        }
        else{
            s2.push(number);
        }
    }

    /*
     * @return: An integer
     */
    int pop() {
        // write your code here
        int temp=s1.top();
        s1.pop();
        s2.pop();
        return temp;
    }

    /*
     * @return: An integer
     */
    int min() {
        // write your code here
        return s2.top();
    }
};
```

# 13. 字符串查找

对于一个给定的 source 字符串和一个 target 字符串,你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始).如果不存在,则返回 `-1`.

### 样例

**样例 1:**

```
输入: source = "source" , target = "target"
输出:-1	
样例解释: 如果source里没有包含target的内容,返回-1
```

**样例 2:**

```
输入: source = "abcdabcdefg" ,target = "bcd"
输出: 1	
样例解释: 如果source里包含target的内容,返回target在source里第一次出现的位置
```

### 挑战

O(n2)的算法是可以接受的.如果你能用O(n)的算法做出来那更加好.(提示：KMP)

### 说明

在面试中我是否需要实现KMP算法？

-    不需要,当这种问题出现在面试中时,面试官很可能只是想要测试一下你的基础应用能力.当然你需要先跟面试官确认清楚要怎么实现这个题.

```cpp
class Solution {
public:
    /**
     * @param source: 
     * @param target: 
     * @return: return the index
     */
    int strStr(string &source, string &target) {
		return source.find(target);
    }
};
```

# 14. 二分查找

给定一个排序的整数数组(升序)和一个要查找的整数`target`,用`O(logn)`的时间查找到target第一次出现的下标(从0开始),如果target不存在于数组中,返回`-1`.

### 样例

```
样例  1:
	输入:[1,4,4,5,7,7,8,9,9,10],1
	输出: 0
	
	样例解释: 
	第一次出现在第0个位置.

样例 2:
	输入: [1, 2, 3, 3, 4, 5, 10],3
	输出: 2
	
	样例解释: 
	第一次出现在第2个位置
	
样例 3:
	输入: [1, 2, 3, 3, 4, 5, 10],6
	输出: -1
	
	样例解释: 
	没有出现过6, 返回-1
```

### 挑战

如果数组中的整数个数超过了2^32,你的算法是否会出错？

```cpp
class Solution {
public:
    /**
     * @param nums: The integer array.
     * @param target: Target to find.
     * @return: The first position of target. Position starts from 0.
     */
    int binarySearch(vector<int> &nums, int target) {
		int tempa = 0, tempb = nums.size();
		while (tempb >= tempa) {
			int medium = (tempa + tempb) / 2;
			if (nums[medium] > target) {
				tempb = medium-1;
			}
			else if (nums[medium] == target) {
				while (nums[medium] == nums[medium - 1]) {
					medium--;
				}
				return medium;
			}
			else {
				tempa = medium+1;
			}
		}
		return -1;
	}
};
```

# 15. 全排列

给定一个数字列表,返回其所有可能的排列.

### 样例

**样例 1：**

```
输入：[1]
输出：
[
  [1]
]
```

**样例 2：**

```
输入：[1,2,3]
输出：
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

### 挑战

使用递归和非递归分别解决.

### 注意事项

你可以假设没有重复数字.

```cpp
class Solution {
public:
	/*
	 * @param nums: A list of integers.
	 * @return: A list of permutations.
	 */
	vector<vector<int>> permute(vector<int>& nums) {
		vector<vector<int>>results;
		if (nums.size() == 0) {
			results.push_back(vector<int>());
			return results;
		}
		vector<bool>used(nums.size(), 0);
		vector<int>current;
		dfs(nums, used, current, results);
		return results;
	}
	void dfs(vector<int>nums, vector<bool>& used, vector<int>& current, vector<vector<int>>& results) {
		if (current.size() == nums.size()) {
			results.push_back(current);
			return;
		}
		for (int i = 0; i < nums.size(); i++) {
			if (used[i]) {
				continue;
			}
			current.push_back(nums[i]);
			used[i] = true;
			dfs(nums, used, current, results);
			used[i] = false;
			current.pop_back();
		}
		return;
	}
};
```

# 16. 带重复元素的排列

给出一个具有重复数字的列表,找出列表所有**不同**的排列.

### 样例

**样例 1：**

```
输入：[1,1]
输出：
[
  [1,1]
]
```

**样例 2：**

```
输入：[1,2,2]
输出：
[
  [1,2,2],
  [2,1,2],
  [2,2,1]
]
```

### 挑战

使用递归和非递归分别完成该题.

```cpp
class Solution {
private:
	void helper(vector<vector<int>>& results, vector<int>& permutation, vector<int>& nums, bool used[]) {
		if (nums.size() == permutation.size()) {
			results.push_back(permutation);
			return;
		}
		for (int i = 0; i < nums.size(); i++) {
			if (used[i]) {
				continue;
			}
			if (i > 0 && used[i - 1] == false && nums[i] == nums[i - 1]) {
				continue;
			}
			used[i] = true;
			permutation.push_back(nums[i]);
			helper(results, permutation, nums, used);
			permutation.pop_back();
			used[i] = false;
		}
	}
public:
	/*
	 * @param nums: A list of integers.
	 * @return: A list of permutations.
	 */
	vector<vector<int>> permuteUnique(vector<int>& nums) {
		vector<vector<int>>results;
		vector<int>permutation;
		bool* used = new bool[nums.size()];
		for (int i = 0; i < nums.size(); i++) {
			used[i] = false;
		}
		sort(nums.begin(), nums.end());
		helper(results, permutation, nums, used);
		return results;
	}
};
```

# 17. 子集

给定一个含不同整数的集合,返回其所有的子集.

### 样例

**样例 1：**

```
输入：[0]
输出：
[
  [],
  [0]
]
```

**样例 2：**

```
输入：[1,2,3]
输出：
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

### 挑战

你可以同时用递归与非递归的方式解决么？

### 注意事项

子集中的元素排列必须是非降序的,解集必须不包含重复的子集.

```cpp
class Solution {
public:
	/**
	 * @param nums: A set of numbers
	 * @return: A list of lists
	 */
	vector<vector<int>> subsets(vector<int>& nums) {
		vector<vector<int>>results;
		vector<int> subset;
		sort(nums.begin(), nums.end());
		helper(results, subset, nums, 0);
		return results;
	}
private:
	void helper(vector<vector<int>>& results, vector<int>& subset, vector<int>& nums, int start) {
		results.push_back(subset);
		for (int i = start; i < nums.size(); i++) {
			subset.push_back(nums[i]);
			helper(results, subset, nums, i + 1);
			subset.pop_back();
		}
	}
};
```

# 20. 骰子求和

扔 *n* 个骰子,向上面的数字之和为 *S*.给定 *n*,请列出所有可能的 *S* 值及其相应的概率.

### 样例

**样例 1：**

```
输入：n = 1
输出：[[1, 0.17], [2, 0.17], [3, 0.17], [4, 0.17], [5, 0.17], [6, 0.17]]
解释：掷一次骰子,向上的数字和可能为1,2,3,4,5,6,出现的概率均为 0.17.
```

**样例 2：**

```
输入：n = 2
输出：[[2,0.03],[3,0.06],[4,0.08],[5,0.11],[6,0.14],[7,0.17],[8,0.14],[9,0.11],[10,0.08],[11,0.06],[12,0.03]]
解释：掷两次骰子,向上的数字和可能在[2,12],出现的概率是不同的.
```

### 注意事项

你不需要关心结果的准确性,我们会帮你输出结果.

```cpp
class Solution {
public:
    /**
     * @param n an integer
     * @return a list of pair<sum, probability>
     */
    vector<pair<int, double>> dicesSum(int n) {
		vector<map<int, double>>dp(n + 1);
		dp[1] = { {1,1 / 6.0},{2,1 / 6.0},{3,1 / 6.0},{4,1 / 6.0},{5,1 / 6.0},{6,1 / 6.0} };
		for (int i = 2; i <= n; i++) {
			for (auto a1 : dp[i - 1]) {
				for (auto a2 : dp[1]) {
					dp[i][a1.first + a2.first] += a1.second * a2.second;
				}
			}
		}
		vector<pair<int, double>>res;
		for (auto a : dp[n]) {
			res.push_back({ a.first,a.second });
		}
		return res;
    }
};
```

# 21. 移动的圆

题目将给出两个圆A和B的圆心坐标(x,y)和半径r,现给你一个点P,使圆A圆心沿直线运动至点P.
请问圆A在运动过程中是否会与圆B相交？(运动过程包括起点和终点)
若会相交返回1,否则返回-1.

### 样例

**样例 1**

```
输入：[0,0,2.5,3,2,0.5,0,2]
输出：1
样例解释：圆A的圆心(0,0),半径为2.5,圆B的圆心(3,2),半径为0.5,点P(0,2)
```

**样例 2**

```
输入：[0,0,2,5,0,1,0,2]
输出：-1
样例解释：圆A的圆心(0,0),半径为2,圆B的圆心(5,0),半径为1,点P(0,2)
```

### 注意事项

两个圆的半径均不超过10000.
横纵坐标值的绝对值均不超过10000.
输入数组的意义为[X_A*X*​*A*​​,Y_A*Y*​*A*​​,R_A*R*​*A*​​,X_B*X*​*B*​​,Y_B*Y*​*B*​​,R_B*R*​*B*​​,X_P*X*​*P*​​,Y_P*Y*​*P*​​].

```cpp
class Solution {
public:
	/**
	 * @param position: the position of circle A,B and point P.
	 * @return: if two circle intersect return 1, otherwise -1.
	 */
	typedef struct point {
		double x, y;
	}point;
	double xmult(point B, point C, point A) {
		return (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y);
	}
	double distance(point A, point B) {
		return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));
	}
	double dis_ptoline(point A, point B, point C) {
		return fabs(xmult(A, B, C)) / distance(B, C);
	}
	int IfIntersect(vector<double>& position) {
		point A, B, P, M;
		double ra, rb;
		double dmin, dmax;
		A.x = position[0];//initialize
		A.y = position[1];
		ra = position[2];
		B.x = position[3];
		B.y = position[4];
		rb = position[5];
		P.x = position[6];
		P.y = position[7];
		M.x = B.x - (P.y - A.y), M.y = B.y + (P.x - A.x);
		if (xmult(A, B, M) * xmult(B, P, M) >= 0) {
			if (A.x == P.x && A.y == P.y) {
				dmin = distance(B, A);
			}
			else {
				dmin = dis_ptoline(B, A, P);
			}
		}
		else {
			dmin = min(distance(A, B), distance(P, B));
		}
		dmax = max(distance(A, B), distance(P, B));
		if (dmin > ra + rb || dmax < fabs(ra - rb)) {
			return -1;
		}
		return 1;
	}
};
```

# 22. 列表扁平化

给定一个列表,该列表中的每个元素要么是个列表,要么是整数.将其变成一个只包含整数的简单列表.

### 样例

```
样例  1:
	输入: [[1,1],2,[1,1]]
	输出:[1,1,2,1,1] 
	
	样例解释:
	将其变成一个只包含整数的简单列表.


样例 2:
	输入: [1,2,[1,2]]
	输出:[1,2,1,2]
	
	样例解释: 
	将其变成一个只包含整数的简单列表.
	
样例 3:
	输入:[4,[3,[2,[1]]]]
	输出:[4,3,2,1]
	
	样例解释: 
	将其变成一个只包含整数的简单列表.
	
```

### 挑战

请用非递归方法尝试解答这道题.

### 注意事项

如果给定的列表中的要素本身也是一个列表,那么它也可以包含列表.

```cpp
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer,
 *     // rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds,
 *     // if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds,
 *     // if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class Solution {
public:
    // @param nestedList a list of NestedInteger
    // @return a list of integer
    vector<int> flatten(vector<NestedInteger> &nestedList) {
        vector<int>res;
        flatten(nestedList,res);
        return res;
    }
    void flatten(const vector<NestedInteger> &nestedList,vector<int>&result){
        for(auto ni:nestedList){
            if(ni.isInteger()){
                result.push_back(ni.getInteger());
            }else{
                flatten(ni.getList(),result);
            }
        }
    }
};
```

# 23. 判断数字与字母字符

给出一个字符`c`,你需要判断它是不是一个数字字符或者字母字符.
如果是,返回`true`,如果不是返回`false`.

### 样例

**样例 1:**

```plain
输入：'1'
输出：true
```

### 注意事项

如果您使用的是Python语言,那么输入将是一个长度为1的字符串.

```cpp
class Solution {
public:
    /**
     * @param c: A character.
     * @return: The character is alphanumeric or not.
     */
	bool isAlphanumeric(char c) {
		if (isalpha(c) || isdigit(c)) {
			return true;
		}
		else {
			return false;
		}
	}
};
```

# 25. 打印X

输入一个正整数N, 你需要按如下方式返回一个字符串列表.

### 样例

**样例 1:**

```
输入：1
输出：
[
"X"
]
```

**样例 2:**

```
输入：2
输出：
[
"XX",
"XX"
]
```

**样例 3:**

```
输入：3
输出：
[
"X X",
" X ",
"X X"
]
```

**样例 4:**

```
输入：4
输出：
[
"X  X",
" XX ",
" XX ",
"X  X"
]
```

**样例 5:**

```
输入：5
输出：
[
"X   X",
" X X ",
"  X  ",
" X X ",
"X   X"
]
```

输入测试数据(每行一个参数)如何理解测试数据？

```cpp
class Solution {
public:
    /**
     * @param n: An integer.
     * @return: A string list.
     */
	vector<string> printX(int n) {
		vector<string>result;
		for (int i = 0; i < n; i++) {
			string temp(n, ' ');
			temp[i] = 'X';
			temp[n - i - 1] = 'X';
			result.push_back(temp);
		}
		return result;
	}
};
```

# 28. 搜索二维矩阵

写出一个高效的算法来搜索 *m* × *n*矩阵中的值.

这个矩阵具有以下特性：

-    每行中的整数从左到右是排序的.
-    每行的第一个数大于上一行的最后一个整数.

### 样例

```
样例  1:
	输入: [[5]],2
	输出: false
	
	样例解释: 
  没有包含,返回false.

样例 2:
	输入:  
[
  [1, 3, 5, 7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
],3
	输出: true
	
	样例解释: 
	包含则返回true.
```

### 挑战

O(log(n) + log(m)) 时间复杂度

```cpp
class Solution {
public:
    /**
     * @param matrix: matrix, a list of lists of integers
     * @param target: An integer
     * @return: a boolean, indicate whether matrix contains target
     */
    bool searchMatrix(vector<vector<int>> &matrix, int target) {
		int n = matrix.size();
		if (n == 0) {
			return false;
		}
		int m = matrix[0].size();
		if (m == 0) {
			return false;
		}
		int start = 0, end = n * m - 1;
		while (start + 1 < end) {
			int mid = start + (end - start) / 2;
			int row = mid / m;
			int col = mid % m;
			if (matrix[row][col] < target) {
				start = mid;
			}
			else {
				end = mid;
			}
		}
		if (matrix[start / m][start % m] == target) {
			return true;
		}
		if (matrix[end / m][end % m] == target) {
			return true;
		}
		return false;
    }
};
```

# 35. 翻转链表

翻转一个链表

### 样例

**样例 1:**

```
输入: 1->2->3->null
输出: 3->2->1->null
```

**样例 2:**

```
输入: 1->2->3->4->null
输出: 4->3->2->1->null
```

### 挑战

在原地一次翻转完成.

```cpp
/**
 * Definition of singly-linked-list:
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param head: n
     * @return: The new head of reversed linked list.
     */
    ListNode * reverse(ListNode * head) {
		ListNode* result = nullptr;
		while (head != nullptr) {
			ListNode* temp = head->next;
			head->next = result;
			result = head;
			head = temp;
		}
		return result;
    }
};
```

# 37. 反转一个3位整数

反转一个只有3位数的整数.

### 样例

**样例 1:**

```
输入: number = 123
输出: 321
```

**样例 2:**

```
输入: number = 900
输出: 9
```

### 注意事项

你可以假设输入一定是一个只有三位数的整数,这个整数大于等于100,小于1000.

```cpp
class Solution {
public:
    /**
     * @param number: A 3-digit number.
     * @return: Reversed number.
     */
    int reverseInteger(int number) {
		return number / 100 + ((number / 10) % 10) * 10 + (number % 10) * 100;
    }
};
```

# 39. 恢复旋转排序数组

给定一个**旋转**排序数组,在原地恢复其排序.(升序)

### 样例

**样例1:**
`[4, 5, 1, 2, 3]` -> `[1, 2, 3, 4, 5]`
**样例2:**
`[6,8,9,1,2]` -> `[1,2,6,8,9]`

### 挑战

使用O(1)的额外空间和O(*n*)时间复杂度

### 说明

什么是旋转数组？

-    比如,原始数组为[1,2,3,4], 则其旋转数组可以是[1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]

```cpp
class Solution {
public:
    /**
     * @param nums: An integer array
     * @return: nothing
     */
    void recoverRotatedSortedArray(vector<int> &nums) {
		int maxindex = -1;
		int size = nums.size();
		for (int i = 0; i < size - 1; i++) {
			if (nums[i] > nums[i + 1]) {
				maxindex = i;
				break;
			}
		}
		if (maxindex == -1) {
			return;
		}
		vector<int>temp;
		for (int i = maxindex + 1; i < size; i++) {
			temp.push_back(nums[i]);
		}
		for (int i = 0; i <= maxindex; i++) {
			temp.push_back(nums[i]);
		}
		nums = temp;
		return;
    }
};
```

# 40. 用栈实现队列

正如标题所述,你需要使用两个栈来实现队列的一些操作.

队列应支持push(element),pop() 和 top(),其中pop是弹出队列中的第一个(最前面的)元素.

pop和top方法都应该返回第一个元素的值.

### 样例

**例1:**

```
输入:
    push(1)
    pop()    
    push(2)
    push(3)
    top()    
    pop()     
输出:
    1
    2
    2
```

**例2:**

```
输入:
    push(1)
    push(2)
    push(2)
    push(3)
    push(4)
    push(5)
    push(6)
    push(7)
    push(1)
输出:
[]
```

### 挑战

仅使用两个栈来实现它,不使用任何其他数据结构,push,pop 和 top的复杂度都应该是均摊O(1)的

### 注意事项

假设调用pop()函数的时候,队列非空

```cpp
class MyQueue {
public:
    stack<int> stk;
    MyQueue() {
        // do intialization if necessary
    }

    /*
     * @param element: An integer
     * @return: nothing
     */
    void push(int element) {
        stk.push(element);
    }

    /*
     * @return: An integer
     */
    int pop() {
        stack<int> temp;
        int size=stk.size();
        for(int i=0;i<size;i++){
            temp.push(stk.top());
            stk.pop();
        }
        int res=temp.top();
        temp.pop();
        size=temp.size();
        for(int i=0;i<size;i++){
            stk.push(temp.top());
            temp.pop();
        }
        return res;
    }

    /*
     * @return: An integer
     */
    int top() {
        stack<int> temp;
        int size=stk.size();
        for(int i=0;i<size;i++){
            temp.push(stk.top());
            stk.pop();
        }
        int res=temp.top();
        size=temp.size();
        for(int i=0;i<size;i++){
            stk.push(temp.top());
            temp.pop();
        }
        return res;
    }
};
```

### 41. 最大子数组

给定一个整数数组,找到一个具有最大和的子数组,返回其最大和.

### 样例

**样例1:**

```
输入：[−2,2,−3,4,−1,2,1,−5,3]
输出：6
解释：符合要求的子数组为[4,−1,2,1],其最大和为 6.
```

**样例2:**

```
输入：[1,2,3,4]
输出：10
解释：符合要求的子数组为[1,2,3,4],其最大和为 10.
```

### 挑战

要求时间复杂度为O(n)

### 注意事项

子数组最少包含一个数

```cpp
class Solution {
public:
    /**
     * @param nums: A list of integers
     * @return: A integer indicate the sum of max subarray
     */
    int maxSubArray(vector<int> &nums) {
        int sum = 0, maxAns = INT_MIN;
        for (int i = 0; i < nums.size(); ++i) {
            sum += nums[i];
            maxAns = max(maxAns, sum);
            sum = max(sum, 0);
        }
        return maxAns;
    }
};
```

# 44. 最小子数组

给定一个整数数组,找到一个具有最小和的连续子数组.返回其最小和.

### 样例

**样例 1**

```
输入：[1, -1, -2, 1]
输出：-3
```

**样例 2**

```
输入：[1, -1, -2, 1, -4]
输出：-6
```

### 注意事项

子数组最少包含一个数字

```cpp
class Solution {
public:
    /*
     * @param nums: a list of integers
     * @return: A integer indicate the sum of minimum subarray
     */
	int minSubArray(vector<int>& nums) {
		int s = nums[0], minsum = s;
		for (int i = 1; i < nums.size(); i++) {
			s = min(0, s) + nums[i];
			minsum = min(minsum, s);
		}
		return minsum;
	}
};
```

# 46. 主元素

给定一个整型数组,找出主元素,它在数组中的出现次数严格大于数组元素个数的二分之一.



### 样例

**样例 1:**

```
输入: [1, 1, 1, 1, 2, 2, 2]
输出: 1
```

**样例 2:**

```
输入: [1, 1, 1, 2, 2, 2, 2]
输出: 2
```

### 挑战

要求时间复杂度为O(n),空间复杂度为O(1)

### 注意事项

你可以假设数组非空,且数组中总是存在主元素.

```cpp
class Solution {
public:
    /*
     * @param nums: a list of integers
     * @return: find a  majority number
     */
    int majorityNumber(vector<int> &nums) {
		vector<pair<int, int>>count;
		pair<int, int>temp(nums[0], 1);
		count.push_back(temp);
		for (int i = 1; i < nums.size(); i++) {
			int flags = 0;
			for (int j = 0; j < count.size(); j++) {
				if (nums[i] == count[j].first) {
					flags = 1;
					count[j].second++;
				}
			}
			if (flags == 0) {
				temp.first = nums[i];
				temp.second = 1;
				count.push_back(temp);
			}
		}
		double size = nums.size() / 2.0;
		for (int i = 0; i < count.size(); i++) {
			if (count[i].second > size) {
				return count[i].first;
			}
		}
    }
};
```

# 47. 主元素 II

描述

给定一个整型数组，找到主元素，它在数组中的出现次数大于数组元素个数的三分之一。

数组中只有唯一的主元素

样例

**样例 1：**

输入：

```
nums = [99,2,99,2,99,3,3]
```

输出：

```
99
```

解释：

99出现了3次
**样例 2：**

输入：

```
nums = [1, 2, 1, 2, 1, 3, 3]
```

输出：

```
1
```

解释：

1出现了3次

挑战

要求时间复杂度为O(n)*O*(*n*)，空间复杂度为O(1)*O*(1)。

```cpp
class Solution {
public:
    /*
     * @param nums: a list of integers
     * @return: The majority number that occurs more than 1/3
     */
    int majorityNumber(vector<int> &nums) {
        sort(nums.begin(), nums.end());
        pair<int,int>cnt(nums[0],1);
        pair<int,int>res=cnt;
        for (int i = 1; 1; i++) {
            if (cnt.first == nums[i]) {
                cnt.second++;
            } else {
                if (res.second<cnt.second) {
                    res.first=cnt.first;
                    res.second=cnt.second;
                }
                cnt.first=nums[i];
                cnt.second=1;
            }
            if(i==nums.size()){
                if (res.second<cnt.second) {
                    res.first=cnt.first;
                    res.second=cnt.second;
                }
                break;
            }
        }
        return res.first;
    }
};
```



# 50. 数组剔除元素后的乘积

给定一个整数数组A.
定义`B[i] = A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]`, 计算B的时候请不要使用除法.请输出B.

### 样例

**样例 1**

```
输入: A = [1, 2, 3]
输出: [6, 3, 2]
解析：B[0] = A[1] * A[2] = 6; B[1] = A[0] * A[2] = 3; B[2] = A[0] * A[1] = 2
```

**样例 2**

```
输入: A = [2, 4, 6]
输出: [24, 12, 8]
```

```cpp
class Solution {
public:
    /*
     * @param nums: Given an integers array A
     * @return: A long long array B and B[i]= A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1]
     */
    vector<long long> productExcludeItself(vector<int> &nums) {
		vector<long long>res;
		for (int i = 0; i < nums.size(); i++) {
			long long temp = 1;
			for (int j = 0; j < nums.size(); j++) {
				if (i != j) {
					temp *= nums[j];
				}
			}
			res.push_back(temp);
		}
		return res;
    }
};
```

# 52. 下一个排列

给定一个整数数组来表示排列,找出其之后的一个排列.

### 样例

例1:

```
输入:[1]
输出:[1]
```

例2:

```
输入:[1,3,2,3]
输出:[1,3,3,2]
```

例3:

```
输入:[4,3,2,1]
输出:[1,2,3,4]
```

### 注意事项

排列中可能包含重复的整数

```cpp
class Solution {
public:
    /**
     * @param nums: A list of integers
     * @return: A list of integers
     */
    vector<int> nextPermutation(vector<int> &nums) {
        if(nums.size()==1){
            return nums;
        }
        int i=nums.size()-2;
        while(i>=0 and nums[i]>=nums[i+1]){
            i--;
        }
        int j=nums.size()-1;
        if(i>=0){
            while(nums[j]<=nums[i]){
                j--;
            }
            swap(nums[i],nums[j]);
        }
        reverse(nums.begin()+i+1,nums.end());
        return nums;
    }
};
```



# 53. 翻转字符串中的单词

给定一个字符串,逐个翻转字符串中的每个单词.

### 样例

```
样例  1:
	输入:  "the sky is blue"
	输出:  "blue is sky the"
	
	样例解释: 
	返回逐字反转的字符串.

样例 2:
	输入:  "hello world"
	输出:  "world hello"
	
	样例解释: 
	返回逐字反转的字符串.
```

### 说明



-    单词的构成：无空格字母构成一个单词,有些单词末尾会带有标点符号
-    输入字符串是否包括前导或者尾随空格？可以包括,但是反转后的字符不能包括
-    如何处理两个单词间的多个空格？在反转字符串中间空格减少到只含一个

```cpp
class Solution {
public:
    /*
     * @param s: A string
     * @return: A string
     */
	string reverseWords(string& s) {
		if (s.find_first_not_of(' ') == string::npos) {
			return "";
		}
		string res;
		int i = s.length() - 1;
		do {
			vector<char>temp;
			for (; i >= 0 and s[i] != ' '; i--) {
				temp.push_back(s[i]);
			}
			i--;
			reverse(temp.begin(), temp.end());
			if (temp.size() > 0) {
				for (int j = 0; j < temp.size(); j++) {
					res += temp[j];
				}
				res += ' ';
			}
		} while (i >= 0);
		return res;
	}
};
```

# 55. 比较字符串

比较两个字符串A和B,确定A中是否包含B中所有的字符.字符串A和B中的字符都是 **大写字母**

### 样例

给出 A = `"ABCD"` B = `"ACD"`,返回 `true`

给出 A = `"ABCD"` B = `"AABC"`, 返回 `false`

### 注意事项

在 A 中出现的 B 字符串里的字符不需要连续或者有序.

```cpp
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: if string A contains all of the characters in B return true else return false
     */
	bool compareStrings(string& A, string& B) {
		for (int i = 0; i < B.size(); i++) {
			bool find = false;
			for (int j = 0; j < A.size(); j++) {
				if (A[j] == B[i]) {
					A.erase(A.begin() + j);
					find = true;
					break;
				}
			}
			if (!find) {
				return false;
			}
		}
		return true;
	}
};
```

# 56. 两数之和

给一个整数数组,找到两个数使得他们的和等于一个给定的数 *target*.

你需要实现的函数`twoSum`需要返回这两个数的下标, 并且第一个下标小于第二个下标.注意这里下标的范围是 0 到 *n-1*.

### 样例

```
样例1:
给出 numbers = [2, 7, 11, 15], target = 9, 返回 [0, 1].
样例2:
给出 numbers = [15, 2, 7, 11], target = 9, 返回 [1, 2].
```

### 挑战

给自己加点挑战

-    O(n)*O*(*n*) 空间复杂度,O(nlogn)*O*(*n**l**o**g**n*) 时间复杂度,
-    O(n)*O*(*n*) 空间复杂度,O(n)*O*(*n*) 时间复杂度,

### 注意事项

你可以假设只有一组答案.

```cpp
class Solution {
public:
    /**
     * @param numbers: An array of Integer
     * @param target: target = numbers[index1] + numbers[index2]
     * @return: [index1 + 1, index2 + 1] (index1 < index2)
     */
    vector<int> twoSum(vector<int> &numbers, int target) {
		vector<int>res;
		size_t size = numbers.size();
		for (int i = 0; i < size; ++i) {
			for (int j = i + 1; j < size; ++j) {
				if (target == numbers[i] + numbers[j]) {
					res.push_back(i);
					res.push_back(j);
					return res;
				}
			}
		}
    }
};
```

# 60. 搜索插入位置

给定一个排序数组和一个目标值,如果在数组中找到目标值则返回索引.如果没有,返回到它将会被按顺序插入的位置.

你可以假设在数组中无重复元素.

### 样例

**[1,3,5,6]**,5 → 2

**[1,3,5,6]**,2 → 1

**[1,3,5,6]**, 7 → 4

**[1,3,5,6]**,0 → 0

### 挑战

时间复杂度为O(log(n))

```cpp
class Solution {
public:
    /**
     * @param A: an integer sorted array
     * @param target: an integer to be inserted
     * @return: An integer
     */
    int searchInsert(vector<int> &A, int target) {
        if(A.size()==0){
            return 0;
        }
        for(int i=0;i<A.size();i++){
            if(A[i]>=target){
                return i;
            }
        }
        return A.size();
    }
};
```

# 64. 合并排序数组(简单版)

合并两个排序的整数数组A和B变成一个新的数组.

### 样例

**样例 1:**

```
输入：[1, 2, 3]  3  [4,5]  2
输出：[1,2,3,4,5]
解释:
经过合并新的数组为[1,2,3,4,5]
```

**样例 2:**

```
输入：[1,2,5] 3 [3,4] 2
输出：[1,2,3,4,5]
解释：
经过合并新的数组为[1,2,3,4,5]
```

### 注意事项

你可以假设A具有足够的空间(A数组的大小大于或等于m+n)去添加B中的元素.

```cpp
class Solution {
public:
    /*
     * @param A: sorted integer array A which has m elements, but size of A is m+n
     * @param m: An integer
     * @param B: sorted integer array B which has n elements
     * @param n: An integer
     * @return: nothing
     */
    void mergeSortedArray(int A[], int m, int B[], int n) {
        for(int i=0;i<n;i++){
            A[m+i]=B[i];
        }
        sort(A,A+m+n,less<int>());
        return;
    }
};
```

# 66.  二叉树的前序遍历

描述

给出一棵二叉树,返回其节点值的前序遍历.

首个数据为根节点,后面接着是其左儿子和右儿子节点值,"#"表示不存在该子节点.节点数量不超过20

样例

**样例 1:**

```
输入：{1,2,3}
输出：[1,2,3]
解释：
   1
  / \
 2   3
它将被序列化为{1,2,3}
前序遍历
```

**样例 2:**

```
输入：{1,#,2,3}
输出：[1,2,3]
解释：
1
 \
  2
 /
3
它将被序列化为{1,#,2,3}
前序遍历
```

挑战

你能使用非递归实现么？

```cpp
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: A Tree
     * @return: Preorder in ArrayList which contains node values.
     */
    vector<int>preorder;
    void traverse(TreeNode*root){
        if(root==NULL){
            return;
        }
        preorder.push_back(root->val);
        traverse(root->left);
        traverse(root->right);
    }
    vector<int> preorderTraversal(TreeNode * root) {
        preorder.clear();
        traverse(root);
        return preorder;
    }
};
```

# 67.  二叉树的中序遍历

描述

给出一棵二叉树,返回其中序遍历

样例

**样例 1:**

```
输入：{1,2,3}
输出：[2,1,3]
解释：
   1
  / \
 2   3
它将被序列化为{1,2,3}
中序遍历
```

**样例 2:**

```
输入：{1,#,2,3}
输出：[1,3,2]
解释：
1
 \
  2
 /
3
它将被序列化为{1,#,2,3}
中序遍历
```

```cpp
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    vector<int>res;
    void traversal(TreeNode* root){
        while(root==NULL){
            return;
        }
        traversal(root->left);
        res.push_back(root->val);
        traversal(root->right);
    }
    vector<int> inorderTraversal(TreeNode * root) {
        res.clear();
        traversal(root);
        return res;
    }
};
```



# 68. 二叉树的后序遍历

描述

给出一棵二叉树,返回其节点值的前序遍历.

首个数据为根节点,后面接着是其左儿子和右儿子节点值,"#"表示不存在该子节点.节点数量不超过20

样例

**样例 1:**

```
输入：{1,2,3}
输出：[1,2,3]
解释：
   1
  / \
 2   3
它将被序列化为{1,2,3}
前序遍历
```

**样例 2:**

```
输入：{1,#,2,3}
输出：[1,2,3]
解释：
1
 \
  2
 /
3
它将被序列化为{1,#,2,3}
前序遍历
```

挑战

你能使用非递归实现么？

```cpp
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: A Tree
     * @return: Preorder in ArrayList which contains node values.
     */
    vector<int>preorder;
    void traverse(TreeNode*root){
        if(root==NULL){
            return;
        }
        preorder.push_back(root->val);
        traverse(root->left);
        traverse(root->right);
    }
    vector<int> preorderTraversal(TreeNode * root) {
        preorder.clear();
        traverse(root);
        return preorder;
    }
};
```



# 75. 寻找峰值

你给出一个整数数组(size为n),其具有以下特点：

-    相邻位置的数字是不同的
-    A[0] < A[1] 并且 A[n - 2] > A[n - 1]

假定*P*是峰值的位置则满足`A[P] > A[P-1]`且`A[P] > A[P+1]`,返回数组中任意一个峰值的位置.

### 样例

```
样例 1:
	输入:  [1, 2, 1, 3, 4, 5, 7, 6]
	输出:  1 or 6
	
	解释:
	返回峰顶元素的下标


样例 2:
	输入: [1,2,3,4,1]
	输出:  3
```

### 挑战

时间复杂度O (logN)

### 注意事项

-    数组保证至少存在一个峰
-    如果数组存在多个峰,返回其中任意一个就行
-    数组至少包含 3 个数

```cpp
class Solution {
public:
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    int findPeak(vector<int> &A) {
        int l=1,r=A.size();
        while(l<=r){
            int mid=(l+r)/2;
            if(A[mid]>A[mid-1] and A[mid]>A[mid+1]){
                return mid;
            }
            if(A[mid]>A[mid-1]){
                l=mid+1;
            }
            else{
                r=mid-1;
            }
        }
        return -1;
    }
};
```

# 76. 最长上升子序列

给定一个整数序列,找到最长上升子序列(LIS),返回LIS的长度.

### 样例

```
样例 1:
	输入:  [5,4,1,2,3]
	输出:  3
	
	解释:
	LIS 是 [1,2,3]


样例 2:
	输入: [4,2,4,5,3,7]
	输出:  4
	
	解释: 
	LIS 是 [2,4,5,7]
```

### 挑战

要求时间复杂度为O(n^2) 或者 O(nlogn)

### 说明

最长上升子序列的定义：

最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列,这种子序列不一定是连续的或者唯一的.
https://en.wikipedia.org/wiki/Longest_increasing_subsequence

```cpp
class Solution {
public:
    int longestIncreasingSubsequence(vector<int> &nums) {
        if (nums.size() == 0) {
            return 0;
        }
        int res = 1;
        vector<int> LIS(nums.size(), 1);
        for (int i = 1; i < nums.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    LIS[i] = max(LIS[i], LIS[j] + 1);
                }
            }
            res = max(res, LIS[i]);
        }
        return res;
    }
};
```

# 80. 中位数

给定一个未排序的整数数组,找到其中位数.

中位数是排序后数组的中间值,如果数组的个数是偶数个,则返回排序后数组的第N/2个数.

### 样例

**样例 1:**

```
输入：[4, 5, 1, 2, 3]
输出：3
解释：
经过排序,得到数组[1,2,3,4,5],中间数字为3
```

**样例 2:**

```
输入：[7, 9, 4, 5]
输出：5
解释：
经过排序,得到数组[4,5,7,9],第二个(4/2)数字为5
```

### 挑战

时间复杂度为O(n)

### 注意事项

数组大小不超过10000

```cpp
class Solution {
public:
    /**
     * @param nums: A list of integers
     * @return: An integer denotes the middle number of the array
     */
    int median(vector<int> &nums) {
		sort(nums.begin(), nums.end());
		if (nums.size() % 2 == 0) {
			return nums[(nums.size() / 2) - 1];
		}
		else {
			return nums[nums.size() / 2];
		}
    }
};
```

# 82. 落单的数

给出 `2 * n + 1`个数字,除其中一个数字之外其他每个数字均出现两次,找到这个数字.

### 样例

**样例 1:**

```
输入：[1,1,2,2,3,4,4]
输出：3
解释：
仅3出现一次
```

**样例 2:**

```
输入：[0,0,1]
输出：1
解释：
仅1出现一次
```

### 挑战

一次遍历,常数级的额外空间复杂度

### 注意事项

-    n≤100

```cpp
class Solution {
public:
    /**
     * @param A: An integer array
     * @return: An integer
     */
    int singleNumber(vector<int> &A) {
		vector<pair<int, int>>count;
		pair<int, int>temp;
		temp.first = A[0];
		temp.second = 1;
		count.push_back(temp);
		for (int i = 1; i < A.size(); i++) {
			bool flag = true;
			for (int j = 0; j < count.size(); j++) {
				if (count[j].first == A[i]) {
					count[j].second++;
					flag = false;
					break;
				}
			}
			if (flag) {
				temp.first = A[i];
				temp.second = 1;
				count.push_back(temp);
			}
		}
		for (int i = 0; i < count.size(); i++) {
			if (count[i].second == 1) {
				return count[i].first;
			}
		}
    }
};
```

# 85. 在二叉查找树中插入节点

描述

给定一棵二叉查找树和一个新的树节点，将节点插入到树中。

你需要保证该树仍然是一棵二叉查找树。

保证不会出现重复的值

样例

**样例 1：**

输入：

```
tree = {}
node= 1
```

输出：

```
{1}
```

解释：

在空树中插入一个点，应该插入为根节点。

**样例 2：**

输入：

```
tree = {2,1,4,#,#,3}
node = 6
```

输出：

```
{2,1,4,#,#,3,6}
```

解释：

如下:
2               2
/  \             /  \
1   4     -->    1    4
/                / \
3                3   6

挑战

能否不使用递归？

```cpp
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    TreeNode* insertNode(TreeNode* root, TreeNode* node) {
        if (root == NULL) {
            return node;
        }
        if (node->val < root->val) {
            root->left = insertNode(root->left, node);
            return root;
        }
        root->right = insertNode(root->right, node);
        return root;
    }
};
```



# 93.  平衡二叉树

描述

给定一个二叉树,确定它是高度平衡的.对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1. 

样例

```
样例  1:
	输入: tree = {1,2,3}
	输出: true
	
	样例解释:
	如下,是一个平衡的二叉树.
		  1  
		 / \                
		2  3

	
样例  2:
	输入: tree = {3,9,20,#,#,15,7}
	输出: true
	
	样例解释:
	如下,是一个平衡的二叉树.
		  3  
		 / \                
		9  20                
		  /  \                
		 15   7 

	
样例  2:
	输入: tree = {1,#,2,3,4}
	输出: false
	
	样例解释:
	如下,是一个不平衡的二叉树.1的左右子树高度差2
		  1  
		   \                
		   2                
		  /  \                
		 3   4
	
```

```cpp
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: True if this Binary tree is Balanced, or false.
     */
    bool isBalanced(TreeNode * root) {
        return dfs(root).first;
    }
    pair<bool,int>dfs(TreeNode*root){
        if(!root){
            return {true,0};
        }
        auto l=dfs(root->left);
        auto r=dfs(root->right);
        pair<bool,int>ans={true,max(l.second,r.second)+1};
        ans.first&=l.first&&r.first &&(abs(l.second-r.second)<=1);
        return ans;
    }
};
```



# 97. 二叉树的最大深度

描述

给定一个二叉树，找出其最大深度。

最大深度是从根节点到叶节点的最长路径的节点数。

最终答案不会超过 `5000`

样例

**样例 1：**

输入：

```
tree = {}
```

输出：

```
0
```

解释：

空树的深度是0。

**样例 2：**

输入：

```
tree = {1,2,3,#,#,4,5}
```

输出：

```
3
```

解释：

树表示如下，深度是3
1
/ \
2  3
/  \
4  5
它将被序列化为{1,2,3,#,#,4,5}

```cpp
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int maxDepth(TreeNode * root) {
        if(root == NULL)
            return 0;
        int leftdep = maxDepth(root->left);
        int rightdep = maxDepth(root->right);
        int dep = max(leftdep, rightdep);
        return dep +1;
    }
};
```

# 100. 删除排序数组中的重复数字

给定一个排序数组,在原数组中"删除"重复出现的数字,使得每个元素只出现一次,并且返回"新"数组的长度.

不要使用额外的数组空间,必须在不使用额外空间的条件下原地完成.

### 样例

**样例 1:**

```
输入:  []
输出: 0
```

**样例 2:**

```
输入:  [1,1,2]
输出: 2	
解释:  数字只出现一次的数组为: [1,2]
```

```
class Solution {
public:
    /*
     * @param nums: An ineger array
     * @return: An integer
     */
    int removeDuplicates(vector<int> &nums) {
        vector<int>::iterator iter=unique(nums.begin(),nums.end());
        nums.erase(iter,nums.end());
        return nums.size();
    }
};
```

# 101. 删除排序数组中的重复数字 II

给你一个排序数组,删除其中的重复元素,使得每个数字最多出现两次,返回新的数组的长度.
如果一个数字出现超过2次,则这个数字最后保留两个.

### 样例

```
样例 1:
	输入: []
	输出: 0


样例 2:
	输入:  [1,1,1,2,2,3]
	输出: 5
	
	样例解释: 
	长度为 5,  数组为：[1,1,2,2,3]
```

### 注意事项

需要在原数组中操作

```cpp
class Solution {
public:
    /**
     * @param A: a list of integers
     * @return : return an integer
     */
    int removeDuplicates(vector<int> &nums) {
        if(nums.size()==0){
            return 0;
        }
        bool equal=false;
        for(int i=1;i<nums.size();){
            if(nums[i]==nums[i-1] and equal==false){
                equal=true;
                ++i;
            }
            else if(nums[i]!=nums[i-1]){
                equal=false;
                ++i;
            }
            else{
                nums.erase(nums.begin()+i);
            }
        }
        return nums.size();
    }
};
```

# 110. 最小路径和

给定一个只含非负整数的m*n网格,找到一条从左上角到右下角的可以使数字和最小的路径.



### 样例

样例 1:

```
输入:  [[1,3,1],[1,5,1],[4,2,1]]
输出: 7	
样例解释：
路线为： 1 -> 3 -> 1 -> 1 -> 1.
```

样例 2:

```
输入:  [[1,3,2]]
输出:  6
解释:  
路线是： 1 -> 3 -> 2
```

### 注意事项

你在同一时间只能向下或者向右移动一步

```cpp
class Solution {
public:
    /**
     * @param grid: a list of lists of integers
     * @return: An integer, minimizes the sum of all numbers along its path
     */
    int minPathSum(vector<vector<int>> &grid) {
        int f[1000][1000];
        if(grid.size()==0 or grid[0].size()==0){
            return 0;
        }
        f[0][0]=grid[0][0];
        for(int i=0;i<grid.size();i++){
            f[i][0]=f[i-1][0]+grid[i][0];
        }
        for(int i=1;i<grid[0].size();i++){
            f[0][i]=f[0][i-1]+grid[0][i];
        }
        for(int i=1;i<grid.size();i++){
            for(int j=1;j<grid[0].size();j++){
                f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j];
            }
        }
        return f[grid.size()-1][grid[0].size()-1];
    }
};
```

# 111. 爬楼梯

假设你正在爬楼梯,需要n步你才能到达顶部.但每次你只能爬一步或者两步,你能有多少种不同的方法爬到楼顶部？

### 样例

```
样例 1:
	输入:  n= 3
	输出: 3
	
	样例解释：
	1) 1, 1, 1
	2) 1, 2
	3) 2, 1
	共3种


样例 2:
	输入:  n = 1
	输出: 1
	
	解释:  
	只有一种方案
```

```cpp
class Solution {
public:
    /**
     * @param n: An integer
     * @return: An integer
     */
    int climbStairs(int n) {
        int a=min(n,1);
        for(auto i=1,b=a;i<n;++i,b=a-b){
            a+=b;
        }
        return a;
    }
};
```

# 112. 删除排序链表中的重复元素

给定一个排序链表,删除所有重复的元素每个元素只留下一个.

### 样例

```
样例 1:
	输入:  null
	输出: null


样例 2:
	输入: 1->1->2->null
	输出: 1->2->null

样例 3:
	输入: 1->1->2->3->3->null
	输出: 1->2->3->null
```

```cpp
/**
 * Definition of singly-linked-list:
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param head: head is the head of the linked list
     * @return: head of linked list
     */
    ListNode * deleteDuplicates(ListNode * head) {
        ListNode *res=head;
        if(head==nullptr){
            return head;
        }
        for(ListNode *reshead=nullptr;head->next!=NULL;){
            reshead=head->next;
            if(head->val==reshead->val){
                head->next=reshead->next;
            }else{
                head=head->next;
            }
        }
        return res;
    }
};
```

# 114. 不同的路径

有一个机器人的位于一个 *m* × *n* 个网格左上角.

机器人每一时刻只能向下或者向右移动一步.机器人试图达到网格的右下角.

问有多少条不同的路径？

### 样例

**样例 1:**

```
输入: n = 1, m = 3
输出: 1	
解释: 只有一条通往目标位置的路径.
```

**样例 2:**

```
输入:  n = 3, m = 3
输出: 6	
解释:
	D : Down
	R : Right
	1) DDRR
	2) DRDR
	3) DRRD
	4) RRDD
	5) RDRD
	6) RDDR
```

### 注意事项

n和m均不超过100
且答案保证在32位整数可表示范围内.

```cpp
class Solution {
public:
    /**
     * @param m: positive integer (1 <= m <= 100)
     * @param n: positive integer (1 <= n <= 100)
     * @return: An integer
     */
	int uniquePaths(int m, int n) {
		vector<vector<int>>count(m, vector<int>(n, 1));
		for (int i = m - 2; i >= 0; --i) {
			for (int j = n - 2; j >= 0; --j) {
				count[i][j] = count[i + 1][j] + count[i][j + 1];
			}
		}
		return count[0][0];
	}
};
```

# 117. 跳跃游戏 II

给出一个非负整数数组,你最初定位在数组的第一个位置.

数组中的每个元素代表你在那个位置可以跳跃的最大长度.　　　

你的目标是使用最少的跳跃次数到达数组的最后一个位置.

### 样例

***样例 1***

```
输入 : [2,3,1,1,4]
输出 : 2
解释 : 到达最后位置的最小跳跃次数是2(从下标0到1跳跃1个距离长度,然后跳跃3个距离长度到最后位置)
```

```cpp
class Solution {
public:
    /**
     * @param A: A list of integers
     * @return: An integer
     */
    int jump(vector<int> &A) {
        int n=A.size();
        vector<int>dp(n);
        dp[0]=0;
        for(int i=1;i<n;i++){
            dp[i]=INT_MAX;
            for(int j=0;j<i;j++){
                if(A[j]+j>=i){
                    dp[i]=min(dp[i],dp[j]+1);
                }
            }
        }
        return dp[n-1];
    }
};
```

# 125. 背包问题 II

有 `n` 个物品和一个大小为 `m` 的背包. 给定数组 `A` 表示每个物品的大小和数组 `V` 表示每个物品的价值.

问最多能装入背包的总价值是多大?

### 样例

**样例 1:**

```
输入: m = 10, A = [2, 3, 5, 7], V = [1, 5, 2, 4]
输出: 9
解释: 装入 A[1] 和 A[3] 可以得到最大价值, V[1] + V[3] = 9 
```

**样例 2:**

```
输入: m = 10, A = [2, 3, 8], V = [2, 5, 8]
输出: 10
解释: 装入 A[0] 和 A[2] 可以得到最大价值, V[0] + V[2] = 10
```

### 挑战

O(nm) 空间复杂度可以通过, 不过你可以尝试 O(m) 空间复杂度吗?

### 注意事项

1.   `A[i], V[i], n, m` 均为整数
2.   你不能将物品进行切分
3.   你所挑选的要装入背包的物品的总大小不能超过 `m`
4.   每个物品只能取一次

```cpp
class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @param V: Given n items with value V[i]
     * @return: The maximum value
     */
    int backPackII(int m, vector<int> &A, vector<int> &V) {
        vector<int>f(m+1,0);
        for(int i=0;i<A.size();i++){
            for(int j=m;j>=A[i];j--){
                f[j]=max(f[j],f[j-A[i]]+V[i]);
            }
        }
        return f[m];
    }
};
```

# 128. 哈希函数

在数据结构中,哈希函数是用来将一个字符串(或任何其他类型)转化为小于哈希表大小且大于等于零的整数.一个好的哈希函数可以尽可能少地产生冲突.一种广泛使用的哈希函数算法是使用数值33,假设任何字符串都是基于33的一个大整数,比如：

hashcode("abcd") = (ascii(a) * 333 + ascii(b) * 332 + ascii(c) *33 + ascii(d)) % HASH_SIZE 

​               = (97* 333 + 98 * 332 + 99 * 33 +100) % HASH_SIZE

​               = 3595978 % HASH_SIZE

其中HASH_SIZE表示哈希表的大小(可以假设一个哈希表就是一个索引0 ~ HASH_SIZE-1的数组).

给出一个字符串作为key和一个哈希表的大小,返回这个字符串的哈希值.

### 样例

**样例 1:**

```
输入:  key = "abcd", size = 1000
输出: 978	
样例解释：(97 * 33^3 + 98*33^2 + 99*33 + 100*1)%1000 = 978
```

**样例 2:**

```
输入:  key = "abcd", size = 100
输出: 78	
样例解释：(97 * 33^3 + 98*33^2 + 99*33 + 100*1)%100 = 78
```

### 说明

对于这个问题,您没有必要设计自己的哈希算法或考虑任何冲突问题,您只需要按照描述实现算法.

```cpp
class Solution {
public:
    /**
     * @param key: A string you should hash
     * @param HASH_SIZE: An integer
     * @return: An integer
     */
    int hashCode(string &key, int HASH_SIZE) {
		vector<long long>hash;
		hash.push_back(1);
		for (int i = 1; i < key.size(); i++) {
			hash.push_back((hash[i - 1] * 33) % HASH_SIZE);
		}
		long long res = 0;
		for (int i = 0; i < key.size(); i++) {
			res += int(key[i]) * hash[key.size() - 1 - i];
			res %= HASH_SIZE;
		}
		return res;
    }
};
```

# 133. 最长单词

给一个词典,找出其中所有最长的单词.

### 样例

```
样例 1:
	输入:   {
		"dog",
		"google",
		"facebook",
		"internationalization",
		"blabla"
		}
	输出: ["internationalization"]



样例 2:
	输入: {
		"like",
		"love",
		"hate",
		"yes"		
		}
	输出: ["like", "love", "hate"]
```

### 挑战

遍历两次的办法很容易想到,如果只遍历一次你有没有什么好办法？

```cpp
class Solution {
public:
    /*
     * @param dictionary: an array of strings
     * @return: an arraylist of strings
     */
    vector<string> longestWords(vector<string> &dictionary) {
		vector<string>res;
		res.push_back(dictionary[0]);
		vector<string>::iterator iter;
		for (iter = dictionary.begin() + 1; iter != dictionary.end(); ++iter) {
			if (iter->size() > res[0].size()) {
				res.clear();
				res.push_back(*iter);
			}
			else if (iter->size() == res[0].size()) {
				res.push_back(*iter);
			}
		}
		return res;
    }
};
```

# 138. 子数组之和

给定一个整数数组,找到和为 0 的子数组.你的代码应该返回满足要求的子数组的起始位置和结束位置

### 样例

**样例 1:**

```
输入: [-3, 1, 2, -3, 4]
输出: [0,2] 或 [1,3]	
样例解释： 返回任意一段和为0的区间即可.
```

**样例 2:**

```
输入: [-3, 1, -4, 2, -3, 4]
输出: [1,5]
```

### 注意事项

至少有一个子数组的和为 0

```cpp
class Solution {
public:
    /**
     * @param nums: A list of integers
     * @return: A list of integers includes the index of the first number and the index of the last number
     */
    vector<int> subarraySum(vector<int> &nums) {
		vector<int>result;
		unordered_map<int, int>hash;
		hash[0] = -1;
		int sum = 0;
		for (int i = 0; i < nums.size(); i++) {
			//累加前缀和
			sum += nums[i];
			//前缀和曾经出现,即这个区间的和为0
			if (hash.find(sum) != hash.end()) {
				result.push_back(hash[sum] + 1);
				result.push_back(i);
				break;
			}
			//前缀和第一次出现,存入hash
			hash[sum] = i;
		}
		return result;
    }
};
```

# 141. 对x开根

实现 `int sqrt(int x)` 函数,计算并返回 *x* 的平方根.

### 样例

```
样例 1:
	输入:  0
	输出: 0


样例 2:
	输入: 3
	输出: 1
	
	样例解释：
	返回对x开根号后向下取整的结果.

样例 3:
	输入: 4
	输出: 2
```

### 挑战

```cpp
class Solution {
public:
    /**
     * @param x: An integer
     * @return: The sqrt of x
     */
    int sqrt(int x) {
        long long res=1+x/2,del=res;
        for(;abs(del=res*res-x)>=res*2;res-=del/2/res);
        return del>0?--res:res;
    }
};
```

# 142. O(1)时间检测2的幂次

用 O(*1*) 时间检测整数 *n* 是否是 *2* 的幂次.

### 样例

`n=4`,返回 `true`;

`n=5`,返回 `false`.

### 挑战

O(*1*) 时间复杂度

```cpp
class Solution {
public:
    /**
     * @param n: An integer
     * @return: True or false
     */
    bool checkPowerOf2(int n) {
        if(n==0){
            return false;
        }
        while(n%2==0){
            n/=2;
        }
        return n==1;
    }
};
```

# 145. 大小写转换

将一个字符由小写字母转换为大写字母

### 样例

**样例 1:**

```
输入: 'a'
输出: 'A'
```

**样例 2:**

```
输入: 'b'
输出: 'B'
```

### 注意事项

你可以假设输入一定在小写字母 a ~ z 之间

```cpp
class Solution {
public:
    /**
     * @param character: a character
     * @return: a character
     */
    char lowercaseToUppercase(char character) {
		character = toupper(character);
		return character;
    }
};
```

# 148. 颜色分类

给定一个包含红,白,蓝且长度为 n 的数组,将数组元素进行分类使相同颜色的元素相邻,并按照红、白、蓝的顺序进行排序.

我们可以使用整数 0,1 和 2 分别代表红,白,蓝.

### 样例

***样例 1***

```
输入 : [1, 0, 1, 2]
输出 : [0, 1, 1, 2]
解释 : 原地排序.
```

### 挑战

一个相当直接的解决方案是使用计数排序扫描2遍的算法.

首先,迭代数组计算 0,1,2 出现的次数,然后依次用 0,1,2 出现的次数去覆盖数组.

你否能想出一个仅使用常数级额外空间复杂度且只扫描遍历一遍数组的算法？

### 注意事项

不能使用代码库中的排序函数来解决这个问题.
排序需要在原数组中进行.

```cpp
bool cmp(int a,int b){
    if(a<b){
        return true;
    }
    else{
        return false;
    }
}
class Solution {
public:
    /**
     * @param nums: A list of integer which is 0, 1 or 2 
     * @return: nothing
     */
    void sortColors(vector<int> &nums) {
        sort(nums.begin(),nums.end(),cmp);
    }
};
```

# 156. 合并区间

给出若干闭合区间,合并所有重叠的部分.

### 样例

**样例1:**

```
输入: [(1,3)]
输出: [(1,3)]
```

**样例 2:**

```
输入:  [(1,3),(2,6),(8,10),(15,18)]
输出: [(1,6),(8,10),(15,18)]
```

### 挑战

O(*n* log *n*) 的时间和 O(1) 的额外空间.

```cpp
class Solution {
public:
	/**
	 * @param intervals: interval list.
	 * @return: A new interval list.
	 */
	vector<Interval> merge(vector<Interval>& intervals) {
		if (intervals.size() == 1 or intervals.size() == 0) {
			return intervals;
		}
		Sort(intervals);
		vector<Interval>res;
		int left = intervals[0].start, right = intervals[0].end;
		for (int i = 1; i < intervals.size(); i++) {
			if (intervals[i].start < right and intervals[i].end>right) {
				right = intervals[i].end;
			}
			else if (intervals[i].start > right) {
				Interval temp(left, right);
				res.push_back(temp);
				left = intervals[i].start;
				right = intervals[i].end;
			}
			else if (intervals[i].start == right and left<intervals[i].end) {
				right = intervals[i].end;
			}
			if (i == intervals.size() - 1) {
				Interval temp(left, right);
				res.push_back(temp);
			}
		}
		return res;
	}
	void Sort(vector<Interval>& intervals) {
		for (int i = 0; i < intervals.size(); i++) {
			for (int j = 0; j < intervals.size() - 1 - i; j++) {
				if (intervals[j].start > intervals[j + 1].start) {
					swap(intervals[j], intervals[j + 1]);
				}
			}
		}
	}
};
```

# 157. 判断字符串是否没有重复字符

实现一个算法确定字符串中的字符是否均唯一出现

### 样例

**样例 1:**

```
输入:  "abc_____"
输出:  false
```

**样例 2:**

```
输入:  "abc"
输出:  true	
```

### 挑战

如果不使用额外的存储空间,你的算法该如何改变？

输入测试数据(每行一个参数)如何理解测试数据？

```cpp
class Solution {
public:
    /*
     * @param str: A string
     * @return: a boolean
     */
    bool isUnique(string &str) {
		char ascii[128] = { 0 };
		for (int i = 0; i < str.size(); i++) {
			if (ascii[str[i]] == 0) {
				ascii[str[i]] = 1;
			}
			else {
				return false;
			}
		}
		return true;
    }
};
```

# 158. 两个字符串是变位词

写出一个函数 `anagram(s, t)` 判断两个字符串是否可以通过改变字母的顺序变成一样的字符串.

### 样例

**样例 1:**

```
输入: s = "ab", t = "ab"
输出: true
```

**样例 2:**

```
输入:  s = "abcd", t = "dcba"
输出: true
```

**样例 3:**

```
输入:  s = "ac", t = "ab"
输出: false
```

### 挑战

O(n) 的时间复杂度, O(1) 的额外空间

### 说明

什么是 **Anagram**?

-    在更改字符顺序后两个字符串可以相同

```cpp
class Solution {
public:
    /**
     * @param s: The first string
     * @param t: The second string
     * @return: true or false
     */
    bool anagram(string &s, string &t) {
        sort(s.begin(),s.end());
        sort(t.begin(),t.end());
        if(s==t){
            return true;
        }
        else{
            return false;
        }
    }
};
```

# 165. 合并两个排序链表

描述

将两个排序(升序)链表合并为一个新的升序排序链表

样例

```
样例 1:
	输入: list1 = null, list2 = 0->3->3->null
	输出: 0->3->3->null


样例2:
	输入:  list1 =  1->3->8->11->15->null, list2 = 2->null
	输出: 1->2->3->8->11->15->null
```

```cpp
/**
 * Definition of singly-linked-list:
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param l1: ListNode l1 is the head of the linked list
     * @param l2: ListNode l2 is the head of the linked list
     * @return: ListNode head of linked list
     */
    ListNode * mergeTwoLists(ListNode * l1, ListNode * l2) {
        if(l1==NULL){
            return l2;
        }
        if(l2==NULL){
            return l1;
        }
        if(l1->val<l2->val){
            return sort(l1,l2);
        }
        else{
            return sort(l2,l1);
        }
    }

    ListNode * sort(ListNode * l1, ListNode * l2){
        ListNode*res=l1;
        ListNode*run=l1;
        l1=l1->next;
        do{
            if(l1->val<l2->val){
                run->next=l1;
                run=run->next;
                if(l1->next!=NULL){
                    l1=l1->next;
                }
                else{
                    run->next=l2;
                    break;
                }
            }
            else{
                run->next=l2;
                run=run->next;
                if(l2->next!=NULL){
                    l2=l2->next;
                }
                else{
                    run->next=l1;
                    break;
                }
            }   
        }while(1);
        return res;
    }
};
```



# 167. 链表求和

你有两个用链表代表的整数,其中每个节点包含一个数字.数字存储按照在原来整数中`相反`的顺序,使得第一个数字位于链表的开头.写出一个函数将两个整数相加,用链表形式返回和.

### 样例

**样例 1:**

```
输入: 7->1->6->null, 5->9->2->null
输出: 2->1->9->null	
样例解释: 617 + 295 = 912, 912 转换成链表:  2->1->9->null
```

**样例 2:**

```
输入:  3->1->5->null, 5->9->2->null
输出: 8->0->8->null	
样例解释: 513 + 295 = 808, 808 转换成链表: 8->0->8->null
```

```cpp
/**
 * Definition of singly-linked-list:
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param l1: the first list
     * @param l2: the second list
     * @return: the sum list of l1 and l2 
     */
    ListNode * addLists(ListNode * l1, ListNode * l2) {
		ListNode* result = nullptr, ** prev = &result;
		for (int carry = 0; l1 || l2 || carry;) {
			if (l1) {
				carry += l1->val;
				l1 = l1->next;
			}
			if (l2) {
				carry += l2->val;
				l2 = l2->next;
			}
			*prev = new ListNode(carry % 10);
			prev = &((*prev)->next);
			carry /= 10;
		}
		return result;
    }
};
```

# 172. 删除元素

给定一个数组和一个值,在原地删除与值相同的数字,返回新数组的长度.

元素的顺序可以改变,并且对新的数组不会有影响.

### 样例

给出一个数组 **[0,4,4,0,0,2,4,4]**,和值 4

返回 4 并且4个元素的新数组为**[0,0,0,2]**

```cpp
class Solution {
public:
    /*
     * @param A: A list of integers
     * @param elem: An integer
     * @return: The new length after remove
     */
    int removeElement(vector<int> &A, int elem) {
		for (int i = 0; i < A.size();) {
			if (A[i] == elem) {
				A.erase(A.begin() + i);
			}
			else {
				i++;
			}
		}
		return A.size();
    }
};
```

# 181. 将整数A转换为B

如果要将整数n转换为m,需要改变多少个bit位？

### 样例

```
样例 1:
	输入: n = 31, m = 14
	输出:  2
	
	解释:
	(11111) -> (01110) 需要改变两个位.


样例 2:
	输入: n = 1, m = 7
	输出:  2
	
	解释:
	(001) -> (111) 需要更改两位
```

### 注意事项

*n*和*m*均为32位整数.

```cpp
class Solution {
public:
    /**
     * @param a: An integer
     * @param b: An integer
     * @return: An integer
     */
	int bitSwapRequired(int a, int b) {
		vector<int>binarya(32, 0), binaryb(32, 0);
		if (a >= 0) {
			int i = 0;
			while (a != 0) {
				binarya[i] = a % 2;
				i++;
				a /= 2;
			}
		}
		else {
			a = abs(a);
			int i = 0;
			while (a != 0) {
				binarya[i] = a % 2;
				i++;
				a /= 2;
			}
			for (int j = 0; j < binarya.size(); j++) {
				if (binarya[j] == 0) {
					binarya[j] = 1;
				}
				else {
					binarya[j] = 0;
				}
			}
			for (int k = 0; k < binarya.size(); ++k) {
				if (binarya[k] == 0) {
					binarya[k] = 1;
					break;
				}
				else {
					binarya[k] = 0;
				}
			}
		}
		if (b >= 0) {
			int i = 0;
			while (b != 0) {
				binaryb[i] = b % 2;
				i++;
				b /= 2;
			}
		}
		else {
			b = abs(b);
			int i = 0;
			while (b != 0) {
				binaryb[i] = b % 2;
				i++;
				b /= 2;
			}
			for (int j = 0; j < binaryb.size(); j++) {
				if (binaryb[j] == 0) {
					binaryb[j] = 1;
				}
				else {
					binaryb[j] = 0;
				}
			}
			for (int k = 0; k < binaryb.size(); ++k) {
				if (binaryb[k] == 0) {
					binaryb[k] = 1;
					break;
				}
				else {
					binaryb[k] = 0;
				}
			}
		}
		int res = 0;
		for (int i = 0; i < 32; i++) {
			if (binarya[i] != binaryb[i]) {
				++res;
			}
		}
		return res;
	}
};
```

# 184. 最大数

描述

给出一组非负整数，重新排列他们的顺序把他们组成一个最大的整数。

最后的结果可能很大，所以我们返回一个字符串来代替这个整数。

样例

**样例 1:**

```
输入:[1, 20, 23, 4, 8]
输出:"8423201"
```

**样例 2:**

```
输入:[4, 6, 65]
输出:"6654"
```

挑战

在 O(nlogn) 的时间复杂度内完成。

```c++
class Solution {
public:
    /**
     * @param nums: A list of non negative integers
     * @return: A string
     */
    string largestNumber(vector<int> &nums) {
        string res;
        vector<string> temp;
        for (int item:nums) {
            temp.push_back(to_string(item));
        }
        sortVector(temp);
        for (string item:temp) {
            res += item;
        }
        if (atoi(res.c_str()) == 0) {
            return "0";
        }
        return res;
    }

    void sortVector(vector<string> &vec) {
        for (int i = 0; i < vec.size(); i++) {
            for (int j = 0; j < vec.size() - i - 1; j++) {
                if (vec[j + 1] + vec[j] > vec[j] + vec[j + 1]) {
                    swap(vec[j + 1], vec[j]);
                }
            }
        }
    }
};
```



# 185.  矩阵的之字型遍历

描述

给你一个包含 *m* x *n* 个元素的矩阵 (*m* 行, *n* 列), 求该矩阵的之字型遍历.

样例

```
样例 1:
	输入: [[1]]
	输出:  [1]

样例 2:
	输入:   
	[
    [1, 2,  3,  4],
    [5, 6,  7,  8],
    [9,10, 11, 12]
  ]

	输出:  [1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12]
```

```cpp
class Solution {
public:
    /**
     * @param matrix: An array of integers
     * @return: An array of integers
     */
    vector<int> printZMatrix(vector<vector<int>> &matrix) {
        vector<int>ret;
        if(matrix.empty()||matrix[0].empty()){
            return ret;
        }
        int n=matrix.size(),m=matrix[0].size();
        int i,j;
        for(int s=0;s<=n+m-2;++s){
            if(s%2!=0){
                for(j=min(s,m-1),i=s-j;i<n and i>=0 and j<m and j>=0;++i,--j){
                    ret.push_back(matrix[i][j]);
                }
            }
            else{
                for(i=min(s,n-1),j=s-i;i>=0 and i<n and j>=0 and j<m;--i,++j){
                    ret.push_back(matrix[i][j]);
                }
            }
        }
        return ret;
    }
};
```



# 188. 插入五

给定一个数字,在数字的任意位置插入一个5,使得插入后的这个数字最大

### 样例

**样例 1:**

```
输入:  a = 234
输出: 5234	
```

### 注意事项

|a| \leq 10^6∣*a*∣≤10^6

```cpp
class Solution {
public:
    /**
     * @param a: A number
     * @return: Returns the maximum number after insertion
     */
	int InsertFive(int a) {
		if (a > 0) {
			vector<int>num;
			while (a != 0) {
				num.push_back(a % 10);
				a /= 10;
			}
			size_t numsize = num.size();
			bool add = false;
			for (int i = numsize - 1; i >= 0; --i) {
				if (num[i] < 5) {
					num.insert(num.begin() + i + 1, 5);
					add = true;
					break;
				}
			}
			if (!add) {
				num.push_back(5);
			}
			int sum = 0;
			numsize = num.size();
			for (int i = 0; i < numsize; ++i) {
				sum += num[i] * pow(10, i);
			}
			return sum;
		}
		else if(a<0){
			a = abs(a);
			vector<int>num;
			while (a != 0) {
				num.push_back(a % 10);
				a /= 10;
			}
			size_t numsize = num.size();
			bool add = false;
			for (int i = numsize - 1; i >= 0; --i) {
				if (num[i] > 5) {
					num.insert(num.begin() + i + 1, 5);
					add = true;
					break;
				}
			}
			if (!add) {
				num.push_back(5);
			}
			int sum = 0;
			numsize = num.size();
			for (int i = 0; i < numsize; ++i) {
				sum += num[i] * pow(10, i);
			}
			return -1 * sum;
		}
		else {
			return 50;
		}
	}
};
```

# 267. 最短休息日

描述

由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天

1为营业 0为不营业

样例

**样例 1:**

```
输入:  company=[1,1,0,0],gym=[0,1,1,0]
输出: 2
样例解释: 小Q可以在第一天工作，第二天或第三天健身，小Q最少休息2天。
```

```cpp
class Solution {
public:
    /**
     * @param company: Company business
     * @param gym: Gym business
     * @return: Find the shortest rest day
     */
    int minimumRestDays(vector<int> &company, vector<int> &gym) {
        if (company.empty() || (company.size() != gym.size()))
            return -1;

        // dp size: (n, 3)
        // dp[i][0] :work
        // dp[i][1] :exercise
        // dp[i][2] :rest
        vector<vector<int>> dp(2);
        for (vector<vector<int>>::size_type i = 0; i != 2; i++)
            for (vector<int>::size_type j = 0; j != 3; j++)
                dp[i].push_back(INT_MAX);

        if (company[0] == 1) {
            dp[0][0] = 0;
            dp[1][0] = 0;
        }
        if (gym[0] == 1) {
            dp[0][1] = 0;
            dp[1][1] = 0;
        }

        dp[0][2] = 1;
        dp[1][2] = 1;

        for (vector<vector<int>>::size_type i = 1; i != company.size(); i++) {
            for (vector<int>::size_type j = 0; j != 3; j++)
                dp[1][j] = INT_MAX;

            if (company[i] == 1) {
                dp[1][0] = min(dp[0][1], dp[0][2]);
            }
            if (gym[i] == 1) {
                dp[1][1] = min(dp[0][0], dp[0][2]);
            }
            dp[1][2] = min(min(dp[0][0], dp[0][1]), dp[0][2]) + 1;

            for (vector<int>::size_type j = 0; j != 3; j++)
                dp[0][j] = dp[1][j];
        }
        return min(min(dp[1][0], dp[1][1]), dp[1][2]);
    }
};
```



# 302. 数字配对

描述

给出一个数组 nums*n**u**m**s*，将数组中的数两两配对。
令数组 sums*s**u**m**s* 为配对后每组数字的和，要求 sums*s**u**m**s* 的极差最小。
请计算并返回可能的最小的 sums*s**u**m**s* 的极差。
极差就是数组中最大最小值的差值。

nums*n**u**m**s* 的长度为 n*n*，2 \le n \le 10^52≤*n*≤105 且 n*n* 是**偶数**，0 \le nums_i \le 10^90≤*n**u**m**s**i*≤109。
将数组配对成 (2, 3)(2,3) 和 (5, 1)(5,1)，它们的差为 11。

样例

```
输入：
[2,3,5,1]
输出：
1
```

```cpp
class Solution {
public:
    /**
     * @param nums: the integers to be paired.
     * @return: return the minimum difference of the maximum value and the minimum value after pairing.
     */
    int digitalPairing(vector<int> &nums) {
        if(nums.size()<=2){
            return 0;
        }
        sort(nums.begin(), nums.end());
        int maxval = INT_MIN;
        int minval = INT_MAX;
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int pair = nums[left] + nums[right];
            maxval = max(maxval, pair);
            minval = min(minval, pair);
            left++;
            right--;
        }
        return abs(maxval - minval);
    }
};
```



# 309.  交叉数组

描述

给定两个相同长度的数组,通过取第一个数组的第一个元素,第二个数组的第一个元素,第一个数组的第二个元素...依此类推来交叉它们.返回新的交错数组.
注意 ： 长度 ≤ 10000

样例

```
输入: 
[1,2]
[3,4]
输出: 
[1,3,2,4]
```

```cpp
class Solution {
public:
    /**
     * @param A: the array A
     * @param B: the array B
     * @return: returns an alternate array of arrays A and B.
     */
    vector<int> interleavedArray(vector<int> &A, vector<int> &B) {
        vector<int>res;
        if(A.size()==0){
            return res;
        }
        else{
            size_t size= A.size();
            for(int i=0;i<size;i++){
                res.push_back(A[i]);
                res.push_back(B[i]);
            }
        }
        return res;
    }
};
```

# 334. 队列检查

描述

班上的学生根据他们的年级照片的身高升序排列,确定当前未站在正确位置的学生人数

1<= len(heights) <=10^51<=*l**e**n*(*h**e**i**g**h**t**s*)<=1051<= heights[i] <= 10^91<=*h**e**i**g**h**t**s*[*i*]<=109

样例

```
	输入:  heights = [1,1,3,3,4,1]
	输出: 3
	解释:  经过排序后 heights变成了[1,1,1,3,3,4],有三个学生不在应在的位置上
```

```cpp
bool cmp(int x,int y){
    if(x<y){
        return true;
    }
    else{
        return false;
    }
}
class Solution {
public:
    /**
     * @param heights: Students height
     * @return: How many people are not where they should be
     */
    int orderCheck(vector<int> &heights) {
        int res=0;
        vector<int>count(heights);
        sort(count.begin(),count.end(),cmp);
        for(int i=0;i<count.size();i++){
            if(count[i]!=heights[i]){
                res++;
            }
        }
        return res;
    }
};
```

# 376. 二叉树的路径和

描述

给定一个二叉树,找出所有路径中各节点相加总和等于给定 `目标值` 的路径.

一个有效的路径,指的是从根节点到叶节点的路径.

样例

**样例1:**

```
输入:
{1,2,4,2,3}
5
输出: [[1, 2, 2],[1, 4]]
说明:
这棵树如下图所示：
	     1
	    / \
	   2   4
	  / \
	 2   3
对于目标总和为5,很显然1 + 2 + 2 = 1 + 4 = 5
```

**样例2:**

```
输入:
{1,2,4,2,3}
3
输出: []
说明:
这棵树如下图所示：
	     1
	    / \
	   2   4
	  / \
	 2   3
注意到题目要求我们寻找从根节点到叶子节点的路径.
1 + 2 + 2 = 5, 1 + 2 + 3 = 6, 1 + 4 = 5 
这里没有合法的路径满足和等于3.
```

```
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */


class Solution {
public:
    /*
     * @param root: the root of binary tree
     * @param target: An integer
     * @return: all valid paths
     */
    vector<vector<int>> binaryTreePathSum(TreeNode * root, int target) {
        vector<vector<int>> res;
        if (root == NULL){
            return res;
        }
        vector<int> path;
        dfs(root, target, path, res);
        return res;
    }

private:
    void dfs(TreeNode* root, int target, vector<int>& path, vector<vector<int>>& res){
        // 空节点
        if (root == NULL){
            return;
        }
        path.push_back(root -> val);
        // 叶节点
        if (root -> left == NULL && root -> right == NULL){
            if (target == root -> val){
                res.push_back(vector<int>(path)); // 新的内存
            }
            path.pop_back(); // 原内存
            return;
        }
        // 非叶节点
        dfs(root -> left, target - root -> val, path, res);
        dfs(root -> right, target - root -> val, path, res);
        path.pop_back();
    }
};
```

# 395. 硬币排成线 II

描述

有 `n` 个不同价值的硬币排成一条线。两个参赛者轮流从 **左边** 依次拿走 1 或 2 个硬币，直到没有硬币为止。计算两个人分别拿到的硬币总价值，价值高的人获胜。

请判定 **先手玩家** 必胜还是必败?

若必胜, 返回 `true`, 否则返回 `false`.

样例

**样例 1:**

```
输入: [1, 2, 2]
输出: true
解释: 先手玩家直接拿走两颗硬币即可.
```

**样例 2:**

```
输入: [1, 2, 4]
输出: false
解释: 无论先手拿一个还是两个, 后手可以拿完, 然后总价值更高.
```

*l**e**n*表示硬币数组的长度，下标从 0 开始

用一个数组`dp[i]` 表示从`i`到`len-1` 能拿到的最大值

一个明显的情况就是当`len<=2`时，这时候先手拿的只要全拿走就行了，所以肯定是先手赢。然后我们分析

- 当`i=len`的时候，`dp[len]`没得可拿，所以`dp[len]=0`

- 当`i=len-1`的时候，`dp[len-1]`只有一个可以拿，所以`dp[len-1] = values[len-1]`;

- 当`i = len-2`的时候，`dp[len-2]`有两个可拿，当然是直接拿走,所以`dp[len-2] = values[len-1]+values[len-2]`;

- 当`i=len-3`的时候，剩下最后三个，这时候如果拿一个，对方就会拿走两个，所以，这次要拿两个，所以`dp[len-3] = values[len-2]+ values[len-3]`;

- 当

  ```
  i = len-4
  ```

  以及以后的情况中，显然可以选择拿一个或者拿两个两种情况，我们自然是选择拿最多的那个作为

  ```
  dp
  ```

  的值，那么我们就分分析这两种情况：

  - 第一种，只拿一个,那么对手可能拿两个或者一个，对手肯定是尽可能多拿，所以我们要选择尽可能小的那个，所以`dp[i] = values[i] + min(dp[i+2],dp[i+3])`
  - 第二种，拿两个，同样的情况，`dp[i] = values[i]+ values[i+1]+min(dp[i+3],dp[i+4])`
  - 然后我们取这两种情况下的最大值。

- `dp[0]`表示先手获得的最大值，`sum-dp[0]`表示后手获得的最大值，比较两者即可判断先手是否必胜

 

## 复杂度分析

- 时间复杂度

  ```
  O(n)
  ```

  - `n`为硬币的数量

- 空间复杂度

  ```
  O(n)
  ```

  - `n`为硬币的数量

```cpp
class Solution {
public:
    /*
     * @param : a vector of integers
     * @return: a boolean which equals to true if the first player will win
     */
    bool firstWillWin(vector<int> values) {
        int size = values.size();
        if (size <= 2) {
            return true;
        }
        vector<int> dp(size + 1, 0);
        int sum = 0;
        dp[size - 1] = values[size - 1]; // i=len-1时,只有一个可以拿
        dp[size - 2] = values[size - 1] + values[size - 2]; // i = len-2,有两个可拿，直接拿走
        dp[size - 3] = values[size - 2] + values[size - 3]; // 当i=len-3的时候，剩下最后三个，这时候如果拿一个，对方就会拿走两个，所以这次拿两个
        sum += (values[size - 1] + values[size - 2] + values[size - 3]);
        // 当i = len-4以及以后的情况中，显然可以选择拿一个或者拿两个两种情况，我们自然是选择拿最多的那个作为`dp`的值
        for (int i = size - 4; i >= 0; i--) {
            sum += values[i];
            dp[i] = max(values[i] + min(dp[i + 2], dp[i + 3]),//只拿一个,那么对手可能拿两个或者一个，对手肯定是尽可能多拿，所以我们要选择尽可能小的那个
             values[i] + values[i + 1] + min(dp[i + 3], dp[i + 4]));//拿两个，同样的情况
        }
        // 由于硬币总数是确定的，我们比较一下先手的硬币dp[0]和后手的硬币数量sum-dp[0]就能得到答案 
        return dp[0] > sum - dp[0];
    }
};
```



# 402. 连续子数组求和

给定一个整数数组,请找出一个连续子数组,使得该子数组的和最大.输出答案时,请分别返回第一个数字和最后一个数字的下标.(如果存在多个答案,请返回字典序最小的)

### 样例

**样例 1:**

```
输入: [-3, 1, 3, -3, 4]
输出: [1, 4]
```

**样例 2:**

```
输入: [0, 1, 0, 1]
输出: [0, 3]
解释: 字典序最小.
```

```cpp
class Solution {
public:
    /*
     * @param A: An integer array
     * @return: A list of integers includes the index of the first number and the index of the last number
     */
    vector<int> continuousSubarraySum(vector<int> &A) {
        vector<int>res(2,0);
        int n=A.size();
        int res_sum=A[0];
        int sum=0;
        int l=0;
        for(int r=0;r<n;r++){
            if(sum<0){
                l=r;
                sum=A[r];
            }
            else{
                sum+=A[r];
            }
            if(sum>res_sum){
                res_sum=sum;
                res[0]=l;
                res[1]=r;
            }
        }
        return res;
    }
};
```

# 408. 二进制求和

给定两个二进制字符串,返回他们的和(用二进制表示).

### 样例

**样例 1：**

```
输入：
a = "0", b = "0"
输出：
"0"
```

**样例 2：**

```
输入：
a = "11", b = "1"
输出：
"100"
```

```cpp
class Solution {
public:
    /**
     * @param a: a number
     * @param b: a number
     * @return: the result
     */
    string addBinary(string &a, string &b) {
		int size=max(a.size(),b.size());
		string res;
		reverse(a.begin(),a.end());
		reverse(b.begin(),b.end());
		int carry=0;
		for(int i=0;i<size;i++){
			int tempa,tempb;
			if(i<a.size()){
				tempa=a[i]-'0';
			}
			else{
				tempa=0;
			}
			if(i<b.size()){
				tempb=b[i]-'0';
			}
			else{
				tempb=0;
			}
			int sum=carry+tempa+tempb;
			carry=0;
			if(sum>=2){
				carry=1;
				sum-=2;
			}
			res.push_back(sum+'0');
		}
		if(carry==1){
			res.push_back('1');
		}
		reverse(res.begin(),res.end());
		return res;
    }
};
```

# 402. 删除链表中的元素

描述

删除链表中等于给定值 `val` 的所有节点.

样例

**样例 1：**

```
输入：head = 1->2->3->3->4->5->3->null, val = 3
输出：1->2->4->5->null
```

**样例 2：**

```
输入：head = 1->1->null, val = 1
输出：null
```

```cpp
/**
 * Definition of singly-linked-list:
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *        this->val = val;
 *        this->next = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param head: a ListNode
     * @param val: An integer
     * @return: a ListNode
     */
    ListNode * removeElements(ListNode * head, int val) {
        if(head==NULL){
            return NULL;
        }
        ListNode*befor=NULL;
        ListNode*temp;
        for(temp=head;temp!=NULL;){
            if(temp->val==val){
                if(befor==NULL){
                    head=head->next;
                    if(head==NULL){
                        return NULL;
                    }
                    temp=temp->next;
                }
                else{
                    temp=temp->next;
                }
            }
            else{
                if(befor==NULL){
                    befor=head;
                }
                else{
                    befor->next=temp;
                    befor=temp;
                }
                temp=temp->next;
            }
        }
        befor->next=NULL;
        return head;
    }
};
```

# 419. 罗马数字转整数

描述

给定一个罗马数字，将其转换成整数。

输入数据保证返回的结果1到3999的范围内。

什么是 *罗马数字*?https://en.wikipedia.org/wiki/Roman_numerals[https://zh.wikipedia.org/wiki/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97](https://zh.wikipedia.org/wiki/罗马数字)http://baike.baidu.com/view/42061.htm

样例

**样例 1:**

```
输入: "IV"
输出: 4
```

**样例 2:**

```
输入: "XCIX"
输出: 99
```

```cpp
class Solution {
public:
    int romanToInt(string s) {
        map<char, int> cop;
        cop['I'] = 1;
        cop['V'] = 5;
        cop['X'] = 10;
        cop['L'] = 50;
        cop['C'] = 100;
        cop['D'] = 500;
        cop['M'] = 1000;
        
        int ans= cop[s[0]];
        for(int i=1; i<s.size(); i++)
        {
            ans += cop[s[i]];
            if(cop[s[i]]>cop[s[i-1]])
                ans-=2*cop[s[i-1]];
        }
        return ans;
    }
};
```



# 551.  嵌套列表的加权和

描述

给一个嵌套的整数列表, 返回列表中所有整数由它们的深度加权后的总和. 每一个元素可能是一个整数或一个列表(其元素也可能是整数或列表)

样例

例1:

```
输入: the list [[1,1],2,[1,1]], 
输出: 10. 
解释:
four 1's at depth 2, one 2 at depth 1, 4 * 1 * 2 + 1 * 2 * 1 = 10
```

例2:

```
输入: the list [1,[4,[6]]], 
输出: 27. 
解释:
one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4 * 2 + 6 * 3 = 27
```

```cpp
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer,
 *     // rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds,
 *     // if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds,
 *     // if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class Solution {
private:
    int sum=0,depth=1;
public:
    int depthSum(const vector<NestedInteger>& nestedList) {
        for(auto i:nestedList){
            if(i.isInteger()){
                sum+=i.getInteger()*depth;
            }
            else{
                depth++;
                depthSum(i.getList());
                depth--;
            }
        }
        return sum;
    }
};
```

# 557. 字符计数

描述

对一个字符串中的字符进行计数, 返回一个hashmap, key为字符, value是这个字符出现的次数.

样例

例1:

```
输入:
str = "abca"

输出:
{
  "a": 2,
  "b": 1,
  "c": 1
}
```

例2:

```
输入:
str = "ab"

输出:
{
  "a": 1,
  "b": 1
}
```

```java
public class Solution {
    /*
     * @param str: a string
     * @return: Return a hash map
     */
    public Map<Character, Integer> countCharacters(String str) {
        Map<Character, Integer> res = new HashMap<Character, Integer>();
        for (int i = 0; i < str.length(); i++) {
            char temp = str.charAt(i);
            if (res.containsKey(temp)) {
                res.put(temp, res.get(temp) + 1);
            } else {
                res.put(temp, 1);
            }
        }
        return res;
    }
}
```

# 657. O(1)实现数组插入/删除/随机访问

描述

设计一个数据结构实现在平均 `O(1)` 的复杂度下执行以下所有的操作。

- `insert(val)`: 如果这个元素不在set中，则插入。
- `remove(val)`: 如果这个元素在set中，则从set中移除。
- `getRandom`: 随机从set中返回一个元素。每一个元素返回的可能性必须相同。

样例

```
// 初始化空集set
RandomizedSet randomSet = new RandomizedSet();

// 1插入set中。返回正确因为1被成功插入
randomSet.insert(1);

// 返回错误因为2不在set中
randomSet.remove(2);

// 2插入set中，返回正确，set现在有[1,2]。
randomSet.insert(2);

// getRandom 应该随机的返回1或2。
randomSet.getRandom();

// 从set中移除1，返回正确。set现在有[2]。
randomSet.remove(1);

// 2已经在set中，返回错误。
randomSet.insert(2);

// 因为2是set中唯一的数字，所以getRandom总是返回2。
randomSet.getRandom();
```

```cpp
class RandomizedSet {
public:
    vector<int> arr;
    unordered_map<int,int> value_to_index;
    RandomizedSet() {
        // do intialization if necessary
    }

    /*
     * @param val: a value to the set
     * @return: true if the set did not already contain the specified element or false
     */
    bool insert(int val) {
        // write your code here
        if(value_to_index.count(val)!=0){
            return false;
        }
        arr.push_back(val);
        value_to_index[val]=arr.size()-1;
        return true;
    }

    /*
     * @param val: a value from the set
     * @return: true if the set contained the specified element or false
     */
    bool remove(int val) {
        // write your code here
        if(arr.size()==0||value_to_index.count(val)==0){
            return false;
        }
        int index=value_to_index[val];
        if (index==arr.size()-1){
            arr.pop_back();
            value_to_index.erase(val);
            return true;
        }
        arr[index]=arr[arr.size()-1];
        value_to_index.erase(arr[arr.size()-1] );
        arr.pop_back();
        return true;
    }

    /*
     * @return: Get a random element from the set
     */
    int getRandom() {
        // write your code here
        return arr[rand()%arr.size()];
    }
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * bool param = obj.insert(val);
 * bool param = obj.remove(val);
 * int param = obj.getRandom();
 */
```

# 744. 前K个偶数长度的回文数和

描述

给一整数 k, 得出前 k 个偶数长度的回文数和. 这里的偶数长度是指一个数字的位数为偶数.

样例

**样例1**

```
输入:  k = 3
输出: 66
解释:
11 + 22 + 33  = 66 (前三个偶数长度的回文数和)
```

**样例2**

```
输入:  k = 10
输出: 1496
解释:
11 + 22 + 33 + 44 + 55 + 66 + 77 + 88 + 99 + 1001 = 1496
```

```cpp
class Solution {
public:
    /**
     * @param k: Write your code here
     * @return: the sum of first k even-length palindrome numbers
     */
    int sumKEven(int k) {
        int res = 0;
        for (int i = 0, n = 1; i < k; i++,n++) {
            string temp;
            string temp1;
            temp1 = temp = to_string(n);
            cout<<"temp1="<<temp1<<endl;
            cout<<"temp2="<<temp<<endl;
            reverse(temp1.begin(), temp1.end());
            string temp2 = temp + temp1;
            res+=atoi(temp2.c_str());
        }
        return res;
    }
};
```

# 900. 二叉搜索树中最接近的值

描述

给一棵非空二叉搜索树以及一个target值，找到在BST中最接近给定值的节点值

给出的目标值为浮点数我们可以保证只有唯一一个最接近给定值的节点

样例

**样例1**

```
输入: root = {5,4,9,2,#,8,10} and target = 6.124780
输出: 5
解释：
二叉树 {5,4,9,2,#,8,10}，表示如下的树结构：
        5
       / \
     4    9
    /    / \
   2    8  10
```

**样例2**

```
输入: root = {3,2,4,1} and target = 4.142857
输出: 4
解释：
二叉树 {3,2,4,1}，表示如下的树结构：
     3
    / \
  2    4
 /
1
```

```cpp
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: the given BST
     * @param target: the given target
     * @return: the value in the BST that is closest to the target
     */
    int closestValue(TreeNode * root, double target) {
        // write your code here
        int closest = root->val;
        while (root) {
            if (abs(closest - target) >= abs(root->val - target)) {
                closest = root->val;
            }
            root = target < root->val ? root->left : root->right;
        }
        return closest;        
    }
};
```

# 914. 翻转游戏

描述

翻转游戏：给定一个只包含两种字符的字符串：`+`和`-`。你可以将两个**连续的**`“++”`翻转成`"--"`，你需要翻转一次，并找到翻转后所有可能得到的结果。

编写一个程序，找到字符串在一次有效翻转后的所有可能状态。

样例

**样例1**

```
输入: s = "++++"
输出: 
[
  "--++",
  "+--+",
  "++--"
]
```

**样例2**

```
输入: s = "---+++-+++-+"
输出: 
[
	"---+++-+---+",
	"---+++---+-+",
	"---+---+++-+",
	"-----+-+++-+"
]
```

```cpp
class Solution {
public:
    /**
     * @param s: the given string
     * @return: all the possible states of the string after one valid move
     */
    vector<string> generatePossibleNextMoves(string &s) {
        vector<string> res;
        if(s.empty()){
            return res;
        }
        for (int i = 0; i < s.size() - 1; i++) {
            if (s[i] == '+' and s[i + 1] == '+') {
                string temp = s;
                temp[i] = temp[i + 1] = '-';
                res.push_back(temp);
            }
        }

        return res;
    }
};
```



# 987.  具有交替位的二进制数

描述

给一个正整数,检查它的二进制表示是否具有交替位.即,两个相邻的位总是具有不同的值.

样例

**样例 1:**

```
输入: 5
输出: True
解释:
5 的二进制表示为: 101
```

**样例 2:**

```
输入: 7
输出: False
解释:
7 的二进制表示为: 111.
```

**样例 3:**

```
输入: 11
输出: False
解释:
11 的二进制表示为: 1011.
```

**样例 4:**

```
输入: 10
输出: True
解释:
10 的二进制表示: 1010.
```

```cpp
class Solution {
public:
    /**
     * @param n: a postive Integer
     * @return: if two adjacent bits will always have different values
     */
    bool hasAlternatingBits(int n) {
        vector<int>count;
        while(n!=0){
            count.push_back(n%2);
            n/=2;
        }
        if(count[0]==0){
            for(int i=1;1;1){
                if(i<count.size()){
                    if(count[i]==1){
                        i++;
                    }
                    else{
                        return false;
                    }
                }
                else{
                    break;
                }
                if(i<count.size()){
                    if(count[i]==0){
                        i++;
                    }
                    else{
                        return false;
                    }
                }
                else{
                    break;
                }
            }
            return true;
        }
        else{
            for(int i=1;1;1){
                if(i<count.size()){
                    if(count[i]==0){
                        i++;
                    }
                    else{
                        return false;
                    }
                }
                else{
                    break;
                }
                if(i<count.size()){
                    if(count[i]==1){
                        i++;
                    }
                    else{
                        return false;
                    }
                }
                else{
                    break;
                }
            }
            return true;
        }
    }
};
class Solution2 {
public:
    /**
     * @param n: a postive Integer
     * @return: if two adjacent bits will always have different values
     */
    bool hasAlternatingBits(int n) {
        bool sign;
        if(n%2==0){
            sign=true;
            n/=2;
            while(n!=0){
                if(sign==true){
                    if(n%2!=0){
                        n/=2;
                        sign=false;
                    }
                    else{
                        return false;
                    }
                }
                else{
                    if(n%2==0){
                        n/=2;
                        sign=true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return true;
        }
        else{
            sign=false;
            n/=2;
            while(n!=0){
                if(sign==false){
                    if(n%2==0){
                        n/=2;
                        sign=true;
                    }
                    else{
                        return false;
                    }
                }
                else{
                    if(n%2!=0){
                        n/=2;
                        sign=false;
                    }
                    else{
                        return false;
                    }
                }
            }
            return true;
        }
    }
};
```

# 988.  硬币摆放

描述

你有 n 枚硬币,想要摆放成阶梯形状,即第 k 行恰好有 k 枚硬币.

给出 n,找到可以形成的**完整**楼梯行数.

n 是一个非负整数,且在32位有符号整数范围内.

样例

**样例 1:**

```
输入：n = 5
输出：2
解释：
硬币可以形成以下行：
¤
¤ ¤
¤ ¤
因为第3行不完整,我们返回2.
```

**样例 2:**

```
输入：n = 8
输出：3
解释：
硬币可以形成以下行：
¤
¤ ¤
¤ ¤ ¤
¤ ¤
因为第4行不完整,我们返回3.
```

```cpp
class Solution {
public:
    /**
     * @param n: a non-negative integer
     * @return: the total number of full staircase rows that can be formed
     */
    int arrangeCoins(int n) {
        int res=1,sum=0;
        while(1){
            sum+=res;
            if(sum<=n){
                res++;
            }
            else{
                return res-1;
            }
        }
    }
};
```

# 1013. 独特的摩尔斯编码

描述

摩尔斯电码定义了一种标准编码,把每个字母映射到一系列点和短划线,例如：`a` -> `.-`,`b` -> `-...`,`c` ->`-.-.`.

给出26个字母的完整编码表格：

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
```

现在给定一个单词列表,每个单词中每个字母可以写成摩尔斯编码. 例如,`cab`可以写成`-.-.-....-`,(把`c`,`a`,`b`的莫尔斯编码串接起来). 我们称之为一个词的转换.

返回所有单词中不同变换的数量.

`words`的长度最多为`100`.每一个`words[i]`的长度范围为`[1, 12]`.`words[i]`仅仅包含小写字母.

样例

**样例1：**

```
输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
每一个单词的变换是:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

这里有两种不同的变换结果： "--...-."和"--...--.".
```

**样例2：**

```
输入: words = ["a", "b"]
输出: 2
解释: 
每一个单词的变换是:
"a" -> ".-"
"b" -> "-..."
这里有两种不同的变换结果：".-" and "-...".
```

```cpp
class Solution {
public:
    /**
     * @param words: the given list of words
     * @return: the number of different transformations among all words we have
     */
    int uniqueMorseRepresentations(vector<string> &words) {
        string cnt[]={".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        set<string> coll;
        for(string item:words){
            string tmp;
            for(int i=0;i<item.size();++i){
                tmp+=cnt[item[i]-'a'];
            }
            coll.insert(tmp);
        }
        return coll.size();
    }
};
```

# 1029. 寻找最便宜的航行旅途(最多经过k个中转站)

描述

有n个城市被一些航班所连接.每个航班 (u,v,w) 从城市u出发,到达城市v,价格为w.

给定城市数目 `n`,所有的航班`flights`.你的任务是找到从起点`src`到终点站`dst`的最便宜线路的价格,而旅途中最多只能中转`K`次.

如果没有找到合适的线路,返回 `-1`.

总城市数 `n` 在 1-100 之间,每个城市被标号为 0 到 n-1.航线的总数在 0 到 n * (n - 1) / 2 之间每条航线会被以 [出发站,终点站,价格] 的形式展现.每条航线的价格都在 1-10000之间.中转站的总数限制范围为 0 到 n-1 之间.不会有重复或者自环航线出现

样例

**样例 1:**

```
输入: 
  n = 3,
  flights = [[0,1,100],[1,2,100],[0,2,500]],
  src = 0, dst = 2, K = 0
输出: 500
```

**样例 2:**

```
输入: 
  n = 3,
  flights = [[0,1,100],[1,2,100],[0,2,500]],
  src = 0, dst = 2, K = 1
输出: 200
```

```cpp
class Solution {
public:
    /**
     * @param n: a integer
     * @param flights: a 2D array
     * @param src: a integer
     * @param dst: a integer
     * @param K: a integer
     * @return: return a integer
     */
    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int K) {
        
        unordered_map<int, vector<int>> outdegrees;
        
        for (int i = 0; i < flights.size(); ++i) {
            outdegrees[flights[i][0]].push_back(i);
        }
        
        queue<pair<int, int>> que; //flight and money

        int k = 0, ans = INT_MAX;
        
        for (int i = 0; i < outdegrees[src].size(); ++i) {
            que.push(make_pair(outdegrees[src][i], 0));
        }
        
        unordered_map<int, int> memo;
        
        while (!que.empty() && k <= K) {
            int size = que.size();
            for (int i = 0; i < size; ++i) {
                int curr_f = que.front().first;
                int start = flights[curr_f][0];
                int end = flights[curr_f][1];
                int curr_mon = que.front().second + flights[curr_f][2];
                que.pop();
                if (memo.find(end) == memo.end()) {
                    memo[end] = curr_mon;
                }
                else {
                    if (memo[end] <= curr_mon) {
                        continue;
                    }
                    memo[end] = curr_mon;
                }
                if (end == dst) {
                    ans = min(ans, curr_mon);
                }
                for (int j = 0; j < outdegrees[end].size(); ++j) {
                    que.push(make_pair(outdegrees[end][j], curr_mon));
                }
            }
            k++;
        }
        
        return ans == INT_MAX ? -1 : ans;
    }
};
```

# 1033. BST中的最小差值

描述

给定一个确定根的二叉搜索树,返回树中任意两个不同节点的值的最小差.

1.这棵二叉搜索树的大小在 2 到`100`之间.
2.这棵二叉搜索树是存在的,每个点的数值是一个整数,而且每个点的数值将会是不同的.

样例

**样例1:**

```
输入: root = {4,2,6,1,3,#,#}
输出: 1
解释:
请留意,root是一个树节点的结构,而非一个普通数组.

给定的树{4,2,6,1,3,#,#}的样子如下图：

          4
        /   \
      2      6
     / \    
    1   3  

在这棵树中,最小数值差距为 1, 它出现在node 1 与 node 2 之间, 也同时存在 node 3 与 node 2之间
```

**样例2:**

```
输入: root = {5,1,8}
输出: 3
解释:
请留意,root是一个树节点的结构,而非一个普通数组.

给定的树{5,1,8}的样子如下图：

     5
   /   \
 1      8
 
在这棵树中,最小数值差距为 3, 它出现在node 5与node 8之间.
```

```cpp
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    vector<int> nums;
    
    /**
     * @param root: the root
     * @return: the minimum difference between the values of any two different nodes in the tree
     */
    int minDiffInBST(TreeNode *root) {
        // Write your code here
        traverse(root);
        int ret = INT_MAX;
        sort(nums.begin(), nums.end());
        for (int i = 1; i < nums.size(); i++) {
            ret = min(ret, nums[i] - nums[i - 1]);
        }
        return ret;
    }


    void traverse(TreeNode *root) {
        if (root != NULL) {
            nums.push_back(root->val);
            traverse(root->left);
            traverse(root->right);
        }
    }
};
```

# 1059. 删除并赚取

描述

给定一个整数数组，你可以在这个数组上进行操作。

在每次操作中，你可以选择任意数num[i]并且删除它从而得到num[i]的分数。在此之后，你必须删除掉任何和num[i]-1或者num[i]+1相等的元素。

你将从0分开始。返回你通过这些操作可以获得的最大的分数。

数组的长度至多为20000。
每一个元素num[i]是一个在范围 [1, 10000]的整数。

样例

```
样例 1:
	输入:  nums = [3, 4, 2]
	输出:  6
	
	解释:
	删除4，获得4分。同时删除3
	然后删除2，获得2分。

	
样例 2:
	输入: nums = [2, 2, 3, 3, 3, 4]
	输出:  9
	
	解释:
	删除3，获得3分。然后删除2和4
	然后再删除3，获得3分。
	再删除3，获得3分。
	
```

```cpp
class Solution {
public:
    /**
     * @param nums: a list of integers
     * @return: return a integer
     */
    int deleteAndEarn(vector<int> &nums) {
        // write your code here
        vector<int> counters(10001);
        for (int i = 0; i < nums.size(); i++) {
            counters[nums[i]]++;
        }
        
        int dp[10001];
        dp[1] = counters[1];
        for (int i = 2; i <= 10000; i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + i * counters[i]);
        }
        
        return dp[10000];
    }
};
```



# 1148. 最长和谐子序列

描述

我们将一个和谐数组定义为是其最大值和最小值之间的差值恰好为1的数组.

现在,给定一个整数数组,您需要在其所有可能的子序列中找到其最长的和谐子序列的长度.

输入数组的长度不会超过20,000.

样例

```
输入：[1,3,2,2,5,2,3,7]
输出：5
解释：最长的和谐子序列是[3,2,2,2,3].
```

```cpp
class Solution {
public:
    /**
     * @param nums: a list of integers
     * @return: return a integer
     */
    int findLHS(vector<int> &nums) {
        map<int,int>count;
        int ans=0;
        for(auto num:nums){
            count[num]++;
        }
        for(auto num:nums){
            if(count[num] and count[num-1]){
                ans=max(ans,count[num]+count[num-1]);
            }
        }
        return ans;
    }
};
```

# 1150. 分数加法和减法

描述

给定表示分数加法和减法表达式的字符串，你需要以字符串格式返回计算结果。 最终结果应该是不可简化的分数。 如果您的最终结果是整数，例如2，则需要将其更改为具有分母1的分数格式。因此，在这种情况下，2应转换为2/1。

输入字符串仅包含'0'到'9'，'/'，'+'和' - '。 输出也是如此。
每个分数（输入和输出）具有±分子/分母的格式。 如果第一个输入分数或输出为正，则省略'+'。
输入仅包含有效的不可约分数，其中每个分数的分子和分母将始终在[1,10]范围内。 如果分母为1，则表示该分数实际上是上面定义的分数格式的整数。
给定分数的数量将在[1,10]范围内。
最终结果的分子和分母保证有效且在32位int范围内。

样例

```
输入:"-1/2+1/2"
输出: "0/1"

输入:"-1/2+1/2+1/3"
输出: "1/3"

输入:"1/3-1/2"
输出: "-1/6"

输入:"5/3+1/3"
输出: "2/1"
```

```cpp
class Solution {
public:
    /**
     * @param expression: a string
     * @return: return a string
     */
    string fractionAddition(string &expression) {
        string res;
        vector<vector<int>> cnt = split(expression);
        int count1 = cnt[0][0], count2 = cnt[0][1];
        for (int i = 1; i < cnt.size(); i++) {
            if (count2 == cnt[i][1]) {
                count1 += cnt[i][0];
                int time1=gcd(count1,count2);
                count1=count1/time1;
                count2=count2/time1;
            } else {
                int time = lcm(count2, cnt[i][1]);
                count1 = (time / count2) * count1 + (time / cnt[i][1]) * cnt[i][0];
                count2 = time;
                int time1=gcd(count1,count2);
                count1=count1/time1;
                count2=count2/time1;
            }
        }
        if(count1*count2<0){
            count1=-abs(count1);
            count2=abs(count2);
        }
        if (count1 == 0) {
            return "0/1";
        } else {
            res = to_string(count1) + "/" + to_string(count2);
            return res;
        }
    }

    vector<vector<int>> split(string &str) {
        vector<vector<int>> res;
        vector<string> cnt;
        for (int pos = 0, pos1 = 0; pos < str.size(); pos = pos1) {
            pos1 = str.find_first_of("+-", pos + 1);
            if (pos1 == string::npos) {
                string temp(str.begin() + pos, str.end());
                cnt.push_back(temp);
                break;
            }
            string temp(str.begin() + pos, str.begin() + pos1);
            cnt.push_back(temp);
        }
        for (int i = 0; i < cnt.size(); i++) {
            string temp1(cnt[i].begin(), cnt[i].begin() + cnt[i].find_first_of('/'));
            string temp2(cnt[i].begin() + cnt[i].find_first_of('/') + 1, cnt[i].end());
            vector<int> tempvec;
            tempvec.push_back(atoi(temp1.c_str()));
            tempvec.push_back(atoi(temp2.c_str()));
            res.push_back(tempvec);
        }
        return res;
    }

    int lcm(int m, int n) {
        int max = (m > n) ? m : n;
        while (true) {
            if (max % m == 0 && max % n == 0) {
                return max;
            }
            max++;
        }
    }

    int gcd(int a, int b) {
        if (a % b == 0) {
            return b;
        } else {
            gcd(b, a % b);
        }
    }
};
```



# 1178. 学生出勤记录 I

描述

给定一个字符串表示学生出勤记录，记录仅由下列三个字符组成：

- **'A'** : 缺席（Absent）.
- **'L'** : 迟到（Late）.
- **'P'** : 到场（Present）.

如果学生的出勤情况不包含 **超过一个'A'(缺席)** 或者 **超过连续两个'L'(迟到)** ，那么他就应该受到奖励。

返回该学生是否会受到奖励。

样例

**样例 1:**

```
输入: "PPALLP"
输出: True
```

**样例 2:**

```
输入: "PPALLL"
输出: False
```

```cpp
class Solution {
public:
    /**
     * @param s: a string
     * @return: whether the student could be rewarded according to his attendance record
     */
    bool checkRecord(string &s) {
        int cntA = 0;
        int cntL = 0;
        for (char i : s) {
            if (i == 'A') {
                ++cntA;
                cntL = 0;
            } else if (i == 'L') {
                ++cntL;
                if (cntL > 2) {
                    return false;
                }
            } else {
                cntL = 0;
            }
        }
        if (cntA > 1) {
            return false;
        }
        return true;
    }
};
```

# 1579. 字母串计算

描述

在型月世界里面，普通人都会解决一个问题，这个问题是有一串英文字母，每次可以删掉一个英文字母
求最少删多少次可以让每个字母出现的次数不同

只有小写字母，英文串的长度不会超过100000

样例

**样例 1：**

```
输入："aaabbb"
输出：1
解释：因为'a'的个数有三个，'b'的个数也有三个，所以删掉一个'a'或者一个'b'都可以满足题意
```

**样例 2：**

```
输入："abcd"
输出：3
解释：因为'a','b','c','d'各有一个，所以需要删掉任意三个来满足题意
```

```cpp
class Solution {
public:
    /**
     * @param aString: letter string
     * @return: the Minimum times
     */
    int Kstart(string &aString) {
       int charCnt[26] = {0};
       for (char& c : aString) {
          ++charCnt[c - 'a'];
       }
       map<int, int, greater<int>> cntMap;
       for (int& cnt : charCnt) {
         if (cnt > 0) ++cntMap[cnt];
       }

       int res = 0;
       while(!cntMap.empty()) {
          auto it = cntMap.begin();
          const int h = it->first, cnt = it->second;
          if (h == 1) {
             res += cnt - 1;
             break;
          }
          cntMap.erase(it);

          for (int i = 1; i < cnt; res += i++) {
             ++cntMap[h - i];
          }
       }

       return res;
    }
};
```



# 1587.  字符串切分

描述

现在有一个字符串,首字符代表一级分隔符,分隔不同的键值对key-value;第二个字符代表二级分隔符,分隔key和value;后面的字符串表示待处理的字符串.请给出所有的有效键值对.

有效键值对即key和value均不为空的键值对.
题目保证分隔符不为字母或数字,待处理的字符串中只包含两种分隔符：小写字母和数字,且两个一级分隔符中间最多只出现一个二级分隔符.
题目保证所给字符串长度不超过1000.

样例

#### 样例1

```
输入:"#:a:3#b:8#c:9"
输出:[["a","3"],["b","8"],["c","9"]]
```

#### 样例2

```
输入:"#:aa:3#b:853#:9"
输出:[["aa","3"],["b","853"]]
```

```cpp
class Solution {
public:
    /**
     * @param str: the string need to be processed
     * @return: all the valid key-value pairs.
     */
    vector<vector<string>> StringSeg(string &str) {
        vector<vector<string>> res;
        char split = str[0];
        char dive_split = str[1];
        str.erase(str.begin(), str.begin() + 2);
        while (str.size() != 0) {
            string temp_key_value;
            if (str.find(split) != string::npos) {
                temp_key_value = str.substr(0, str.find_first_of(split));
                str.erase(0, str.find_first_of(split) + 1);
            } else {
                temp_key_value = str;
                str = "";
            }
            string temp_key, temp_value;
            if (temp_key_value.find(dive_split) != string::npos) {
                temp_key = temp_key_value.substr(0, temp_key_value.find(dive_split));
                temp_value = temp_key_value.substr(temp_key_value.find(dive_split) + 1, string::npos);
                if (!temp_key.empty() and !temp_value.empty()) {
                    vector<string> temp_vec = {temp_key, temp_value};
                    res.push_back(temp_vec);
                }
            }
        }
        return res;
    }
};
```

# 1746. 二叉搜索树结点最小距离



给定一个二叉搜索树的根结点 root, 返回树中任意两节点的差的最小值.

### 样例

**样例 1:**

```
输入: root = {4,2,6,1,3}
输出: 1
解释:
注意,root是树结点对象(TreeNode object),而不是数组.

给定的树 [4,2,6,1,3,null,null] 可表示为下图:

          4
        /   \
      2      6
     / \    
    1   3  

最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值.
```

**样例 2:**

```
输入: root = {2,1}
输出: 1
解释:
注意,root是树结点对象(TreeNode object),而不是数组.

给定的树 {2,1} 可表示为下图:

      2
     / 
    1 

最小的差值是 1, 它是节点1和节点2的差值.
```

### 注意事项

-    二叉树的大小范围在 2 到 100.
-    二叉树总是有效的,每个节点的值都是整数,且不重复.

```cpp
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    int res=INT_MAX,pre=-1;
    /**
     * @param root:  a Binary Search Tree (BST) with the root node
     * @return: the minimum difference
     */
    int minDiffInBST(TreeNode * root) {
        if(root->left!=NULL){
            minDiffInBST(root->left);
        }
        if(pre>=0){
            res=min(res,root->val-pre);
        }
        pre=root->val;
        if(root->right!=NULL){
            minDiffInBST(root->right);
        }
        return res;
    }
};
```

# 1789. 区分用户名

描述

给出一组用户名，如果有重复的用户名，则在用户名后添加数字区别，并返回修改后的数组。

样例

**样例 1:**

```
输入：["aa", "bb", "cc", "bb", "aa", "aa", "aa"]
输出：["aa","bb","cc","bb1","aa1","aa2","aa3"]
解释：
"bb"第二次出现输出为"bb1"
"aa"第二次出现输出为"aa1"
"aa"第三次出现输出为"aa2"
"aa"第四次出现输出为"aa3"
```

**样例 2:**

```
输入：[aa, bb, cc, aa]
输出：[aa, bb, cc, aa1]
解释："aa"第二次出现输出为"aa1"
```

```cpp
class Solution {
public:
    /**
     * @param names: a string array
     * @return: the string array
     */
    vector<string> DistinguishUsername(vector<string> &names) {
        vector<string> res;
        map<string, int> cnt;
        for (string str:names) {
            if (cnt.find(str) != cnt.end()) {
                cnt[str]++;
            } else {
                cnt[str] = 1;
            }
            string temp = str;
            if (cnt[str] != 1) {
                string tail = to_string(cnt[str] - 1);
                temp += tail;
            }
            res.push_back(temp);
        }
        return res;
    }
};
```

# 1816. 使结果不超过阈值的最小除数

描述

给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。

请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。

每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。

题目保证一定有解。

1 <= nums.length <= 5 * 10^41 <= nums[i] <= 10^6nums.length <= threshold <= 10^6

样例

```
示例 1：

输入：nums = [1,2,5,9], threshold = 6
输出：5
解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。
如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。
示例 2：

输入：nums = [2,3,5,7,11], threshold = 11
输出：3
示例 3：

输入：nums = [19], threshold = 5
输出：4
```

```cpp
class Solution {
public:
    /**
     * @param nums: an array of integers
     * @param threshold: an integer
     * @return: return the smallest divisor
     */
    bool check(vector<int> &nums, int mid, int threshold){
        
        int total = 0;
        for (int i = 0; i < nums.size(); i++) total += (nums[i] + mid - 1) / mid;
        if(total <= threshold) return true;
        return false;
    }
    int smallestDivisor(vector<int> &nums, int threshold) {
        
        int left = 1, right = -1;
        for (int i = 0; i < nums.size(); i++) right = max(right, nums[i]);

        while (left + 1 < right) {
            int mid = (left + right) / 2;
            if (check(nums, mid, threshold)) right = mid;
            else left = mid;
        }
        if (check(nums, left, threshold)) return left;
        return right;
    }
};
```

# 2506. 删除不匹配的括号

描述

你将得到一个由小写字母 `a-z` ，左括号 `'('` 和右括号 `')'` 构成的字符串 `s`。
你的任务是删除**尽可能少**的括号，使得 `s` 里面的括号匹配。
你需要返回删除括号后的字符串。
由于答案可能会有很多，所以你只需要返回任意一个正确答案。

例如：`"()"`, `"(())"`, `"()()"`, `"(())()"` 是括号匹配的字符串， 而 `")("`, `"(()"`, `"()()("`, `"()())"` 则是括号不匹配的字符串。

没有括号的字符串（如：`abcd`）或空串 `""` 也算一个括号匹配的字符串。0 \leq0≤ `s` 的长度 \leq 10^5≤105你**只能**对原串进行**括号删除**的操作，其他操作将**不被允许**。

样例

**样例1：**

输入：

```
s = "a(b(c(de)fgh)"
```

输出：

```
"a(b(cde)fgh)"
```

解释：

正确答案有三个："ab(c(de)fgh)"，"a(bc(de)fgh)"，"a(b(cde)fgh)"。
你只需要返回任何一个。

**样例2：**

输入：

```
s = "((("
```

输出：

```
""
```

解释：

空串也属于括号匹配的字符串。

```cpp
class Solution {
public:
    /**
     * @param s: A string with lowercase letters and parentheses
     * @return: A string which has been removed invalid parentheses
     */
    string removeParentheses(string &s) {
        stack<int> stk;
        for (int i = 0; i < s.size(); ) {
            if (s[i] == '(') {
                stk.push(i);
                i++;
            } else if (s[i] == ')') {
                if (!stk.empty()) {
                    stk.pop();
                    i++;
                }else{
                    s.erase(i,1);
                }
            }else{
                i++;
            }
        }
        while (!stk.empty()) {
            s.erase(stk.top(), 1);
            stk.pop();
        }
        return s;
    }
};
```

